{"ast":null,"code":"import { ChainId } from '@pangolindex/sdk';\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core';\nimport { useEffect, useState } from 'react';\nimport { isMobile } from 'react-device-detect';\nimport { gnosisSafe, injected, xDefi } from '../connectors';\nimport { IS_IN_IFRAME, NetworkContextName } from '../constants';\nexport function useActiveWeb3React() {\n  const context = useWeb3ReactCore();\n  const contextNetwork = useWeb3ReactCore(NetworkContextName);\n  return context.active ? context : contextNetwork;\n}\nexport function useEagerConnect() {\n  const {\n    activate,\n    active\n  } = useWeb3ReactCore(); // specifically using useWeb3ReactCore because of what this hook does\n\n  const [tried, setTried] = useState(false);\n  const [triedSafe, setTriedSafe] = useState(!IS_IN_IFRAME);\n  useEffect(() => {\n    const eagerConnect = async () => {\n      if (!triedSafe) {\n        gnosisSafe.isSafeApp().then(loadedInSafe => {\n          if (loadedInSafe) {\n            activate(gnosisSafe, undefined, true).catch(() => {\n              setTriedSafe(true);\n            });\n          } else {\n            setTriedSafe(true);\n          }\n        });\n      } else {\n        const isMetaMask = await injected.isAuthorized();\n        const existingConnector = isMetaMask ? injected : xDefi;\n        existingConnector.isAuthorized().then(isAuthorized => {\n          if (isAuthorized) {\n            activate(existingConnector, undefined, true).catch(() => {\n              setTried(true);\n            });\n          } else {\n            if (isMobile && (window.ethereum || window.xfi.ethereum)) {\n              activate(existingConnector, undefined, true).catch(() => {\n                setTried(true);\n              });\n            } else {\n              setTried(true);\n            }\n          }\n        });\n      }\n    };\n\n    eagerConnect();\n  }, [activate, triedSafe, setTriedSafe]); // intentionally only running on mount (make sure it's only mounted once :))\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(() => {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n  return tried;\n}\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\n\nexport function useInactiveListener() {\n  let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const {\n    active,\n    error,\n    activate\n  } = useWeb3ReactCore(); // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error);\n        });\n      };\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error);\n          });\n        }\n      };\n\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n\n    return undefined;\n  }, [active, error, suppress, activate]);\n}\nexport const useChainId = () => {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  return chainId || ChainId.AVALANCHE;\n};","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/hooks/index.ts"],"names":["ChainId","useWeb3React","useWeb3ReactCore","useEffect","useState","isMobile","gnosisSafe","injected","xDefi","IS_IN_IFRAME","NetworkContextName","useActiveWeb3React","context","contextNetwork","active","useEagerConnect","activate","tried","setTried","triedSafe","setTriedSafe","eagerConnect","isSafeApp","then","loadedInSafe","undefined","catch","isMetaMask","isAuthorized","existingConnector","window","ethereum","xfi","useInactiveListener","suppress","error","on","handleChainChanged","console","handleAccountsChanged","accounts","length","removeListener","useChainId","chainId","AVALANCHE"],"mappings":"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","sourcesContent":["import { Web3Provider } from '@ethersproject/providers'\nimport { ChainId } from '@pangolindex/sdk'\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core'\nimport { Web3ReactContextInterface } from '@web3-react/core/dist/types'\nimport { useEffect, useState } from 'react'\nimport { isMobile } from 'react-device-detect'\nimport { gnosisSafe, injected, xDefi } from '../connectors'\nimport { IS_IN_IFRAME, NetworkContextName } from '../constants'\n\nexport function useActiveWeb3React(): Web3ReactContextInterface<Web3Provider> & { chainId?: ChainId } {\n  const context = useWeb3ReactCore<Web3Provider>()\n  const contextNetwork = useWeb3ReactCore<Web3Provider>(NetworkContextName)\n  return context.active ? context : contextNetwork\n}\n\nexport function useEagerConnect() {\n  const { activate, active } = useWeb3ReactCore() // specifically using useWeb3ReactCore because of what this hook does\n  const [tried, setTried] = useState(false)\n  const [triedSafe, setTriedSafe] = useState<boolean>(!IS_IN_IFRAME)\n\n  useEffect(() => {\n    const eagerConnect = async () => {\n      if (!triedSafe) {\n        gnosisSafe.isSafeApp().then(loadedInSafe => {\n          if (loadedInSafe) {\n            activate(gnosisSafe, undefined, true).catch(() => {\n              setTriedSafe(true)\n            })\n          } else {\n            setTriedSafe(true)\n          }\n        })\n      } else {\n        const isMetaMask = await injected.isAuthorized()\n\n        const existingConnector = isMetaMask ? injected : xDefi\n\n        existingConnector.isAuthorized().then(isAuthorized => {\n          if (isAuthorized) {\n            activate(existingConnector, undefined, true).catch(() => {\n              setTried(true)\n            })\n          } else {\n            if (isMobile && (window.ethereum || window.xfi.ethereum)) {\n              activate(existingConnector, undefined, true).catch(() => {\n                setTried(true)\n              })\n            } else {\n              setTried(true)\n            }\n          }\n        })\n      }\n    }\n\n    eagerConnect()\n  }, [activate, triedSafe, setTriedSafe]) // intentionally only running on mount (make sure it's only mounted once :))\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect(() => {\n    if (active) {\n      setTried(true)\n    }\n  }, [active])\n\n  return tried\n}\n\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\nexport function useInactiveListener(suppress = false) {\n  const { active, error, activate } = useWeb3ReactCore() // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const { ethereum } = window\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error)\n        })\n      }\n\n      const handleAccountsChanged = (accounts: string[]) => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error)\n          })\n        }\n      }\n\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n        }\n      }\n    }\n    return undefined\n  }, [active, error, suppress, activate])\n}\n\nexport const useChainId = () => {\n  const { chainId } = useActiveWeb3React()\n  return chainId || ChainId.AVALANCHE\n}\n"]},"metadata":{},"sourceType":"module"}