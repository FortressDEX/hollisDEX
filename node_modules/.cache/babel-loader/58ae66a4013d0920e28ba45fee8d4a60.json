{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GelatoStopLimitOrders = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst constants_1 = require(\"../constants\");\n\nconst core_1 = require(\"./core\");\n\nconst stoplimit_1 = require(\"../utils/queries/stoplimit\");\n\nclass GelatoStopLimitOrders extends core_1.GelatoBase {\n  constructor(chainId, signerOrProvider, handler) {\n    var _a;\n\n    if (handler && !(0, core_1.isValidChainIdAndHandler)(chainId, handler)) {\n      throw new Error(\"Invalid chainId and handler\");\n    }\n\n    const sotplossHandlers = constants_1.NETWORK_STOP_LIMIT_HANDLERS[chainId];\n\n    if (!handler) {\n      throw new Error(\"No Handler defined\");\n    }\n\n    if (handler && !sotplossHandlers.includes(handler)) {\n      throw new Error(\"Handler not supported\");\n    }\n\n    const moduleAddress = constants_1.GELATO_STOP_LIMIT_ORDERS_MODULE_ADDRESS[chainId];\n    if (!moduleAddress) throw new Error(\"Invalid chainId and handler\");\n    const handlerAddress = (_a = constants_1.HANDLERS_ADDRESSES[chainId][handler]) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    super(chainId, moduleAddress, signerOrProvider, handler, handlerAddress);\n  }\n\n  submitStopLimitOrder(inputToken, outputToken, inputAmount, maxReturn) {\n    let checkAllowance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let overrides = arguments.length > 5 ? arguments[5] : undefined;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this.signer) throw new Error(\"No signer\");\n      if (!maxReturn) throw new Error(\"No StopLimit defined\");\n      const owner = yield this.signer.getAddress();\n      const txData = yield this.encodeStopLimitOrderSubmission(inputToken, outputToken, inputAmount, maxReturn, owner, checkAllowance);\n      return this.signer.sendTransaction(Object.assign(Object.assign({}, overrides), {\n        to: txData.to,\n        data: txData.data,\n        value: ethers_1.BigNumber.from(txData.value)\n      }));\n    });\n  }\n\n  encodeStopLimitOrderSubmission(inputToken, outputToken, inputAmount, maxReturn, owner) {\n    let checkAllowance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const {\n        payload\n      } = yield this.encodeStopLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, maxReturn, owner, checkAllowance);\n      return payload;\n    });\n  }\n\n  encodeStopLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, maxReturnToBeParsed, owner) {\n    let checkAllowance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    var _a;\n\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!maxReturnToBeParsed) throw new Error(\"No StopLimit defined\");\n      if (!this.handlerAddress) throw new Error(\"No handlerAddress\");\n      const randomSecret = ethers_1.utils.hexlify(ethers_1.utils.randomBytes(19)).replace(\"0x\", \"\"); // 0x67656c61746f6e6574776f726b = gelatonetwork in hex\n\n      const fullSecret = `0x67656c61746f6e6574776f726b${randomSecret}`;\n      const {\n        privateKey: secret,\n        address: witness\n      } = new ethers_1.Wallet(fullSecret);\n      const {\n        minReturn\n      } = this.getFeeAndSlippageAdjustedMinReturn(maxReturnToBeParsed);\n      const payload = yield this._encodeSubmitData(inputToken, outputToken, owner, witness, inputAmount, maxReturnToBeParsed, minReturn, secret, checkAllowance);\n      const encodedData = this.abiEncoder.encode([\"address\", \"uint256\", \"address\", \"uint256\"], [outputToken, minReturn, this.handlerAddress, maxReturnToBeParsed]);\n      return {\n        payload,\n        secret,\n        witness,\n        order: {\n          id: this._getKey({\n            module: this.moduleAddress,\n            inputToken,\n            owner,\n            witness,\n            data: encodedData\n          }),\n          module: this.moduleAddress.toLowerCase(),\n          data: encodedData,\n          inputToken: inputToken.toLowerCase(),\n          outputToken: outputToken.toLowerCase(),\n          owner: owner.toLowerCase(),\n          witness: witness.toLowerCase(),\n          inputAmount: inputAmount.toString(),\n          minReturn: minReturn.toString(),\n          maxReturn: maxReturnToBeParsed.toString(),\n          adjustedMinReturn: maxReturnToBeParsed.toString(),\n          inputData: payload.data.toString(),\n          secret: secret.toLowerCase(),\n          handler: (_a = this.handlerAddress) !== null && _a !== void 0 ? _a : null\n        }\n      };\n    });\n  }\n\n  getOpenStopLimitOrders(owner) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, stoplimit_1.queryStopLimitOrders)(owner, this.chainId);\n      return orders;\n    });\n  }\n\n  getStopLimitOrders(owner) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, stoplimit_1.queryStopLimitOrders)(owner, this.chainId);\n      return orders;\n    });\n  }\n\n  getExecutedStopLimitOrders(owner) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, stoplimit_1.queryStopLimitExecutedOrders)(owner, this.chainId);\n      return orders;\n    });\n  }\n\n  getCancelledStopLimitOrders(owner) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, stoplimit_1.queryStopLimitCancelledOrders)(owner, this.chainId);\n      return orders;\n    });\n  }\n\n  getPastStopLimitOrders(owner) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, stoplimit_1.queryPastOrders)(owner, this.chainId);\n      return orders;\n    });\n  }\n\n}\n\nexports.GelatoStopLimitOrders = GelatoStopLimitOrders;","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/node_modules/@gelatonetwork/limit-orders-lib/dist/stoplimit-orders/index.js"],"names":["Object","defineProperty","exports","value","GelatoStopLimitOrders","tslib_1","require","ethers_1","constants_1","core_1","stoplimit_1","GelatoBase","constructor","chainId","signerOrProvider","handler","_a","isValidChainIdAndHandler","Error","sotplossHandlers","NETWORK_STOP_LIMIT_HANDLERS","includes","moduleAddress","GELATO_STOP_LIMIT_ORDERS_MODULE_ADDRESS","handlerAddress","HANDLERS_ADDRESSES","toLowerCase","submitStopLimitOrder","inputToken","outputToken","inputAmount","maxReturn","checkAllowance","overrides","__awaiter","signer","owner","getAddress","txData","encodeStopLimitOrderSubmission","sendTransaction","assign","to","data","BigNumber","from","payload","encodeStopLimitOrderSubmissionWithSecret","maxReturnToBeParsed","randomSecret","utils","hexlify","randomBytes","replace","fullSecret","privateKey","secret","address","witness","Wallet","minReturn","getFeeAndSlippageAdjustedMinReturn","_encodeSubmitData","encodedData","abiEncoder","encode","order","id","_getKey","module","toString","adjustedMinReturn","inputData","getOpenStopLimitOrders","orders","queryStopLimitOrders","getStopLimitOrders","getExecutedStopLimitOrders","queryStopLimitExecutedOrders","getCancelledStopLimitOrders","queryStopLimitCancelledOrders","getPastStopLimitOrders","queryPastOrders"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GelatoStopLimitOrders = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ethers_1 = require(\"ethers\");\nconst constants_1 = require(\"../constants\");\nconst core_1 = require(\"./core\");\nconst stoplimit_1 = require(\"../utils/queries/stoplimit\");\nclass GelatoStopLimitOrders extends core_1.GelatoBase {\n    constructor(chainId, signerOrProvider, handler) {\n        var _a;\n        if (handler && !(0, core_1.isValidChainIdAndHandler)(chainId, handler)) {\n            throw new Error(\"Invalid chainId and handler\");\n        }\n        const sotplossHandlers = constants_1.NETWORK_STOP_LIMIT_HANDLERS[chainId];\n        if (!handler) {\n            throw new Error(\"No Handler defined\");\n        }\n        if (handler && !sotplossHandlers.includes(handler)) {\n            throw new Error(\"Handler not supported\");\n        }\n        const moduleAddress = constants_1.GELATO_STOP_LIMIT_ORDERS_MODULE_ADDRESS[chainId];\n        if (!moduleAddress)\n            throw new Error(\"Invalid chainId and handler\");\n        const handlerAddress = (_a = constants_1.HANDLERS_ADDRESSES[chainId][handler]) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n        super(chainId, moduleAddress, signerOrProvider, handler, handlerAddress);\n    }\n    submitStopLimitOrder(inputToken, outputToken, inputAmount, maxReturn, checkAllowance = true, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this.signer)\n                throw new Error(\"No signer\");\n            if (!maxReturn)\n                throw new Error(\"No StopLimit defined\");\n            const owner = yield this.signer.getAddress();\n            const txData = yield this.encodeStopLimitOrderSubmission(inputToken, outputToken, inputAmount, maxReturn, owner, checkAllowance);\n            return this.signer.sendTransaction(Object.assign(Object.assign({}, overrides), { to: txData.to, data: txData.data, value: ethers_1.BigNumber.from(txData.value) }));\n        });\n    }\n    encodeStopLimitOrderSubmission(inputToken, outputToken, inputAmount, maxReturn, owner, checkAllowance = true) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const { payload } = yield this.encodeStopLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, maxReturn, owner, checkAllowance);\n            return payload;\n        });\n    }\n    encodeStopLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, maxReturnToBeParsed, owner, checkAllowance = true) {\n        var _a;\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!maxReturnToBeParsed)\n                throw new Error(\"No StopLimit defined\");\n            if (!this.handlerAddress)\n                throw new Error(\"No handlerAddress\");\n            const randomSecret = ethers_1.utils.hexlify(ethers_1.utils.randomBytes(19)).replace(\"0x\", \"\");\n            // 0x67656c61746f6e6574776f726b = gelatonetwork in hex\n            const fullSecret = `0x67656c61746f6e6574776f726b${randomSecret}`;\n            const { privateKey: secret, address: witness } = new ethers_1.Wallet(fullSecret);\n            const { minReturn } = this.getFeeAndSlippageAdjustedMinReturn(maxReturnToBeParsed);\n            const payload = yield this._encodeSubmitData(inputToken, outputToken, owner, witness, inputAmount, maxReturnToBeParsed, minReturn, secret, checkAllowance);\n            const encodedData = this.abiEncoder.encode([\"address\", \"uint256\", \"address\", \"uint256\"], [outputToken, minReturn, this.handlerAddress, maxReturnToBeParsed]);\n            return {\n                payload,\n                secret,\n                witness,\n                order: {\n                    id: this._getKey({\n                        module: this.moduleAddress,\n                        inputToken,\n                        owner,\n                        witness,\n                        data: encodedData,\n                    }),\n                    module: this.moduleAddress.toLowerCase(),\n                    data: encodedData,\n                    inputToken: inputToken.toLowerCase(),\n                    outputToken: outputToken.toLowerCase(),\n                    owner: owner.toLowerCase(),\n                    witness: witness.toLowerCase(),\n                    inputAmount: inputAmount.toString(),\n                    minReturn: minReturn.toString(),\n                    maxReturn: maxReturnToBeParsed.toString(),\n                    adjustedMinReturn: maxReturnToBeParsed.toString(),\n                    inputData: payload.data.toString(),\n                    secret: secret.toLowerCase(),\n                    handler: (_a = this.handlerAddress) !== null && _a !== void 0 ? _a : null,\n                },\n            };\n        });\n    }\n    getOpenStopLimitOrders(owner) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, stoplimit_1.queryStopLimitOrders)(owner, this.chainId);\n            return orders;\n        });\n    }\n    getStopLimitOrders(owner) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, stoplimit_1.queryStopLimitOrders)(owner, this.chainId);\n            return orders;\n        });\n    }\n    getExecutedStopLimitOrders(owner) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, stoplimit_1.queryStopLimitExecutedOrders)(owner, this.chainId);\n            return orders;\n        });\n    }\n    getCancelledStopLimitOrders(owner) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, stoplimit_1.queryStopLimitCancelledOrders)(owner, this.chainId);\n            return orders;\n        });\n    }\n    getPastStopLimitOrders(owner) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, stoplimit_1.queryPastOrders)(owner, this.chainId);\n            return orders;\n        });\n    }\n}\nexports.GelatoStopLimitOrders = GelatoStopLimitOrders;\n"]},"metadata":{},"sourceType":"script"}