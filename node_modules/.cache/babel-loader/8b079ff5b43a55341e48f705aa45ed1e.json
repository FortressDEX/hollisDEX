{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, createStackParser, extractExceptionKeysForMessage, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, normalizeToSize, resolvedSyncPromise } from '@sentry/utils';\nimport { chromeStackParser, geckoStackParser, opera10StackParser, opera11StackParser, winjsStackParser } from './stack-parsers';\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\n\nexport function exceptionFromError(ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  var frames = parseStackFrames(ex);\n  var exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex)\n  };\n\n  if (frames.length) {\n    exception.stacktrace = {\n      frames: frames\n    };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n/**\n * @hidden\n */\n\nexport function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {\n  var event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n        value: \"Non-Error \" + (isUnhandledRejection ? 'promise rejection' : 'exception') + \" captured with keys: \" + extractExceptionKeysForMessage(exception)\n      }]\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception)\n    }\n  };\n\n  if (syntheticException) {\n    var frames_1 = parseStackFrames(syntheticException);\n\n    if (frames_1.length) {\n      event.stacktrace = {\n        frames: frames_1\n      };\n    }\n  }\n\n  return event;\n}\n/**\n * @hidden\n */\n\nexport function eventFromError(ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(ex)]\n    }\n  };\n}\n/** Parses stack frames from an error */\n\nexport function parseStackFrames(ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace || ex.stack || '';\n  var popSize = getPopSize(ex);\n\n  try {\n    return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);\n  } catch (e) {// no-empty\n  }\n\n  return [];\n} // Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\n\nvar reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex) {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\n\n\nfunction extractMessage(ex) {\n  var message = ex && ex.message;\n\n  if (!message) {\n    return 'No error message';\n  }\n\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n\n  return message;\n}\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\n\n\nexport function eventFromException(exception, hint, attachStacktrace) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n\n  event.level = Severity.Error;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return resolvedSyncPromise(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\n\nexport function eventFromMessage(message, level, hint, attachStacktrace) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, attachStacktrace);\n  event.level = level;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return resolvedSyncPromise(event);\n}\n/**\n * @hidden\n */\n\nexport function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {\n  var event;\n\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception;\n    return eventFromError(errorEvent.error);\n  } // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n\n\n  if (isDOMError(exception) || isDOMException(exception)) {\n    var domException = exception;\n\n    if ('stack' in exception) {\n      event = eventFromError(exception);\n    } else {\n      var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n      event = eventFromString(message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n\n    if ('code' in domException) {\n      event.tags = __assign(__assign({}, event.tags), {\n        'DOMException.code': \"\" + domException.code\n      });\n    }\n\n    return event;\n  }\n\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(exception);\n  }\n\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  } // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n\n\n  event = eventFromString(exception, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\n\nexport function eventFromString(input, syntheticException, attachStacktrace) {\n  var event = {\n    message: input\n  };\n\n  if (attachStacktrace && syntheticException) {\n    var frames_2 = parseStackFrames(syntheticException);\n\n    if (frames_2.length) {\n      event.stacktrace = {\n        frames: frames_2\n      };\n    }\n  }\n\n  return event;\n}","map":{"version":3,"sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventHint, Exception, Severity, StackFrame } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  createStackParser,\n  extractExceptionKeysForMessage,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isPlainObject,\n  normalizeToSize,\n  resolvedSyncPromise,\n} from '@sentry/utils';\n\nimport {\n  chromeStackParser,\n  geckoStackParser,\n  opera10StackParser,\n  opera11StackParser,\n  winjsStackParser,\n} from './stack-parsers';\n\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromError(ex: Error): Exception {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  const frames = parseStackFrames(ex);\n\n  const exception: Exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nexport function eventFromPlainObject(\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  isUnhandledRejection?: boolean,\n): Event {\n  const event: Event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            isUnhandledRejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception),\n    },\n  };\n\n  if (syntheticException) {\n    const frames = parseStackFrames(syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromError(ex: Error): Event {\n  return {\n    exception: {\n      values: [exceptionFromError(ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nexport function parseStackFrames(ex: Error & { framesToPop?: number; stacktrace?: string }): StackFrame[] {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace || ex.stack || '';\n\n  const popSize = getPopSize(ex);\n\n  try {\n    return createStackParser(\n      opera10StackParser,\n      opera11StackParser,\n      chromeStackParser,\n      winjsStackParser,\n      geckoStackParser,\n    )(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nconst reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex: Error & { framesToPop?: number }): number {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex: Error & { message: { error?: Error } }): string {\n  const message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nexport function eventFromException(\n  exception: unknown,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  exception: unknown,\n  syntheticException?: Error,\n  attachStacktrace?: boolean,\n  isUnhandledRejection?: boolean,\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    return eventFromError(errorEvent.error as Error);\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n    const domException = exception as DOMException;\n\n    if ('stack' in (exception as Error)) {\n      event = eventFromError(exception as Error);\n    } else {\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception as Error)) {\n    // we have a real Error object, do nothing\n    return eventFromError(exception as Error);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception as string, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromString(input: string, syntheticException?: Error, attachStacktrace?: boolean): Event {\n  const event: Event = {\n    message: input,\n  };\n\n  if (attachStacktrace && syntheticException) {\n    const frames = parseStackFrames(syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}