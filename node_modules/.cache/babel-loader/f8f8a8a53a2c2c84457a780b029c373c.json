{"ast":null,"code":"import { useMemo, useEffect, useState } from 'react';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { CAVAX, Token, currencyEquals } from '@pangolindex/sdk';\nimport ERC20_INTERFACE, { ERC20_BYTES32_INTERFACE } from '../constants/abis/erc20';\nimport { useSelectedTokenList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useChainId } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { CHAINS, ChainsId } from 'src/constants/chains';\nexport function useAllTokens() {\n  const chainId = useChainId();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useSelectedTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    }, // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    { ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n} // Check if currency is included in custom list from user storage\n\nexport function useIsUserAddedToken(currency) {\n  const userAddedTokens = useUserAddedTokens();\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n} // parse a name or symbol from a token response\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : bytes32 && BYTES32_REGEX.test(bytes32) ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  const chainId = useChainId();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\nexport function useTokens() {\n  let tokensAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const chainId = useChainId();\n  const tokens = useAllTokens();\n  const tokensName = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'name', undefined, NEVER_RELOAD);\n  const tokensNameBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'name', undefined, NEVER_RELOAD);\n  const symbols = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'symbol', undefined, NEVER_RELOAD);\n  const symbolsBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (!tokensAddress || (tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.length) === 0) return [];\n    if (!chainId) return [];\n    return tokensAddress.reduce((acc, tokenAddress, index) => {\n      const tokenName = tokensName === null || tokensName === void 0 ? void 0 : tokensName[index];\n      const tokenNameBytes32 = tokensNameBytes32 === null || tokensNameBytes32 === void 0 ? void 0 : tokensNameBytes32[index];\n      const symbol = symbols === null || symbols === void 0 ? void 0 : symbols[index];\n      const symbolBytes32 = symbolsBytes32 === null || symbolsBytes32 === void 0 ? void 0 : symbolsBytes32[index];\n      const decimal = decimals === null || decimals === void 0 ? void 0 : decimals[index];\n      const address = isAddress(tokenAddress);\n\n      if (!!address && tokens[address]) {\n        // if we have user tokens already\n        acc.push(tokens[address]);\n      } else if ((tokenName === null || tokenName === void 0 ? void 0 : tokenName.loading) === false && (tokenNameBytes32 === null || tokenNameBytes32 === void 0 ? void 0 : tokenNameBytes32.loading) === false && (symbol === null || symbol === void 0 ? void 0 : symbol.loading) === false && (symbolBytes32 === null || symbolBytes32 === void 0 ? void 0 : symbolBytes32.loading) === false && (decimal === null || decimal === void 0 ? void 0 : decimal.loading) === false && address) {\n        var _decimal$result, _symbol$result2, _symbolBytes32$result2, _tokenName$result2, _tokenNameBytes32$res2;\n\n        const token = new Token(chainId, tokenAddress, decimal === null || decimal === void 0 ? void 0 : (_decimal$result = decimal.result) === null || _decimal$result === void 0 ? void 0 : _decimal$result[0], parseStringOrBytes32((_symbol$result2 = symbol.result) === null || _symbol$result2 === void 0 ? void 0 : _symbol$result2[0], (_symbolBytes32$result2 = symbolBytes32.result) === null || _symbolBytes32$result2 === void 0 ? void 0 : _symbolBytes32$result2[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result2 = tokenName.result) === null || _tokenName$result2 === void 0 ? void 0 : _tokenName$result2[0], (_tokenNameBytes32$res2 = tokenNameBytes32.result) === null || _tokenNameBytes32$res2 === void 0 ? void 0 : _tokenNameBytes32$res2[0], 'Unknown Token'));\n        acc.push(token);\n      }\n\n      return acc;\n    }, []);\n  }, [chainId, decimals, symbols, symbolsBytes32, tokensName, tokensNameBytes32, tokens, tokensAddress]);\n}\nexport function useCurrency(currencyId) {\n  const chainId = useChainId();\n  const isAVAX = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'AVAX';\n  const token = useToken(isAVAX ? undefined : currencyId);\n  return isAVAX ? chainId && CAVAX[chainId] : token;\n}\nexport function useCoinGeckoTokenData(coin) {\n  const [result, setResult] = useState({});\n  useEffect(() => {\n    const getCoinData = async () => {\n      var _data$links, _data$description;\n\n      const chain = coin.chainId === 43113 ? CHAINS[ChainsId.AVAX] : CHAINS[coin.chainId];\n      const response = await fetch(`https://api.coingecko.com/api/v3/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}`);\n      const data = await response.json();\n      setResult({\n        coinId: data === null || data === void 0 ? void 0 : data.id,\n        homePage: data === null || data === void 0 ? void 0 : (_data$links = data.links) === null || _data$links === void 0 ? void 0 : _data$links.homepage[0],\n        description: data === null || data === void 0 ? void 0 : (_data$description = data.description) === null || _data$description === void 0 ? void 0 : _data$description.en\n      });\n    };\n\n    getCoinData();\n  }, [coin]);\n  return result;\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/hooks/Tokens.ts"],"names":["useMemo","useEffect","useState","parseBytes32String","CAVAX","Token","currencyEquals","ERC20_INTERFACE","ERC20_BYTES32_INTERFACE","useSelectedTokenList","NEVER_RELOAD","useMultipleContractSingleData","useSingleCallResult","useUserAddedTokens","isAddress","useChainId","useBytes32TokenContract","useTokenContract","CHAINS","ChainsId","useAllTokens","chainId","userAddedTokens","allTokens","reduce","tokenMap","token","address","useIsUserAddedToken","currency","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useTokens","tokensAddress","tokensName","tokensNameBytes32","symbols","symbolsBytes32","acc","index","decimal","push","useCurrency","currencyId","isAVAX","toUpperCase","useCoinGeckoTokenData","coin","setResult","getCoinData","chain","AVAX","response","fetch","coingecko_id","toLowerCase","data","json","coinId","id","homePage","links","homepage","description","en"],"mappings":"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","sourcesContent":["import { useMemo, useEffect, useState } from 'react'\nimport { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, CAVAX, Token, currencyEquals } from '@pangolindex/sdk'\nimport ERC20_INTERFACE, { ERC20_BYTES32_INTERFACE } from '../constants/abis/erc20'\nimport { useSelectedTokenList } from '../state/lists/hooks'\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult } from '../state/multicall/hooks'\nimport { useUserAddedTokens } from '../state/user/hooks'\nimport { isAddress } from '../utils'\nimport { useChainId } from './index'\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\n\nimport { CHAINS, ChainsId } from 'src/constants/chains'\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const chainId = useChainId()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useSelectedTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency): boolean {\n  const userAddedTokens = useUserAddedTokens()\n  return !!userAddedTokens.find(token => currencyEquals(currency, token))\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : bytes32 && BYTES32_REGEX.test(bytes32)\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const chainId = useChainId()\n  const tokens = useAllTokens()\n\n  const address = isAddress(tokenAddress)\n\n  const tokenContract = useTokenContract(address ? address : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false)\n  const token: Token | undefined = address ? tokens[address] : undefined\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (token) return token\n    if (!chainId || !address) return undefined\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      )\n    }\n    return undefined\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result\n  ])\n}\n\nexport function useTokens(tokensAddress: string[] = []): Array<Token | undefined | null> | undefined | null {\n  const chainId = useChainId()\n  const tokens = useAllTokens()\n\n  const tokensName = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'name', undefined, NEVER_RELOAD)\n  const tokensNameBytes32 = useMultipleContractSingleData(\n    tokensAddress,\n    ERC20_BYTES32_INTERFACE,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbols = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'symbol', undefined, NEVER_RELOAD)\n  const symbolsBytes32 = useMultipleContractSingleData(\n    tokensAddress,\n    ERC20_BYTES32_INTERFACE,\n    'symbol',\n    undefined,\n    NEVER_RELOAD\n  )\n  const decimals = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (!tokensAddress || tokensAddress?.length === 0) return []\n    if (!chainId) return []\n\n    return tokensAddress.reduce<Token[]>((acc, tokenAddress, index) => {\n      const tokenName = tokensName?.[index]\n      const tokenNameBytes32 = tokensNameBytes32?.[index]\n      const symbol = symbols?.[index]\n      const symbolBytes32 = symbolsBytes32?.[index]\n      const decimal = decimals?.[index]\n      const address = isAddress(tokenAddress)\n\n      if (!!address && tokens[address]) {\n        // if we have user tokens already\n        acc.push(tokens[address])\n      } else if (\n        tokenName?.loading === false &&\n        tokenNameBytes32?.loading === false &&\n        symbol?.loading === false &&\n        symbolBytes32?.loading === false &&\n        decimal?.loading === false &&\n        address\n      ) {\n        const token = new Token(\n          chainId,\n          tokenAddress,\n          decimal?.result?.[0],\n          parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n          parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n        )\n\n        acc.push(token)\n      }\n\n      return acc\n    }, [])\n  }, [chainId, decimals, symbols, symbolsBytes32, tokensName, tokensNameBytes32, tokens, tokensAddress])\n}\n\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\n  const chainId = useChainId()\n  const isAVAX = currencyId?.toUpperCase() === 'AVAX'\n  const token = useToken(isAVAX ? undefined : currencyId)\n  return isAVAX ? chainId && CAVAX[chainId] : token\n}\n\nexport function useCoinGeckoTokenData(coin: Token) {\n  const [result, setResult] = useState({} as { coinId: string; homePage: string; description: string })\n\n  useEffect(() => {\n    const getCoinData = async () => {\n      const chain = coin.chainId === 43113 ? CHAINS[ChainsId.AVAX] : CHAINS[coin.chainId]\n\n      const response = await fetch(\n        `https://api.coingecko.com/api/v3/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}`\n      )\n      const data = await response.json()\n\n      setResult({\n        coinId: data?.id,\n        homePage: data?.links?.homepage[0],\n        description: data?.description?.en\n      })\n    }\n    getCoinData()\n  }, [coin])\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}