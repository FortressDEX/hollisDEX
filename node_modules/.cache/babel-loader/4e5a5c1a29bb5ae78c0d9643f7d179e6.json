{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Safe = void 0;\n\nconst ethers_1 = require(\"ethers\");\n\nconst signatures_1 = require(\"./signatures\");\n\nconst methods_1 = require(\"../communication/methods\");\n\nconst constants_1 = require(\"../eth/constants\");\n\nclass Safe {\n  constructor(communicator) {\n    this.communicator = communicator;\n  }\n\n  async getChainInfo() {\n    const response = await this.communicator.send(methods_1.Methods.getChainInfo, undefined);\n    return response.data;\n  }\n\n  async getInfo() {\n    const response = await this.communicator.send(methods_1.Methods.getSafeInfo, undefined);\n    return response.data;\n  } // There is a possibility that this method will change because we may add pagination to the endpoint\n\n\n  async experimental_getBalances() {\n    let {\n      currency = 'usd'\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const response = await this.communicator.send(methods_1.Methods.getSafeBalances, {\n      currency\n    });\n    return response.data;\n  }\n\n  async check1271Signature(messageHash) {\n    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0x';\n    const safeInfo = await this.getInfo();\n    const encodedIsValidSignatureCall = signatures_1.EIP_1271_INTERFACE.encodeFunctionData('isValidSignature', [messageHash, signature]);\n    const payload = {\n      call: constants_1.RPC_CALLS.eth_call,\n      params: [{\n        to: safeInfo.safeAddress,\n        data: encodedIsValidSignatureCall\n      }, 'latest']\n    };\n\n    try {\n      const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);\n      return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  async check1271SignatureBytes(messageHash) {\n    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0x';\n    const safeInfo = await this.getInfo();\n    const msgBytes = ethers_1.ethers.utils.arrayify(messageHash);\n    const encodedIsValidSignatureCall = signatures_1.EIP_1271_BYTES_INTERFACE.encodeFunctionData('isValidSignature', [msgBytes, signature]);\n    const payload = {\n      call: constants_1.RPC_CALLS.eth_call,\n      params: [{\n        to: safeInfo.safeAddress,\n        data: encodedIsValidSignatureCall\n      }, 'latest']\n    };\n\n    try {\n      const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);\n      return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE_BYTES;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  calculateMessageHash(message) {\n    return ethers_1.ethers.utils.hashMessage(message);\n  }\n\n  async isMessageSigned(message) {\n    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0x';\n    const messageHash = this.calculateMessageHash(message);\n    const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);\n    return messageHashSigned;\n  }\n\n  async isMessageHashSigned(messageHash) {\n    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0x';\n    const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];\n\n    for (const check of checks) {\n      const isValid = await check(messageHash, signature);\n\n      if (isValid) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.Safe = Safe;","map":{"version":3,"sources":["../../../src/safe/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Safe = void 0;\nconst ethers_1 = require(\"ethers\");\nconst signatures_1 = require(\"./signatures\");\nconst methods_1 = require(\"../communication/methods\");\nconst constants_1 = require(\"../eth/constants\");\nclass Safe {\n    constructor(communicator) {\n        this.communicator = communicator;\n    }\n    async getChainInfo() {\n        const response = await this.communicator.send(methods_1.Methods.getChainInfo, undefined);\n        return response.data;\n    }\n    async getInfo() {\n        const response = await this.communicator.send(methods_1.Methods.getSafeInfo, undefined);\n        return response.data;\n    }\n    // There is a possibility that this method will change because we may add pagination to the endpoint\n    async experimental_getBalances({ currency = 'usd' } = {}) {\n        const response = await this.communicator.send(methods_1.Methods.getSafeBalances, {\n            currency,\n        });\n        return response.data;\n    }\n    async check1271Signature(messageHash, signature = '0x') {\n        const safeInfo = await this.getInfo();\n        const encodedIsValidSignatureCall = signatures_1.EIP_1271_INTERFACE.encodeFunctionData('isValidSignature', [\n            messageHash,\n            signature,\n        ]);\n        const payload = {\n            call: constants_1.RPC_CALLS.eth_call,\n            params: [\n                {\n                    to: safeInfo.safeAddress,\n                    data: encodedIsValidSignatureCall,\n                },\n                'latest',\n            ],\n        };\n        try {\n            const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);\n            return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    async check1271SignatureBytes(messageHash, signature = '0x') {\n        const safeInfo = await this.getInfo();\n        const msgBytes = ethers_1.ethers.utils.arrayify(messageHash);\n        const encodedIsValidSignatureCall = signatures_1.EIP_1271_BYTES_INTERFACE.encodeFunctionData('isValidSignature', [\n            msgBytes,\n            signature,\n        ]);\n        const payload = {\n            call: constants_1.RPC_CALLS.eth_call,\n            params: [\n                {\n                    to: safeInfo.safeAddress,\n                    data: encodedIsValidSignatureCall,\n                },\n                'latest',\n            ],\n        };\n        try {\n            const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);\n            return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE_BYTES;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    calculateMessageHash(message) {\n        return ethers_1.ethers.utils.hashMessage(message);\n    }\n    async isMessageSigned(message, signature = '0x') {\n        const messageHash = this.calculateMessageHash(message);\n        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);\n        return messageHashSigned;\n    }\n    async isMessageHashSigned(messageHash, signature = '0x') {\n        const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];\n        for (const check of checks) {\n            const isValid = await check(messageHash, signature);\n            if (isValid) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.Safe = Safe;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}