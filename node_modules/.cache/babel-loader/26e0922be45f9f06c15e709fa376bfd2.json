{"ast":null,"code":"import { ChainId, JSBI, Token, TokenAmount, WAVAX, Pair, Percent } from '@pangolindex/sdk';\nimport { useMemo, useEffect, useState, useCallback } from 'react';\nimport { MINICHEF_ADDRESS, BIG_INT_ZERO, BIG_INT_TWO, BIG_INT_ONE, BIG_INT_SECONDS_IN_WEEK, PANGOLIN_API_BASE_URL } from '../../constants';\nimport { DAIe, PNG, USDC, USDCe, USDTe, axlUST } from '../../constants/tokens';\nimport { STAKING_REWARDS_INTERFACE } from '../../constants/abis/staking-rewards';\nimport { PairState, usePair, usePairs } from '../../data/Reserves';\nimport { useActiveWeb3React } from '../../hooks';\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useTranslation } from 'react-i18next';\nimport ERC20_INTERFACE from '../../constants/abis/erc20';\nimport { REWARDER_VIA_MULTIPLIER_INTERFACE } from '../../constants/abis/rewarderViaMultiplier';\nimport useUSDCPrice from '../../utils/useUSDCPrice';\nimport { getRouterContract } from '../../utils';\nimport { useTokenBalance } from '../../state/wallet/hooks';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { usePngContract, useStakingContract } from '../../hooks/useContract';\nimport { SINGLE_SIDE_STAKING_REWARDS_INFO } from './singleSideConfig';\nimport { DOUBLE_SIDE_STAKING_REWARDS_INFO } from './doubleSideConfig';\nimport { ZERO_ADDRESS } from '../../constants';\nimport { CHAINS } from '../../constants/chains';\nimport { unwrappedToken } from 'src/utils/wrappedCurrency';\nimport { useTokens } from '../../hooks/Tokens';\nimport { useRewardViaMultiplierContract } from '../../hooks/useContract';\nimport { wrappedCurrencyAmount } from 'src/utils/wrappedCurrency';\nimport { useTransactionAdder } from 'src/state/transactions/hooks';\nimport useTransactionDeadline from 'src/hooks/useTransactionDeadline';\nimport { maxAmountSpend } from 'src/utils/maxAmountSpend';\nimport { useApproveCallback, ApprovalState } from 'src/hooks/useApproveCallback';\nimport { splitSignature } from 'ethers/lib/utils';\nimport { useChainId } from 'src/hooks';\n\nconst calculateTotalStakedAmountInAvaxFromPng = function (amountStaked, amountAvailable, avaxPngPairReserveOfPng, avaxPngPairReserveOfWavax, reserveInPng, chainId) {\n  if (JSBI.EQ(amountAvailable, JSBI.BigInt(0))) {\n    return new TokenAmount(WAVAX[chainId], JSBI.BigInt(0));\n  }\n\n  const oneToken = JSBI.BigInt(1000000000000000000);\n  const avaxPngRatio = JSBI.divide(JSBI.multiply(oneToken, avaxPngPairReserveOfWavax), avaxPngPairReserveOfPng);\n  const valueOfPngInAvax = JSBI.divide(JSBI.multiply(reserveInPng, avaxPngRatio), oneToken);\n  return new TokenAmount(WAVAX[chainId], JSBI.divide(JSBI.multiply(JSBI.multiply(amountStaked, valueOfPngInAvax), JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the wavax they entitle owner to\n  ), amountAvailable));\n};\n\nconst calculateRewardRateInPng = function (rewardRate, valueOfPng) {\n  if (!valueOfPng || JSBI.EQ(valueOfPng, 0)) return JSBI.BigInt(0); // TODO: Handle situation where stakingToken and rewardToken have different decimals\n\n  const oneToken = JSBI.BigInt(1000000000000000000);\n  return JSBI.divide(JSBI.multiply(rewardRate, oneToken), // Multiply first for precision\n  valueOfPng);\n};\n\nconst calculateApr = function (rewardRatePerSecond, totalSupply) {\n  if (JSBI.EQ(totalSupply, 0)) {\n    return JSBI.BigInt(0);\n  }\n\n  const rewardsPerYear = JSBI.multiply(rewardRatePerSecond, JSBI.BigInt(31536000) // Seconds in year\n  );\n  return JSBI.divide(JSBI.multiply(rewardsPerYear, JSBI.BigInt(100)), totalSupply);\n};\n\nconst calculateTotalStakedAmountInAvax = function (amountStaked, amountAvailable, reserveInWavax, chainId) {\n  if (JSBI.GT(amountAvailable, 0)) {\n    // take the total amount of LP tokens staked, multiply by AVAX value of all LP tokens, divide by all LP tokens\n    return new TokenAmount(WAVAX[chainId], JSBI.divide(JSBI.multiply(JSBI.multiply(amountStaked, reserveInWavax), JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the wavax they entitle owner to\n    ), amountAvailable));\n  } else {\n    return new TokenAmount(WAVAX[chainId], JSBI.BigInt(0));\n  }\n}; // gets the staking info from the network for the active chain id\n\n\nexport function useStakingInfo(version, pairToFilterBy) {\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const info = useMemo(() => {\n    var _DOUBLE_SIDE_STAKING_, _DOUBLE_SIDE_STAKING_2, _DOUBLE_SIDE_STAKING_3;\n\n    return chainId ? (_DOUBLE_SIDE_STAKING_ = (_DOUBLE_SIDE_STAKING_2 = DOUBLE_SIDE_STAKING_REWARDS_INFO[chainId]) === null || _DOUBLE_SIDE_STAKING_2 === void 0 ? void 0 : (_DOUBLE_SIDE_STAKING_3 = _DOUBLE_SIDE_STAKING_2[version]) === null || _DOUBLE_SIDE_STAKING_3 === void 0 ? void 0 : _DOUBLE_SIDE_STAKING_3.filter(stakingRewardInfo => pairToFilterBy === undefined ? true : pairToFilterBy === null ? false : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]))) !== null && _DOUBLE_SIDE_STAKING_ !== void 0 ? _DOUBLE_SIDE_STAKING_ : [] : [];\n  }, [chainId, pairToFilterBy, version]);\n  const png = PNG[chainId];\n  const rewardsAddresses = useMemo(() => info.map(_ref => {\n    let {\n      stakingRewardAddress\n    } = _ref;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const tokens = useMemo(() => info.map(_ref2 => {\n    let {\n      tokens\n    } = _ref2;\n    return tokens;\n  }), [info]);\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const stakingTotalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n  const pairs = usePairs(tokens);\n  const pairAddresses = useMemo(() => {\n    const pairsHaveLoaded = pairs === null || pairs === void 0 ? void 0 : pairs.every(_ref3 => {\n      let [state] = _ref3;\n      return state === PairState.EXISTS;\n    });\n    if (!pairsHaveLoaded) return [];else return pairs.map(_ref4 => {\n      let [, pair] = _ref4;\n      return pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address;\n    });\n  }, [pairs]);\n  const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');\n  const [avaxPngPairState, avaxPngPair] = usePair(WAVAX[chainId], png); // tokens per second, constants\n\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish', undefined, NEVER_RELOAD);\n  const usdPriceTmp = useUSDCPrice(WAVAX[chainId]);\n  const usdPrice = CHAINS[chainId].is_mainnet ? usdPriceTmp : undefined;\n  return useMemo(() => {\n    if (!chainId || !png) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const stakingTotalSupplyState = stakingTotalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const periodFinishState = periodFinishes[index];\n      const [pairState, pair] = pairs[index];\n      const pairTotalSupplyState = pairTotalSupplies[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) && !(earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.loading) && // always need these\n      (stakingTotalSupplyState === null || stakingTotalSupplyState === void 0 ? void 0 : stakingTotalSupplyState.loading) === false && (rewardRateState === null || rewardRateState === void 0 ? void 0 : rewardRateState.loading) === false && (periodFinishState === null || periodFinishState === void 0 ? void 0 : periodFinishState.loading) === false && (pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.loading) === false && pair && avaxPngPair && pairState !== PairState.LOADING && avaxPngPairState !== PairState.LOADING) {\n        var _periodFinishState$re, _periodFinishState$re2, _periodFinishState$re3, _stakingTotalSupplySt, _pairTotalSupplyState, _balanceState$result$, _balanceState$result, _rewardRateState$resu, _earnedAmountState$re, _earnedAmountState$re2;\n\n        if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) || (earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.error) || stakingTotalSupplyState.error || rewardRateState.error || periodFinishState.error || pairTotalSupplyState.error || pairState === PairState.INVALID || pairState === PairState.NOT_EXISTS || avaxPngPairState === PairState.INVALID || avaxPngPairState === PairState.NOT_EXISTS) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        } // get the LP token\n\n\n        const tokens = info[index].tokens;\n        const wavax = tokens[0].equals(WAVAX[tokens[0].chainId]) ? tokens[0] : tokens[1];\n        const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId); // check for account, if no account set to 0\n\n        const periodFinishMs = (_periodFinishState$re = periodFinishState.result) === null || _periodFinishState$re === void 0 ? void 0 : (_periodFinishState$re2 = _periodFinishState$re[0]) === null || _periodFinishState$re2 === void 0 ? void 0 : (_periodFinishState$re3 = _periodFinishState$re2.mul(1000)) === null || _periodFinishState$re3 === void 0 ? void 0 : _periodFinishState$re3.toNumber(); // periodFinish will be 0 immediately after a reward contract is initialized\n\n        const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now();\n        const totalSupplyStaked = JSBI.BigInt((_stakingTotalSupplySt = stakingTotalSupplyState.result) === null || _stakingTotalSupplySt === void 0 ? void 0 : _stakingTotalSupplySt[0]);\n        const totalSupplyAvailable = JSBI.BigInt((_pairTotalSupplyState = pairTotalSupplyState.result) === null || _pairTotalSupplyState === void 0 ? void 0 : _pairTotalSupplyState[0]);\n        const stakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt((_balanceState$result$ = balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result = balanceState.result) === null || _balanceState$result === void 0 ? void 0 : _balanceState$result[0]) !== null && _balanceState$result$ !== void 0 ? _balanceState$result$ : 0));\n        const totalStakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt(totalSupplyStaked));\n        const totalRewardRatePerSecond = new TokenAmount(png, JSBI.BigInt(isPeriodFinished ? 0 : (_rewardRateState$resu = rewardRateState.result) === null || _rewardRateState$resu === void 0 ? void 0 : _rewardRateState$resu[0]));\n        const totalRewardRatePerWeek = new TokenAmount(png, JSBI.multiply(totalRewardRatePerSecond.raw, BIG_INT_SECONDS_IN_WEEK));\n        const isAvaxPool = tokens[0].equals(WAVAX[tokens[0].chainId]);\n        const totalStakedInWavax = isAvaxPool ? calculateTotalStakedAmountInAvax(totalSupplyStaked, totalSupplyAvailable, pair.reserveOf(wavax).raw, chainId) : calculateTotalStakedAmountInAvaxFromPng(totalSupplyStaked, totalSupplyAvailable, avaxPngPair.reserveOf(png).raw, avaxPngPair.reserveOf(WAVAX[tokens[1].chainId]).raw, pair.reserveOf(png).raw, chainId);\n        const totalStakedInUsd = totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(totalStakedInWavax, chainId));\n\n        const getHypotheticalWeeklyRewardRate = (stakedAmount, totalStakedAmount, totalRewardRatePerSecond) => {\n          return new TokenAmount(png, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), totalStakedAmount.raw) : JSBI.BigInt(0));\n        };\n\n        const individualRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, totalRewardRatePerSecond);\n        const multiplier = info[index].multiplier;\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished: isPeriodFinished,\n          earnedAmount: new TokenAmount(png, JSBI.BigInt((_earnedAmountState$re = earnedAmountState === null || earnedAmountState === void 0 ? void 0 : (_earnedAmountState$re2 = earnedAmountState.result) === null || _earnedAmountState$re2 === void 0 ? void 0 : _earnedAmountState$re2[0]) !== null && _earnedAmountState$re !== void 0 ? _earnedAmountState$re : 0)),\n          rewardRatePerWeek: individualRewardRatePerWeek,\n          totalRewardRatePerSecond: totalRewardRatePerSecond,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          totalStakedInWavax: totalStakedInWavax,\n          totalStakedInUsd: totalStakedInUsd,\n          multiplier: JSBI.BigInt(multiplier !== null && multiplier !== void 0 ? multiplier : 0),\n          getHypotheticalWeeklyRewardRate\n        });\n      }\n\n      return memo;\n    }, []); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [chainId, png, rewardsAddresses, balances, earnedAmounts, stakingTotalSupplies, rewardRates, periodFinishes, pairs, pairTotalSupplies, avaxPngPair, avaxPngPairState, info]);\n}\nexport function useSingleSideStakingInfo(version, rewardTokenToFilterBy) {\n  const {\n    chainId,\n    library,\n    account\n  } = useActiveWeb3React();\n  const info = useMemo(() => {\n    var _SINGLE_SIDE_STAKING_, _SINGLE_SIDE_STAKING_2, _SINGLE_SIDE_STAKING_3;\n\n    return chainId ? (_SINGLE_SIDE_STAKING_ = (_SINGLE_SIDE_STAKING_2 = SINGLE_SIDE_STAKING_REWARDS_INFO[chainId]) === null || _SINGLE_SIDE_STAKING_2 === void 0 ? void 0 : (_SINGLE_SIDE_STAKING_3 = _SINGLE_SIDE_STAKING_2[version]) === null || _SINGLE_SIDE_STAKING_3 === void 0 ? void 0 : _SINGLE_SIDE_STAKING_3.filter(stakingRewardInfo => rewardTokenToFilterBy === undefined ? true : rewardTokenToFilterBy === null ? false : rewardTokenToFilterBy.equals(stakingRewardInfo.rewardToken))) !== null && _SINGLE_SIDE_STAKING_ !== void 0 ? _SINGLE_SIDE_STAKING_ : [] : [];\n  }, [chainId, rewardTokenToFilterBy, version]);\n  const png = PNG[ChainId.AVALANCHE];\n  const rewardsAddresses = useMemo(() => info.map(_ref5 => {\n    let {\n      stakingRewardAddress\n    } = _ref5;\n    return stakingRewardAddress;\n  }), [info]);\n  const routes = useMemo(() => info.map(_ref6 => {\n    let {\n      conversionRouteHops,\n      rewardToken\n    } = _ref6;\n    return [png.address, ...conversionRouteHops.map(token => token.address), rewardToken.address]; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [info, png]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]);\n  const getAmountsOutArgs = useMemo(() => {\n    const amountIn = '1' + '0'.repeat(18); // 1 PNG\n\n    return routes.map(route => [amountIn, route]);\n  }, [routes]);\n  const routerContract = useMemo(() => {\n    if (!chainId || !library) return;\n    return getRouterContract(chainId, library);\n  }, [chainId, library]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const stakingTotalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply'); // tokens per second, constants\n\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish', undefined, NEVER_RELOAD);\n  const amountsOuts = useSingleContractMultipleData(routerContract, 'getAmountsOut', getAmountsOutArgs, NEVER_RELOAD);\n  return useMemo(() => {\n    if (!chainId || !png) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const stakingTotalSupplyState = stakingTotalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const periodFinishState = periodFinishes[index];\n      const amountsOutsState = amountsOuts[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) && !(earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.loading) && // always need these\n      (stakingTotalSupplyState === null || stakingTotalSupplyState === void 0 ? void 0 : stakingTotalSupplyState.loading) === false && (rewardRateState === null || rewardRateState === void 0 ? void 0 : rewardRateState.loading) === false && (periodFinishState === null || periodFinishState === void 0 ? void 0 : periodFinishState.loading) === false && (amountsOutsState === null || amountsOutsState === void 0 ? void 0 : amountsOutsState.loading) === false) {\n        var _amountsOutsState$res, _amountsOutsState$res2, _amountsOutsState$res3, _amountsOutsState$res4, _periodFinishState$re4, _periodFinishState$re5, _periodFinishState$re6, _stakingTotalSupplySt2, _balanceState$result$2, _balanceState$result2, _rewardRateState$resu2, _earnedAmountState$re3, _earnedAmountState$re4;\n\n        if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) || (earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.error) || stakingTotalSupplyState.error || rewardRateState.error || periodFinishState.error || amountsOutsState.error) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        }\n\n        const rewardToken = info[index].rewardToken;\n        const valueOfPng = JSBI.BigInt((_amountsOutsState$res = (_amountsOutsState$res2 = amountsOutsState.result) === null || _amountsOutsState$res2 === void 0 ? void 0 : (_amountsOutsState$res3 = _amountsOutsState$res2[0]) === null || _amountsOutsState$res3 === void 0 ? void 0 : (_amountsOutsState$res4 = _amountsOutsState$res3.slice(-1)) === null || _amountsOutsState$res4 === void 0 ? void 0 : _amountsOutsState$res4[0]) !== null && _amountsOutsState$res !== void 0 ? _amountsOutsState$res : 0);\n        const periodFinishMs = (_periodFinishState$re4 = periodFinishState.result) === null || _periodFinishState$re4 === void 0 ? void 0 : (_periodFinishState$re5 = _periodFinishState$re4[0]) === null || _periodFinishState$re5 === void 0 ? void 0 : (_periodFinishState$re6 = _periodFinishState$re5.mul(1000)) === null || _periodFinishState$re6 === void 0 ? void 0 : _periodFinishState$re6.toNumber(); // periodFinish will be 0 immediately after a reward contract is initialized\n\n        const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now();\n        const totalSupplyStaked = JSBI.BigInt((_stakingTotalSupplySt2 = stakingTotalSupplyState.result) === null || _stakingTotalSupplySt2 === void 0 ? void 0 : _stakingTotalSupplySt2[0]);\n        const stakedAmount = new TokenAmount(png, JSBI.BigInt((_balanceState$result$2 = balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result2 = balanceState.result) === null || _balanceState$result2 === void 0 ? void 0 : _balanceState$result2[0]) !== null && _balanceState$result$2 !== void 0 ? _balanceState$result$2 : 0));\n        const totalStakedAmount = new TokenAmount(png, JSBI.BigInt(totalSupplyStaked));\n        const totalRewardRatePerSecond = new TokenAmount(rewardToken, JSBI.BigInt(isPeriodFinished ? 0 : (_rewardRateState$resu2 = rewardRateState.result) === null || _rewardRateState$resu2 === void 0 ? void 0 : _rewardRateState$resu2[0]));\n        const totalRewardRatePerWeek = new TokenAmount(png, JSBI.multiply(totalRewardRatePerSecond.raw, BIG_INT_SECONDS_IN_WEEK));\n        const earnedAmount = new TokenAmount(png, JSBI.BigInt((_earnedAmountState$re3 = earnedAmountState === null || earnedAmountState === void 0 ? void 0 : (_earnedAmountState$re4 = earnedAmountState.result) === null || _earnedAmountState$re4 === void 0 ? void 0 : _earnedAmountState$re4[0]) !== null && _earnedAmountState$re3 !== void 0 ? _earnedAmountState$re3 : 0));\n        const rewardRateInPng = calculateRewardRateInPng(totalRewardRatePerSecond.raw, valueOfPng);\n        const apr = isPeriodFinished ? JSBI.BigInt(0) : calculateApr(rewardRateInPng, totalSupplyStaked);\n\n        const getHypotheticalWeeklyRewardRate = (stakedAmount, totalStakedAmount, totalRewardRatePerSecond) => {\n          return new TokenAmount(rewardToken, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), totalStakedAmount.raw) : JSBI.BigInt(0));\n        };\n\n        const individualWeeklyRewardRate = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, totalRewardRatePerSecond);\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          rewardToken: rewardToken,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished: isPeriodFinished,\n          earnedAmount: earnedAmount,\n          rewardRatePerWeek: individualWeeklyRewardRate,\n          totalRewardRatePerSecond: totalRewardRatePerSecond,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          totalStakedInPng: totalStakedAmount,\n          getHypotheticalWeeklyRewardRate,\n          apr: apr\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [chainId, png, rewardsAddresses, balances, earnedAmounts, stakingTotalSupplies, rewardRates, periodFinishes, amountsOuts, info]);\n}\nexport function useTotalPngEarned() {\n  const chainId = useChainId();\n  const png = PNG[chainId];\n  const stakingInfo0 = useStakingInfo(0);\n  const stakingInfo1 = useStakingInfo(1);\n  const stakingInfo2 = useMinichefStakingInfos(2);\n  const earned0 = useMemo(() => {\n    var _stakingInfo0$reduce;\n\n    if (!png) new TokenAmount(png, '0');\n    return (_stakingInfo0$reduce = stakingInfo0 === null || stakingInfo0 === void 0 ? void 0 : stakingInfo0.reduce((accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount), new TokenAmount(png, '0'))) !== null && _stakingInfo0$reduce !== void 0 ? _stakingInfo0$reduce : new TokenAmount(png, '0');\n  }, [stakingInfo0, png]);\n  const earned1 = useMemo(() => {\n    var _stakingInfo1$reduce;\n\n    if (!png) new TokenAmount(png, '0');\n    return (_stakingInfo1$reduce = stakingInfo1 === null || stakingInfo1 === void 0 ? void 0 : stakingInfo1.reduce((accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount), new TokenAmount(png, '0'))) !== null && _stakingInfo1$reduce !== void 0 ? _stakingInfo1$reduce : new TokenAmount(png, '0');\n  }, [stakingInfo1, png]);\n  const earned2 = useMemo(() => {\n    var _stakingInfo2$reduce;\n\n    if (!png) new TokenAmount(png, '0');\n    return (_stakingInfo2$reduce = stakingInfo2 === null || stakingInfo2 === void 0 ? void 0 : stakingInfo2.reduce((accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount), new TokenAmount(png, '0'))) !== null && _stakingInfo2$reduce !== void 0 ? _stakingInfo2$reduce : new TokenAmount(png, '0');\n  }, [stakingInfo2, png]);\n  return earned0.add(earned1).add(earned2); // return earned0 ? (earned1 ? earned0.add(earned1) : earned0) : earned1 ? earned1 : undefined\n} // based on typed value\n\nexport function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const {\n    t\n  } = useTranslation();\n  const parsedInput = tryParseAmount(chainId, typedValue, stakingToken);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = t('stakeHooks.connectWallet');\n  }\n\n  if (!parsedAmount) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : t('stakeHooks.enterAmount');\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n} // based on typed value\n\nexport function useDerivedUnstakeInfo(typedValue, stakingAmount) {\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const {\n    t\n  } = useTranslation();\n  const parsedInput = tryParseAmount(chainId, typedValue, stakingAmount.token);\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = t('stakeHooks.connectWallet');\n  }\n\n  if (!parsedAmount) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : t('stakeHooks.enterAmount');\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n}\nexport function useGetStakingDataWithAPR(version) {\n  const stakingInfos = useStakingInfo(version);\n  const [stakingInfoData, setStakingInfoData] = useState(stakingInfos);\n  useEffect(() => {\n    if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {\n      Promise.all(stakingInfos.map(stakingInfo => {\n        const APR_URL = version < 2 ? `${PANGOLIN_API_BASE_URL}/pangolin/apr/${stakingInfo.stakingRewardAddress}` : `${PANGOLIN_API_BASE_URL}/pangolin/apr2/${stakingInfo.stakingRewardAddress}`;\n        return fetch(APR_URL).then(res => res.json()).then(res => ({\n          swapFeeApr: Number(res.swapFeeApr),\n          stakingApr: Number(res.stakingApr),\n          combinedApr: Number(res.combinedApr),\n          ...stakingInfo\n        }));\n      })).then(updatedStakingInfos => {\n        setStakingInfoData(updatedStakingInfos);\n      });\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length, version]);\n  return stakingInfoData;\n}\nexport function useGetPairDataFromPair(pair) {\n  var _usdPriceCurrency0$qu, _usdPriceCurrency1$qu;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const dummyToken = new Token(chainId, ZERO_ADDRESS, 18, 'PNG', 'Pangolin');\n  const token0 = (pair === null || pair === void 0 ? void 0 : pair.token0) || dummyToken;\n  const token1 = (pair === null || pair === void 0 ? void 0 : pair.token1) || dummyToken;\n  const usdPriceCurrency0Tmp = useUSDCPrice(token0);\n  const usdPriceCurrency0 = CHAINS[chainId].is_mainnet ? usdPriceCurrency0Tmp : undefined;\n  const usdPriceCurrency1Tmp = useUSDCPrice(token1);\n  const usdPriceCurrency1 = CHAINS[chainId].is_mainnet ? usdPriceCurrency1Tmp : undefined;\n  const zeroTokenAmount0 = new TokenAmount(token0, '0');\n  const zeroTokenAmount1 = new TokenAmount(token1, '0');\n  const userPoolBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pair.liquidityToken);\n  const totalPoolTokens = useTotalSupply(pair.liquidityToken);\n\n  const getHypotheticalPoolOwnership = (userBalance, poolTotalBalance) => {\n    if (!userBalance || !poolTotalBalance || JSBI.equal(poolTotalBalance, BIG_INT_ZERO)) {\n      return new Percent(BIG_INT_ZERO, BIG_INT_ONE);\n    }\n\n    return new Percent(userBalance, poolTotalBalance).multiply('100');\n  };\n\n  const poolTokenPercentage = !!userPoolBalance && !!totalPoolTokens && JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw) ? new Percent(userPoolBalance.raw, totalPoolTokens.raw) : undefined;\n  const [token0Deposited, token1Deposited] = !!pair && !!totalPoolTokens && !!userPoolBalance && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw) ? [pair.getLiquidityValue(pair.token0, totalPoolTokens, userPoolBalance, false), pair.getLiquidityValue(pair.token1, totalPoolTokens, userPoolBalance, false)] : [zeroTokenAmount0, zeroTokenAmount1];\n  const usdAmountCurrency0 = (_usdPriceCurrency0$qu = usdPriceCurrency0 === null || usdPriceCurrency0 === void 0 ? void 0 : usdPriceCurrency0.quote(token0Deposited, chainId)) !== null && _usdPriceCurrency0$qu !== void 0 ? _usdPriceCurrency0$qu : zeroTokenAmount0;\n  const usdAmountCurrency1 = (_usdPriceCurrency1$qu = usdPriceCurrency1 === null || usdPriceCurrency1 === void 0 ? void 0 : usdPriceCurrency1.quote(token1Deposited, chainId)) !== null && _usdPriceCurrency1$qu !== void 0 ? _usdPriceCurrency1$qu : zeroTokenAmount1;\n  const totalAmountUsd = usdAmountCurrency0 === null || usdAmountCurrency0 === void 0 ? void 0 : usdAmountCurrency0.add(usdAmountCurrency1);\n  return {\n    currency0: pair.token0,\n    currency1: pair.token1,\n    userPoolBalance: userPoolBalance,\n    totalPoolTokens: totalPoolTokens,\n    token0Deposited: token0Deposited,\n    token1Deposited: token1Deposited,\n    totalAmountUsd: totalAmountUsd,\n    poolTokenPercentage: poolTokenPercentage,\n    getHypotheticalPoolOwnership\n  };\n}\nexport const useMinichefPools = () => {\n  const chainId = useChainId();\n  const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId]);\n  const lpTokens = useSingleCallResult(minichefContract, 'lpTokens', []).result;\n  const lpTokensArr = lpTokens === null || lpTokens === void 0 ? void 0 : lpTokens[0];\n  return useMemo(() => {\n    const poolMap = {};\n\n    if (lpTokensArr) {\n      lpTokensArr.forEach((address, index) => {\n        poolMap[address] = index;\n      });\n    }\n\n    return poolMap;\n  }, [lpTokensArr]);\n};\nexport const useMinichefStakingInfos = function () {\n  let version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n  let pairToFilterBy = arguments.length > 1 ? arguments[1] : undefined;\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId]);\n  const poolMap = useMinichefPools();\n  const png = PNG[chainId];\n  const info = useMemo(() => {\n    var _DOUBLE_SIDE_STAKING_4, _DOUBLE_SIDE_STAKING_5, _DOUBLE_SIDE_STAKING_6;\n\n    return chainId ? (_DOUBLE_SIDE_STAKING_4 = (_DOUBLE_SIDE_STAKING_5 = DOUBLE_SIDE_STAKING_REWARDS_INFO[chainId]) === null || _DOUBLE_SIDE_STAKING_5 === void 0 ? void 0 : (_DOUBLE_SIDE_STAKING_6 = _DOUBLE_SIDE_STAKING_5[version]) === null || _DOUBLE_SIDE_STAKING_6 === void 0 ? void 0 : _DOUBLE_SIDE_STAKING_6.filter(item => pairToFilterBy === undefined ? true : pairToFilterBy === null ? false : pairToFilterBy.involvesToken(item.tokens[0]) && pairToFilterBy.involvesToken(item.tokens[1]))) !== null && _DOUBLE_SIDE_STAKING_4 !== void 0 ? _DOUBLE_SIDE_STAKING_4 : [] : [];\n  }, [chainId, pairToFilterBy, version]);\n  const tokens = useMemo(() => info.map(_ref7 => {\n    let {\n      tokens\n    } = _ref7;\n    return tokens;\n  }), [info]);\n  const pairs = usePairs(tokens); // @dev: If no farms load, you likely loaded an incorrect config from doubleSideConfig.js\n  // Enable this and look for an invalid pair\n  // console.log(pairs)\n\n  const pairAddresses = useMemo(() => {\n    return pairs.map(_ref8 => {\n      let [, pair] = _ref8;\n      return pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address;\n    });\n  }, [pairs]);\n  const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');\n  const balances = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'balanceOf', [MINICHEF_ADDRESS[chainId]]);\n  const [avaxPngPairState, avaxPngPair] = usePair(WAVAX[chainId], png);\n  const poolIdArray = useMemo(() => {\n    if (!pairAddresses || !poolMap) return []; // TODO: clean up this logic. seems like a lot of work to ensure correct types\n\n    const NOT_FOUND = -1;\n    const results = pairAddresses.map(address => {\n      var _poolMap;\n\n      return (_poolMap = poolMap[address !== null && address !== void 0 ? address : '']) !== null && _poolMap !== void 0 ? _poolMap : NOT_FOUND;\n    });\n    if (results.some(result => result === NOT_FOUND)) return [];\n    return results;\n  }, [poolMap, pairAddresses]);\n  const poolsIdInput = useMemo(() => {\n    if (!poolIdArray) return [];\n    return poolIdArray.map(pid => [pid]);\n  }, [poolIdArray]);\n  const poolInfos = useSingleContractMultipleData(minichefContract, 'poolInfo', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);\n  const rewarders = useSingleContractMultipleData(minichefContract, 'rewarder', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);\n  const userInfoInput = useMemo(() => {\n    if (!poolIdArray || !account) return [];\n    return poolIdArray.map(pid => [pid, account]);\n  }, [poolIdArray, account]);\n  const userInfos = useSingleContractMultipleData(minichefContract, 'userInfo', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);\n  const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);\n  const rewardsAddresses = useMemo(() => {\n    if ((rewarders || []).length === 0) return [];\n    if (rewarders.some(item => item.loading)) return [];\n    return rewarders.map(reward => {\n      var _reward$result;\n\n      return reward === null || reward === void 0 ? void 0 : (_reward$result = reward.result) === null || _reward$result === void 0 ? void 0 : _reward$result[0];\n    });\n  }, [rewarders]);\n  const rewardTokensAddresses = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardTokens', []);\n  const rewardTokensMultipliers = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardMultipliers', []);\n  const rewardPerSecond = useSingleCallResult(minichefContract, 'rewardPerSecond', []).result;\n  const totalAllocPoint = useSingleCallResult(minichefContract, 'totalAllocPoint', []).result;\n  const rewardsExpiration = useSingleCallResult(minichefContract, 'rewardsExpiration', []).result;\n  const usdPriceTmp = useUSDCPrice(WAVAX[chainId]);\n  const usdPrice = CHAINS[chainId].is_mainnet ? usdPriceTmp : undefined;\n  const arr = useMemo(() => {\n    if (!chainId || !png) return [];\n    return pairAddresses.reduce((memo, pairAddress, index) => {\n      const pairTotalSupplyState = pairTotalSupplies[index];\n      const balanceState = balances[index];\n      const poolInfo = poolInfos[index];\n      const userPoolInfo = userInfos[index];\n      const [pairState, pair] = pairs[index];\n      const pendingRewardInfo = pendingRewards[index];\n      const rewardTokensAddress = rewardTokensAddresses[index];\n      const rewardTokensMultiplier = rewardTokensMultipliers[index];\n      const rewardsAddress = rewardsAddresses[index];\n\n      if ((pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.loading) === false && (poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.loading) === false && (balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) === false && pair && avaxPngPair && pairState !== PairState.LOADING && avaxPngPairState !== PairState.LOADING && rewardPerSecond && totalAllocPoint && (rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : rewardsExpiration[0]) && (rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : rewardTokensAddress.loading) === false) {\n        var _poolInfo$result, _rewardsExpiration$, _rewardsExpiration$$m, _balanceState$result3, _pairTotalSupplyState2, _balanceState$result4, _userPoolInfo$result$, _userPoolInfo$result, _pendingRewardInfo$re, _pendingRewardInfo$re2, _poolInfo$result2, _rewardTokensAddress$, _rewardTokensMultipli;\n\n        if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) || pairTotalSupplyState.error || pairState === PairState.INVALID || pairState === PairState.NOT_EXISTS || avaxPngPairState === PairState.INVALID || avaxPngPairState === PairState.NOT_EXISTS) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        } // get the LP token\n\n\n        const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;\n        const token1 = pair === null || pair === void 0 ? void 0 : pair.token1;\n        const tokens = [token0, token1].sort((_ref9, _ref10) => {\n          let {\n            address: addressA\n          } = _ref9;\n          let {\n            address: addressB\n          } = _ref10;\n          // Sort AVAX last\n          if (addressA === WAVAX[ChainId.AVALANCHE].address) return 1;else if (addressB === WAVAX[ChainId.AVALANCHE].address) return -1; // Sort PNG first\n          else if (addressA === PNG[ChainId.AVALANCHE].address) return -1;else if (addressB === PNG[ChainId.AVALANCHE].address) return 1; // Sort axlUST first\n          else if (addressA === axlUST[ChainId.AVALANCHE].address) return -1;else if (addressB === axlUST[ChainId.AVALANCHE].address) return 1; // Sort USDC first\n          else if (addressA === USDC[ChainId.AVALANCHE].address) return -1;else if (addressB === USDC[ChainId.AVALANCHE].address) return 1; // Sort USDCe first\n          else if (addressA === USDCe[ChainId.AVALANCHE].address) return -1;else if (addressB === USDCe[ChainId.AVALANCHE].address) return 1;else return 0;\n        });\n        const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId);\n        const lpToken = dummyPair.liquidityToken;\n        const poolAllocPointAmount = new TokenAmount(lpToken, JSBI.BigInt(poolInfo === null || poolInfo === void 0 ? void 0 : (_poolInfo$result = poolInfo.result) === null || _poolInfo$result === void 0 ? void 0 : _poolInfo$result['allocPoint']));\n        const totalAllocPointAmount = new TokenAmount(lpToken, JSBI.BigInt(totalAllocPoint === null || totalAllocPoint === void 0 ? void 0 : totalAllocPoint[0]));\n        const rewardRatePerSecAmount = new TokenAmount(png, JSBI.BigInt(rewardPerSecond === null || rewardPerSecond === void 0 ? void 0 : rewardPerSecond[0]));\n        const poolRewardRate = new TokenAmount(png, JSBI.divide(JSBI.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw));\n        const totalRewardRatePerWeek = new TokenAmount(png, JSBI.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK));\n        const periodFinishMs = rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : (_rewardsExpiration$ = rewardsExpiration[0]) === null || _rewardsExpiration$ === void 0 ? void 0 : (_rewardsExpiration$$m = _rewardsExpiration$.mul(1000)) === null || _rewardsExpiration$$m === void 0 ? void 0 : _rewardsExpiration$$m.toNumber(); // periodFinish will be 0 immediately after a reward contract is initialized\n\n        const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0');\n        const totalSupplyStaked = JSBI.BigInt(balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result3 = balanceState.result) === null || _balanceState$result3 === void 0 ? void 0 : _balanceState$result3[0]);\n        const totalSupplyAvailable = JSBI.BigInt(pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : (_pairTotalSupplyState2 = pairTotalSupplyState.result) === null || _pairTotalSupplyState2 === void 0 ? void 0 : _pairTotalSupplyState2[0]);\n        const totalStakedAmount = new TokenAmount(lpToken, JSBI.BigInt(balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result4 = balanceState.result) === null || _balanceState$result4 === void 0 ? void 0 : _balanceState$result4[0]));\n        const stakedAmount = new TokenAmount(lpToken, JSBI.BigInt((_userPoolInfo$result$ = userPoolInfo === null || userPoolInfo === void 0 ? void 0 : (_userPoolInfo$result = userPoolInfo.result) === null || _userPoolInfo$result === void 0 ? void 0 : _userPoolInfo$result['amount']) !== null && _userPoolInfo$result$ !== void 0 ? _userPoolInfo$result$ : 0));\n        const earnedAmount = new TokenAmount(png, JSBI.BigInt((_pendingRewardInfo$re = pendingRewardInfo === null || pendingRewardInfo === void 0 ? void 0 : (_pendingRewardInfo$re2 = pendingRewardInfo.result) === null || _pendingRewardInfo$re2 === void 0 ? void 0 : _pendingRewardInfo$re2['pending']) !== null && _pendingRewardInfo$re !== void 0 ? _pendingRewardInfo$re : 0));\n        const multiplier = JSBI.BigInt(poolInfo === null || poolInfo === void 0 ? void 0 : (_poolInfo$result2 = poolInfo.result) === null || _poolInfo$result2 === void 0 ? void 0 : _poolInfo$result2['allocPoint']);\n        const isAvaxPool = pair.involvesToken(WAVAX[chainId]);\n        const isPngPool = pair.involvesToken(PNG[chainId]);\n        let totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(DAIe[chainId], BIG_INT_ZERO) : undefined;\n        const totalStakedInWavax = new TokenAmount(WAVAX[chainId], BIG_INT_ZERO);\n\n        if (JSBI.equal(totalSupplyAvailable, BIG_INT_ZERO)) {// Default to 0 values above avoiding division by zero errors\n        } else if (pair.involvesToken(DAIe[chainId])) {\n          const pairValueInDAI = JSBI.multiply(pair.reserveOf(DAIe[chainId]).raw, BIG_INT_TWO);\n          const stakedValueInDAI = JSBI.divide(JSBI.multiply(pairValueInDAI, totalSupplyStaked), totalSupplyAvailable);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(DAIe[chainId], stakedValueInDAI) : undefined;\n        } else if (pair.involvesToken(USDCe[chainId])) {\n          const pairValueInUSDC = JSBI.multiply(pair.reserveOf(USDCe[chainId]).raw, BIG_INT_TWO);\n          const stakedValueInUSDC = JSBI.divide(JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(USDCe[chainId], stakedValueInUSDC) : undefined;\n        } else if (pair.involvesToken(USDC[chainId])) {\n          const pairValueInUSDC = JSBI.multiply(pair.reserveOf(USDC[chainId]).raw, BIG_INT_TWO);\n          const stakedValueInUSDC = JSBI.divide(JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(USDC[chainId], stakedValueInUSDC) : undefined;\n        } else if (pair.involvesToken(axlUST[chainId])) {\n          const pairValueInUST = JSBI.multiply(pair.reserveOf(axlUST[chainId]).raw, BIG_INT_TWO);\n          const stakedValueInUST = JSBI.divide(JSBI.multiply(pairValueInUST, totalSupplyStaked), totalSupplyAvailable);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(axlUST[chainId], stakedValueInUST) : undefined;\n        } else if (pair.involvesToken(USDTe[chainId])) {\n          const pairValueInUSDT = JSBI.multiply(pair.reserveOf(USDTe[chainId]).raw, BIG_INT_TWO);\n          const stakedValueInUSDT = JSBI.divide(JSBI.multiply(pairValueInUSDT, totalSupplyStaked), totalSupplyAvailable);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? new TokenAmount(USDTe[chainId], stakedValueInUSDT) : undefined;\n        } else if (isAvaxPool) {\n          const totalStakedInWavax = calculateTotalStakedAmountInAvax(totalSupplyStaked, totalSupplyAvailable, pair.reserveOf(WAVAX[chainId]).raw, chainId);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(totalStakedInWavax, chainId)) : undefined;\n        } else if (isPngPool) {\n          const totalStakedInWavax = calculateTotalStakedAmountInAvaxFromPng(totalSupplyStaked, totalSupplyAvailable, avaxPngPair.reserveOf(png).raw, avaxPngPair.reserveOf(WAVAX[chainId]).raw, pair.reserveOf(png).raw, chainId);\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet ? totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(totalStakedInWavax, chainId)) : undefined;\n        } else {\n          // Contains no stablecoin, WAVAX, nor PNG\n          console.error(`Could not identify total staked value for pair ${pair.liquidityToken.address}`);\n        }\n\n        const getHypotheticalWeeklyRewardRate = (stakedAmount, totalStakedAmount, totalRewardRatePerSecond) => {\n          return new TokenAmount(png, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), totalStakedAmount.raw) : JSBI.BigInt(0));\n        };\n\n        const getExtraTokensWeeklyRewardRate = (rewardRatePerWeek, token, tokenMultiplier) => {\n          const TEN_EIGHTEEN = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(18)); // const secondToWeekConversion = JSBI.BigInt(60 * 60 * 24 * 7)\n\n          const rewardMultiplier = JSBI.BigInt(tokenMultiplier || 1);\n          const unadjustedRewardPerWeek = JSBI.multiply(rewardMultiplier, rewardRatePerWeek === null || rewardRatePerWeek === void 0 ? void 0 : rewardRatePerWeek.raw); // const finalReward = JSBI.divide(JSBI.multiply(unadjustedRewardPerWeek, secondToWeekConversion), TEN_EIGHTEEN)\n\n          const finalReward = JSBI.divide(unadjustedRewardPerWeek, TEN_EIGHTEEN);\n          return new TokenAmount(token, finalReward);\n        };\n\n        const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate);\n        memo.push({\n          stakingRewardAddress: MINICHEF_ADDRESS[chainId],\n          tokens,\n          earnedAmount,\n          rewardRatePerWeek: userRewardRatePerWeek,\n          totalRewardRatePerSecond: poolRewardRate,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount,\n          totalStakedAmount,\n          totalStakedInWavax,\n          totalStakedInUsd,\n          multiplier: JSBI.divide(multiplier, JSBI.BigInt(100)),\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished,\n          getHypotheticalWeeklyRewardRate,\n          getExtraTokensWeeklyRewardRate,\n          rewardTokensAddress: rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : (_rewardTokensAddress$ = rewardTokensAddress.result) === null || _rewardTokensAddress$ === void 0 ? void 0 : _rewardTokensAddress$[0],\n          rewardTokensMultiplier: rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : (_rewardTokensMultipli = rewardTokensMultiplier.result) === null || _rewardTokensMultipli === void 0 ? void 0 : _rewardTokensMultipli[0],\n          rewardsAddress\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [chainId, png, pairTotalSupplies, poolInfos, userInfos, pairs, avaxPngPair, avaxPngPairState, rewardPerSecond, totalAllocPoint, pendingRewards, rewardsExpiration, balances, usdPrice, pairAddresses, rewardTokensAddresses, rewardsAddresses, rewardTokensMultipliers]);\n  return arr;\n};\nexport function useGetPoolDollerWorth(pair) {\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;\n  const currency0 = unwrappedToken(token0, chainId);\n  const currency0PriceTmp = useUSDCPrice(currency0);\n  const currency0Price = CHAINS[chainId].is_mainnet ? currency0PriceTmp : undefined;\n  const userPglTmp = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const userPgl = CHAINS[chainId].is_mainnet ? userPglTmp : undefined;\n  const totalPoolTokens = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const [token0Deposited] = !!pair && !!totalPoolTokens && !!userPgl && // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPgl.raw) ? [pair.getLiquidityValue(pair.token0, totalPoolTokens, userPgl, false), pair.getLiquidityValue(pair.token1, totalPoolTokens, userPgl, false)] : [undefined, undefined];\n  const liquidityInUSD = CHAINS[chainId].is_mainnet ? currency0Price && token0Deposited ? Number(currency0Price.toFixed()) * 2 * Number(token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6)) : 0 : 0; //\n\n  return useMemo(() => ({\n    userPgl,\n    liquidityInUSD\n  }), [userPgl, liquidityInUSD]);\n}\nexport function useMinichefPendingRewards(miniChefStaking) {\n  var _miniChefStaking$earn, _rewardTokenAmounts$, _rewardTokenAmounts$$;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const rewardAddress = miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.rewardsAddress;\n  const rewardContract = useRewardViaMultiplierContract(rewardAddress !== ZERO_ADDRESS ? rewardAddress : undefined);\n  const earnedAmount = (miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.earnedAmount) ? JSBI.BigInt(miniChefStaking === null || miniChefStaking === void 0 ? void 0 : (_miniChefStaking$earn = miniChefStaking.earnedAmount) === null || _miniChefStaking$earn === void 0 ? void 0 : _miniChefStaking$earn.raw).toString() : JSBI.BigInt(0).toString();\n  const rewardTokenAmounts = useSingleContractMultipleData(rewardContract, 'pendingTokens', account ? [[0, account, earnedAmount]] : []);\n  const rewardTokens = useTokens(miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.rewardTokensAddress);\n  const rewardAmounts = (rewardTokenAmounts === null || rewardTokenAmounts === void 0 ? void 0 : (_rewardTokenAmounts$ = rewardTokenAmounts[0]) === null || _rewardTokenAmounts$ === void 0 ? void 0 : (_rewardTokenAmounts$$ = _rewardTokenAmounts$.result) === null || _rewardTokenAmounts$$ === void 0 ? void 0 : _rewardTokenAmounts$$.amounts) || []; // eslint-disable-line react-hooks/exhaustive-deps\n\n  const rewardTokensAmount = useMemo(() => {\n    if (!rewardTokens) return [];\n    return rewardTokens.map((rewardToken, index) => new TokenAmount(rewardToken, rewardAmounts[index] || 0));\n  }, [rewardAmounts, rewardTokens]);\n  return useMemo(() => ({\n    rewardTokensAmount\n  }), [rewardTokensAmount]);\n}\nexport function useDerivedStakingProcess(stakingInfo) {\n  var _stakingInfo$stakedAm, _stakingInfo$stakedAm2, _stakingInfo$stakedAm3, _ref11;\n\n  const {\n    account,\n    library\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const {\n    t\n  } = useTranslation();\n  const png = PNG[chainId];\n  const usdcPrice = useUSDCPrice(png); // detect existing unstaked position to show purchase button if none found\n\n  const userPngUnstaked = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingInfo === null || stakingInfo === void 0 ? void 0 : (_stakingInfo$stakedAm = stakingInfo.stakedAmount) === null || _stakingInfo$stakedAm === void 0 ? void 0 : _stakingInfo$stakedAm.token);\n  const stakeToken = stakingInfo === null || stakingInfo === void 0 ? void 0 : (_stakingInfo$stakedAm2 = stakingInfo.stakedAmount) === null || _stakingInfo$stakedAm2 === void 0 ? void 0 : (_stakingInfo$stakedAm3 = _stakingInfo$stakedAm2.token) === null || _stakingInfo$stakedAm3 === void 0 ? void 0 : _stakingInfo$stakedAm3.symbol;\n  const [stepIndex, setStepIndex] = useState(4); // track and parse user input\n\n  const [typedValue, setTypedValue] = useState(((_ref11 = userPngUnstaked) === null || _ref11 === void 0 ? void 0 : _ref11.toExact()) || '');\n  const {\n    parsedAmount,\n    error\n  } = useDerivedStakeInfo(typedValue, stakingInfo.stakedAmount.token, userPngUnstaked);\n  const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId);\n  let hypotheticalRewardRatePerWeek = new TokenAmount(stakingInfo.rewardRatePerWeek.token, '0');\n\n  if (parsedAmountWrapped === null || parsedAmountWrapped === void 0 ? void 0 : parsedAmountWrapped.greaterThan('0')) {\n    hypotheticalRewardRatePerWeek = stakingInfo.getHypotheticalWeeklyRewardRate(stakingInfo.stakedAmount.add(parsedAmountWrapped), stakingInfo.totalStakedAmount.add(parsedAmountWrapped), stakingInfo.totalRewardRatePerSecond);\n  }\n\n  const dollerWorth = (userPngUnstaked === null || userPngUnstaked === void 0 ? void 0 : userPngUnstaked.greaterThan('0')) && usdcPrice ? Number(typedValue) * Number(usdcPrice.toFixed()) : undefined; // state for pending and submitted txn views\n\n  const addTransaction = useTransactionAdder();\n  const [attempting, setAttempting] = useState(false);\n  const [hash, setHash] = useState();\n  const wrappedOnDismiss = useCallback(() => {\n    setSignatureData(null);\n    setTypedValue('0');\n    setStepIndex(0);\n    setHash(undefined);\n    setAttempting(false); // onClose && onClose()\n  }, []);\n  const stakingTokenContract = usePngContract(); // approval data for stake\n\n  const deadline = useTransactionDeadline();\n  const [signatureData, setSignatureData] = useState(null);\n  const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo.stakingRewardAddress);\n  const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress);\n\n  async function onStake() {\n    setAttempting(true);\n\n    if (stakingContract && parsedAmount && deadline) {\n      if (approval === ApprovalState.APPROVED) {\n        stakingContract.stake(`0x${parsedAmount.raw.toString(16)}`).then(response => {\n          addTransaction(response, {\n            summary: t('earnPage.stakeStakingTokens', {\n              symbol: 'PNG'\n            })\n          });\n          setHash(response.hash);\n        }).catch(error => {\n          setAttempting(false); // we only care if the error is something _other_ than the user rejected the tx\n\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.error(error);\n          }\n        });\n      } else if (signatureData) {\n        stakingContract.stakeWithPermit(`0x${parsedAmount.raw.toString(16)}`, signatureData.deadline, signatureData.v, signatureData.r, signatureData.s).then(response => {\n          addTransaction(response, {\n            summary: t('earnPage.stakeStakingTokens', {\n              symbol: 'PNG'\n            })\n          });\n          setHash(response.hash);\n        }).catch(error => {\n          setAttempting(false); // we only care if the error is something _other_ than the user rejected the tx\n\n          if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n            console.error(error);\n          }\n        });\n      } else {\n        setAttempting(false);\n        throw new Error(t('earn.attemptingToStakeError'));\n      }\n    }\n  }\n\n  const onChangePercentage = value => {\n    // setStepIndex(value)\n    if (!userPngUnstaked) {\n      setTypedValue('0');\n      return;\n    }\n\n    if (value === 100) {\n      setTypedValue(userPngUnstaked.toExact());\n    } else if (value === 0) {\n      setTypedValue('0');\n    } else {\n      const newAmount = userPngUnstaked.multiply(JSBI.BigInt(value)).divide(JSBI.BigInt(100));\n      setTypedValue(newAmount.toSignificant(6));\n    }\n  }; // wrapped onUserInput to clear signatures\n\n\n  const onUserInput = useCallback(typedValue => {\n    setSignatureData(null);\n    setTypedValue(typedValue);\n  }, []); // used for max input button\n\n  const maxAmountInput = maxAmountSpend(chainId, userPngUnstaked); // const atMaxAmount = Boolean(maxAmountInput && parsedAmount?.equalTo(maxAmountInput))\n\n  const handleMax = useCallback(() => {\n    maxAmountInput && onUserInput(maxAmountInput.toExact());\n    setStepIndex(4);\n  }, [maxAmountInput, onUserInput]);\n\n  async function onAttemptToApprove() {\n    if (!stakingTokenContract || !library || !deadline) throw new Error(t('earn.missingDependencies'));\n    const liquidityAmount = parsedAmount;\n    if (!liquidityAmount) throw new Error(t('earn.missingLiquidityAmount')); // try to gather a signature for permission\n\n    const nonce = await stakingTokenContract.nonces(account);\n    const EIP712Domain = [{\n      name: 'name',\n      type: 'string'\n    }, {\n      name: 'chainId',\n      type: 'uint256'\n    }, {\n      name: 'verifyingContract',\n      type: 'address'\n    }];\n    const domain = {\n      name: 'Pangolin',\n      chainId: chainId,\n      verifyingContract: stakingTokenContract.address\n    };\n    const Permit = [{\n      name: 'owner',\n      type: 'address'\n    }, {\n      name: 'spender',\n      type: 'address'\n    }, {\n      name: 'value',\n      type: 'uint256'\n    }, {\n      name: 'nonce',\n      type: 'uint256'\n    }, {\n      name: 'deadline',\n      type: 'uint256'\n    }];\n    const message = {\n      owner: account,\n      spender: stakingInfo.stakingRewardAddress,\n      value: liquidityAmount.raw.toString(),\n      nonce: nonce.toHexString(),\n      deadline: deadline.toNumber()\n    };\n    const data = JSON.stringify({\n      types: {\n        EIP712Domain,\n        Permit\n      },\n      domain,\n      primaryType: 'Permit',\n      message\n    });\n    library.send('eth_signTypedData_v4', [account, data]).then(splitSignature).then(signature => {\n      setSignatureData({\n        v: signature.v,\n        r: signature.r,\n        s: signature.s,\n        deadline: deadline.toNumber()\n      });\n    }).catch(error => {\n      // for all errors other than 4001 (EIP-1193 user rejected request), fall back to manual approve\n      if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {\n        approveCallback();\n      }\n    });\n  }\n\n  return useMemo(() => ({\n    attempting,\n    stakeToken,\n    parsedAmount,\n    hash,\n    userPngUnstaked,\n    stepIndex,\n    dollerWorth,\n    hypotheticalRewardRatePerWeek,\n    signatureData,\n    error,\n    approval,\n    account,\n    png,\n    onAttemptToApprove,\n    onUserInput,\n    wrappedOnDismiss,\n    handleMax,\n    onStake,\n    onChangePercentage,\n    setStepIndex\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  [attempting, stakeToken, parsedAmount, hash, userPngUnstaked, stepIndex, dollerWorth, hypotheticalRewardRatePerWeek, signatureData, error, approval, account, png, onUserInput, handleMax]);\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/stake/hooks.ts"],"names":["ChainId","JSBI","Token","TokenAmount","WAVAX","Pair","Percent","useMemo","useEffect","useState","useCallback","MINICHEF_ADDRESS","BIG_INT_ZERO","BIG_INT_TWO","BIG_INT_ONE","BIG_INT_SECONDS_IN_WEEK","PANGOLIN_API_BASE_URL","DAIe","PNG","USDC","USDCe","USDTe","axlUST","STAKING_REWARDS_INTERFACE","PairState","usePair","usePairs","useActiveWeb3React","NEVER_RELOAD","useMultipleContractSingleData","useSingleCallResult","useSingleContractMultipleData","tryParseAmount","useTranslation","ERC20_INTERFACE","REWARDER_VIA_MULTIPLIER_INTERFACE","useUSDCPrice","getRouterContract","useTokenBalance","useTotalSupply","usePngContract","useStakingContract","SINGLE_SIDE_STAKING_REWARDS_INFO","DOUBLE_SIDE_STAKING_REWARDS_INFO","ZERO_ADDRESS","CHAINS","unwrappedToken","useTokens","useRewardViaMultiplierContract","wrappedCurrencyAmount","useTransactionAdder","useTransactionDeadline","maxAmountSpend","useApproveCallback","ApprovalState","splitSignature","useChainId","calculateTotalStakedAmountInAvaxFromPng","amountStaked","amountAvailable","avaxPngPairReserveOfPng","avaxPngPairReserveOfWavax","reserveInPng","chainId","EQ","BigInt","oneToken","avaxPngRatio","divide","multiply","valueOfPngInAvax","calculateRewardRateInPng","rewardRate","valueOfPng","calculateApr","rewardRatePerSecond","totalSupply","rewardsPerYear","calculateTotalStakedAmountInAvax","reserveInWavax","GT","useStakingInfo","version","pairToFilterBy","account","info","filter","stakingRewardInfo","undefined","involvesToken","tokens","png","rewardsAddresses","map","stakingRewardAddress","accountArg","balances","earnedAmounts","stakingTotalSupplies","pairs","pairAddresses","pairsHaveLoaded","every","state","EXISTS","pair","liquidityToken","address","pairTotalSupplies","avaxPngPairState","avaxPngPair","rewardRates","periodFinishes","usdPriceTmp","usdPrice","is_mainnet","reduce","memo","rewardsAddress","index","balanceState","earnedAmountState","stakingTotalSupplyState","rewardRateState","periodFinishState","pairState","pairTotalSupplyState","loading","LOADING","error","INVALID","NOT_EXISTS","console","wavax","equals","dummyPair","periodFinishMs","result","mul","toNumber","isPeriodFinished","Date","now","totalSupplyStaked","totalSupplyAvailable","stakedAmount","totalStakedAmount","totalRewardRatePerSecond","totalRewardRatePerWeek","raw","isAvaxPool","totalStakedInWavax","reserveOf","totalStakedInUsd","quote","getHypotheticalWeeklyRewardRate","greaterThan","individualRewardRatePerWeek","multiplier","push","periodFinish","earnedAmount","rewardRatePerWeek","useSingleSideStakingInfo","rewardTokenToFilterBy","library","rewardToken","AVALANCHE","routes","conversionRouteHops","token","getAmountsOutArgs","amountIn","repeat","route","routerContract","amountsOuts","amountsOutsState","slice","rewardRateInPng","apr","individualWeeklyRewardRate","totalStakedInPng","useTotalPngEarned","stakingInfo0","stakingInfo1","stakingInfo2","useMinichefStakingInfos","earned0","accumulator","stakingInfo","add","earned1","earned2","useDerivedStakeInfo","typedValue","stakingToken","userLiquidityUnstaked","t","parsedInput","parsedAmount","lessThanOrEqual","useDerivedUnstakeInfo","stakingAmount","useGetStakingDataWithAPR","stakingInfos","stakingInfoData","setStakingInfoData","length","Promise","all","APR_URL","fetch","then","res","json","swapFeeApr","Number","stakingApr","combinedApr","updatedStakingInfos","useGetPairDataFromPair","dummyToken","token0","token1","usdPriceCurrency0Tmp","usdPriceCurrency0","usdPriceCurrency1Tmp","usdPriceCurrency1","zeroTokenAmount0","zeroTokenAmount1","userPoolBalance","totalPoolTokens","getHypotheticalPoolOwnership","userBalance","poolTotalBalance","equal","poolTokenPercentage","greaterThanOrEqual","token0Deposited","token1Deposited","getLiquidityValue","usdAmountCurrency0","usdAmountCurrency1","totalAmountUsd","currency0","currency1","useMinichefPools","minichefContract","lpTokens","lpTokensArr","poolMap","forEach","item","poolIdArray","NOT_FOUND","results","some","poolsIdInput","pid","poolInfos","rewarders","userInfoInput","userInfos","pendingRewards","reward","rewardTokensAddresses","rewardTokensMultipliers","rewardPerSecond","totalAllocPoint","rewardsExpiration","arr","pairAddress","poolInfo","userPoolInfo","pendingRewardInfo","rewardTokensAddress","rewardTokensMultiplier","sort","addressA","addressB","lpToken","poolAllocPointAmount","totalAllocPointAmount","rewardRatePerSecAmount","poolRewardRate","equalTo","isPngPool","pairValueInDAI","stakedValueInDAI","pairValueInUSDC","stakedValueInUSDC","pairValueInUST","stakedValueInUST","pairValueInUSDT","stakedValueInUSDT","getExtraTokensWeeklyRewardRate","tokenMultiplier","TEN_EIGHTEEN","exponentiate","rewardMultiplier","unadjustedRewardPerWeek","finalReward","userRewardRatePerWeek","useGetPoolDollerWorth","currency0PriceTmp","currency0Price","userPglTmp","userPgl","liquidityInUSD","toFixed","toSignificant","useMinichefPendingRewards","miniChefStaking","rewardAddress","rewardContract","toString","rewardTokenAmounts","rewardTokens","rewardAmounts","amounts","rewardTokensAmount","useDerivedStakingProcess","usdcPrice","userPngUnstaked","stakeToken","symbol","stepIndex","setStepIndex","setTypedValue","toExact","parsedAmountWrapped","hypotheticalRewardRatePerWeek","dollerWorth","addTransaction","attempting","setAttempting","hash","setHash","wrappedOnDismiss","setSignatureData","stakingTokenContract","deadline","signatureData","approval","approveCallback","stakingContract","onStake","APPROVED","stake","response","summary","catch","code","stakeWithPermit","v","r","s","Error","onChangePercentage","value","newAmount","onUserInput","maxAmountInput","handleMax","onAttemptToApprove","liquidityAmount","nonce","nonces","EIP712Domain","name","type","domain","verifyingContract","Permit","message","owner","spender","toHexString","data","JSON","stringify","types","primaryType","send","signature"],"mappings":"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","sourcesContent":["import { ChainId, CurrencyAmount, JSBI, Token, TokenAmount, WAVAX, Pair, Percent } from '@pangolindex/sdk'\nimport { useMemo, useEffect, useState, useCallback } from 'react'\nimport {\n  MINICHEF_ADDRESS,\n  BIG_INT_ZERO,\n  BIG_INT_TWO,\n  BIG_INT_ONE,\n  BIG_INT_SECONDS_IN_WEEK,\n  PANGOLIN_API_BASE_URL\n} from '../../constants'\nimport { DAIe, PNG, USDC, USDCe, USDTe, axlUST } from '../../constants/tokens'\nimport { STAKING_REWARDS_INTERFACE } from '../../constants/abis/staking-rewards'\nimport { PairState, usePair, usePairs } from '../../data/Reserves'\nimport { useActiveWeb3React } from '../../hooks'\nimport {\n  NEVER_RELOAD,\n  useMultipleContractSingleData,\n  useSingleCallResult,\n  useSingleContractMultipleData\n} from '../multicall/hooks'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useTranslation } from 'react-i18next'\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { REWARDER_VIA_MULTIPLIER_INTERFACE } from '../../constants/abis/rewarderViaMultiplier'\nimport useUSDCPrice from '../../utils/useUSDCPrice'\nimport { getRouterContract } from '../../utils'\nimport { useTokenBalance } from '../../state/wallet/hooks'\nimport { useTotalSupply } from '../../data/TotalSupply'\nimport { usePngContract, useStakingContract } from '../../hooks/useContract'\nimport { SINGLE_SIDE_STAKING_REWARDS_INFO } from './singleSideConfig'\nimport { DOUBLE_SIDE_STAKING_REWARDS_INFO } from './doubleSideConfig'\nimport { ZERO_ADDRESS } from '../../constants'\nimport { CHAINS } from '../../constants/chains'\nimport { unwrappedToken } from 'src/utils/wrappedCurrency'\nimport { useTokens } from '../../hooks/Tokens'\nimport { useRewardViaMultiplierContract } from '../../hooks/useContract'\nimport { wrappedCurrencyAmount } from 'src/utils/wrappedCurrency'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { useTransactionAdder } from 'src/state/transactions/hooks'\nimport useTransactionDeadline from 'src/hooks/useTransactionDeadline'\nimport { maxAmountSpend } from 'src/utils/maxAmountSpend'\nimport { useApproveCallback, ApprovalState } from 'src/hooks/useApproveCallback'\nimport { splitSignature } from 'ethers/lib/utils'\nimport { useChainId } from 'src/hooks'\n\nexport interface SingleSideStaking {\n  rewardToken: Token\n  conversionRouteHops: Token[]\n  stakingRewardAddress: string\n  version: number\n}\n\nexport interface DoubleSideStaking {\n  tokens: [Token, Token]\n  stakingRewardAddress: string\n  version: number\n  multiplier?: number\n}\n\nexport interface Migration {\n  from: DoubleSideStaking\n  to: DoubleSideStaking\n}\n\nexport interface BridgeMigrator {\n  aeb: string\n  ab: string\n}\n\nexport interface StakingInfoBase {\n  // the address of the reward contract\n  stakingRewardAddress: string\n  // the amount of token currently staked, or undefined if no account\n  stakedAmount: TokenAmount\n  // the amount of reward token earned by the active account, or undefined if no account\n  earnedAmount: TokenAmount\n  // the total amount of token staked in the contract\n  totalStakedAmount: TokenAmount\n  // the amount of token distributed per second to all LPs, constant\n  totalRewardRatePerSecond: TokenAmount\n  totalRewardRatePerWeek: TokenAmount\n  // the current amount of token distributed to the active account per week.\n  // equivalent to percent of total supply * reward rate * (60 * 60 * 24 * 7)\n  rewardRatePerWeek: TokenAmount\n  // when the period ends\n  periodFinish: Date | undefined\n  // has the reward period expired\n  isPeriodFinished: boolean\n  // calculates a hypothetical amount of token distributed to the active account per second.\n  getHypotheticalWeeklyRewardRate: (\n    stakedAmount: TokenAmount,\n    totalStakedAmount: TokenAmount,\n    totalRewardRatePerSecond: TokenAmount\n  ) => TokenAmount\n}\n\nexport interface SingleSideStakingInfo extends StakingInfoBase {\n  // the token being earned\n  rewardToken: Token\n  // total staked PNG in the pool\n  totalStakedInPng: TokenAmount\n  apr: JSBI\n}\n\nexport interface DoubleSideStakingInfo extends StakingInfoBase {\n  // the tokens involved in this pair\n  tokens: [Token, Token]\n  // the pool weight\n  multiplier: JSBI\n  // total staked AVAX in the pool\n  totalStakedInWavax: TokenAmount\n  totalStakedInUsd: TokenAmount\n  rewardTokensAddress?: Array<string>\n  rewardsAddress?: string\n  rewardTokensMultiplier?: Array<JSBI>\n  getExtraTokensWeeklyRewardRate?: (\n    rewardRatePerWeek: TokenAmount,\n    token: Token,\n    tokenMultiplier: JSBI | undefined\n  ) => TokenAmount\n}\n\nexport interface StakingInfo extends DoubleSideStakingInfo {\n  swapFeeApr?: number\n  stakingApr?: number\n  combinedApr?: number\n}\n\nconst calculateTotalStakedAmountInAvaxFromPng = function(\n  amountStaked: JSBI,\n  amountAvailable: JSBI,\n  avaxPngPairReserveOfPng: JSBI,\n  avaxPngPairReserveOfWavax: JSBI,\n  reserveInPng: JSBI,\n  chainId: ChainId\n): TokenAmount {\n  if (JSBI.EQ(amountAvailable, JSBI.BigInt(0))) {\n    return new TokenAmount(WAVAX[chainId], JSBI.BigInt(0))\n  }\n\n  const oneToken = JSBI.BigInt(1000000000000000000)\n  const avaxPngRatio = JSBI.divide(JSBI.multiply(oneToken, avaxPngPairReserveOfWavax), avaxPngPairReserveOfPng)\n  const valueOfPngInAvax = JSBI.divide(JSBI.multiply(reserveInPng, avaxPngRatio), oneToken)\n\n  return new TokenAmount(\n    WAVAX[chainId],\n    JSBI.divide(\n      JSBI.multiply(\n        JSBI.multiply(amountStaked, valueOfPngInAvax),\n        JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the wavax they entitle owner to\n      ),\n      amountAvailable\n    )\n  )\n}\n\nconst calculateRewardRateInPng = function(rewardRate: JSBI, valueOfPng: JSBI | null): JSBI {\n  if (!valueOfPng || JSBI.EQ(valueOfPng, 0)) return JSBI.BigInt(0)\n\n  // TODO: Handle situation where stakingToken and rewardToken have different decimals\n  const oneToken = JSBI.BigInt(1000000000000000000)\n\n  return JSBI.divide(\n    JSBI.multiply(rewardRate, oneToken), // Multiply first for precision\n    valueOfPng\n  )\n}\n\nconst calculateApr = function(rewardRatePerSecond: JSBI, totalSupply: JSBI): JSBI {\n  if (JSBI.EQ(totalSupply, 0)) {\n    return JSBI.BigInt(0)\n  }\n\n  const rewardsPerYear = JSBI.multiply(\n    rewardRatePerSecond,\n    JSBI.BigInt(31536000) // Seconds in year\n  )\n\n  return JSBI.divide(JSBI.multiply(rewardsPerYear, JSBI.BigInt(100)), totalSupply)\n}\n\nconst calculateTotalStakedAmountInAvax = function(\n  amountStaked: JSBI,\n  amountAvailable: JSBI,\n  reserveInWavax: JSBI,\n  chainId: ChainId\n): TokenAmount {\n  if (JSBI.GT(amountAvailable, 0)) {\n    // take the total amount of LP tokens staked, multiply by AVAX value of all LP tokens, divide by all LP tokens\n    return new TokenAmount(\n      WAVAX[chainId],\n      JSBI.divide(\n        JSBI.multiply(\n          JSBI.multiply(amountStaked, reserveInWavax),\n          JSBI.BigInt(2) // this is b/c the value of LP shares are ~double the value of the wavax they entitle owner to\n        ),\n        amountAvailable\n      )\n    )\n  } else {\n    return new TokenAmount(WAVAX[chainId], JSBI.BigInt(0))\n  }\n}\n\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(version: number, pairToFilterBy?: Pair | null): DoubleSideStakingInfo[] {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? DOUBLE_SIDE_STAKING_REWARDS_INFO[chainId]?.[version]?.filter(stakingRewardInfo =>\n            pairToFilterBy === undefined\n              ? true\n              : pairToFilterBy === null\n              ? false\n              : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n                pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])\n          ) ?? []\n        : [],\n    [chainId, pairToFilterBy, version]\n  )\n\n  const png = PNG[chainId]\n\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n  const accountArg = useMemo(() => [account ?? undefined], [account])\n\n  // get all the info from the staking rewards contracts\n  const tokens = useMemo(() => info.map(({ tokens }) => tokens), [info])\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const stakingTotalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n  const pairs = usePairs(tokens)\n\n  const pairAddresses = useMemo(() => {\n    const pairsHaveLoaded = pairs?.every(([state]) => state === PairState.EXISTS)\n    if (!pairsHaveLoaded) return []\n    else return pairs.map(([, pair]) => pair?.liquidityToken.address)\n  }, [pairs])\n\n  const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply')\n\n  const [avaxPngPairState, avaxPngPair] = usePair(WAVAX[chainId], png)\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n  const periodFinishes = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const usdPriceTmp = useUSDCPrice(WAVAX[chainId])\n  const usdPrice = CHAINS[chainId].is_mainnet ? usdPriceTmp : undefined\n\n  return useMemo(() => {\n    if (!chainId || !png) return []\n\n    return rewardsAddresses.reduce<DoubleSideStakingInfo[]>((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index]\n      const earnedAmountState = earnedAmounts[index]\n\n      // these get fetched regardless of account\n      const stakingTotalSupplyState = stakingTotalSupplies[index]\n      const rewardRateState = rewardRates[index]\n      const periodFinishState = periodFinishes[index]\n      const [pairState, pair] = pairs[index]\n      const pairTotalSupplyState = pairTotalSupplies[index]\n\n      if (\n        // these may be undefined if not logged in\n        !balanceState?.loading &&\n        !earnedAmountState?.loading &&\n        // always need these\n        stakingTotalSupplyState?.loading === false &&\n        rewardRateState?.loading === false &&\n        periodFinishState?.loading === false &&\n        pairTotalSupplyState?.loading === false &&\n        pair &&\n        avaxPngPair &&\n        pairState !== PairState.LOADING &&\n        avaxPngPairState !== PairState.LOADING\n      ) {\n        if (\n          balanceState?.error ||\n          earnedAmountState?.error ||\n          stakingTotalSupplyState.error ||\n          rewardRateState.error ||\n          periodFinishState.error ||\n          pairTotalSupplyState.error ||\n          pairState === PairState.INVALID ||\n          pairState === PairState.NOT_EXISTS ||\n          avaxPngPairState === PairState.INVALID ||\n          avaxPngPairState === PairState.NOT_EXISTS\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        // get the LP token\n        const tokens = info[index].tokens\n        const wavax = tokens[0].equals(WAVAX[tokens[0].chainId]) ? tokens[0] : tokens[1]\n        const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId)\n        // check for account, if no account set to 0\n\n        const periodFinishMs = periodFinishState.result?.[0]?.mul(1000)?.toNumber()\n\n        // periodFinish will be 0 immediately after a reward contract is initialized\n        const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now()\n\n        const totalSupplyStaked = JSBI.BigInt(stakingTotalSupplyState.result?.[0])\n        const totalSupplyAvailable = JSBI.BigInt(pairTotalSupplyState.result?.[0])\n\n        const stakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt(balanceState?.result?.[0] ?? 0))\n        const totalStakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt(totalSupplyStaked))\n        const totalRewardRatePerSecond = new TokenAmount(\n          png,\n          JSBI.BigInt(isPeriodFinished ? 0 : rewardRateState.result?.[0])\n        )\n\n        const totalRewardRatePerWeek = new TokenAmount(\n          png,\n          JSBI.multiply(totalRewardRatePerSecond.raw, BIG_INT_SECONDS_IN_WEEK)\n        )\n\n        const isAvaxPool = tokens[0].equals(WAVAX[tokens[0].chainId])\n        const totalStakedInWavax = isAvaxPool\n          ? calculateTotalStakedAmountInAvax(\n              totalSupplyStaked,\n              totalSupplyAvailable,\n              pair.reserveOf(wavax).raw,\n              chainId\n            )\n          : calculateTotalStakedAmountInAvaxFromPng(\n              totalSupplyStaked,\n              totalSupplyAvailable,\n              avaxPngPair.reserveOf(png).raw,\n              avaxPngPair.reserveOf(WAVAX[tokens[1].chainId]).raw,\n              pair.reserveOf(png).raw,\n              chainId\n            )\n\n        const totalStakedInUsd = totalStakedInWavax && (usdPrice?.quote(totalStakedInWavax, chainId) as TokenAmount)\n\n        const getHypotheticalWeeklyRewardRate = (\n          stakedAmount: TokenAmount,\n          totalStakedAmount: TokenAmount,\n          totalRewardRatePerSecond: TokenAmount\n        ): TokenAmount => {\n          return new TokenAmount(\n            png,\n            JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n              ? JSBI.divide(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), totalStakedAmount.raw)\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const individualRewardRatePerWeek = getHypotheticalWeeklyRewardRate(\n          stakedAmount,\n          totalStakedAmount,\n          totalRewardRatePerSecond\n        )\n\n        const multiplier = info[index].multiplier\n\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished: isPeriodFinished,\n          earnedAmount: new TokenAmount(png, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0)),\n          rewardRatePerWeek: individualRewardRatePerWeek,\n          totalRewardRatePerSecond: totalRewardRatePerSecond,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          totalStakedInWavax: totalStakedInWavax,\n          totalStakedInUsd: totalStakedInUsd,\n          multiplier: JSBI.BigInt(multiplier ?? 0),\n          getHypotheticalWeeklyRewardRate\n        })\n      }\n      return memo\n    }, [])\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    chainId,\n    png,\n    rewardsAddresses,\n    balances,\n    earnedAmounts,\n    stakingTotalSupplies,\n    rewardRates,\n    periodFinishes,\n    pairs,\n    pairTotalSupplies,\n    avaxPngPair,\n    avaxPngPairState,\n    info\n  ])\n}\n\nexport function useSingleSideStakingInfo(\n  version: number,\n  rewardTokenToFilterBy?: Token | null\n): SingleSideStakingInfo[] {\n  const { chainId, library, account } = useActiveWeb3React()\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? SINGLE_SIDE_STAKING_REWARDS_INFO[chainId]?.[version]?.filter(stakingRewardInfo =>\n            rewardTokenToFilterBy === undefined\n              ? true\n              : rewardTokenToFilterBy === null\n              ? false\n              : rewardTokenToFilterBy.equals(stakingRewardInfo.rewardToken)\n          ) ?? []\n        : [],\n    [chainId, rewardTokenToFilterBy, version]\n  )\n\n  const png = PNG[ChainId.AVALANCHE]\n\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n  const routes = useMemo(\n    (): string[][] =>\n      info.map(({ conversionRouteHops, rewardToken }) => {\n        return [png.address, ...conversionRouteHops.map(token => token.address), rewardToken.address]\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }),\n    [info, png]\n  )\n\n  const accountArg = useMemo(() => [account ?? undefined], [account])\n  const getAmountsOutArgs = useMemo(() => {\n    const amountIn = '1' + '0'.repeat(18) // 1 PNG\n    return routes.map(route => [amountIn, route])\n  }, [routes])\n\n  const routerContract = useMemo(() => {\n    if (!chainId || !library) return\n    return getRouterContract(chainId, library)\n  }, [chainId, library])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const stakingTotalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n  const periodFinishes = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const amountsOuts = useSingleContractMultipleData(routerContract, 'getAmountsOut', getAmountsOutArgs, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (!chainId || !png) return []\n\n    return rewardsAddresses.reduce<SingleSideStakingInfo[]>((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index]\n      const earnedAmountState = earnedAmounts[index]\n\n      // these get fetched regardless of account\n      const stakingTotalSupplyState = stakingTotalSupplies[index]\n      const rewardRateState = rewardRates[index]\n      const periodFinishState = periodFinishes[index]\n      const amountsOutsState = amountsOuts[index]\n\n      if (\n        // these may be undefined if not logged in\n        !balanceState?.loading &&\n        !earnedAmountState?.loading &&\n        // always need these\n        stakingTotalSupplyState?.loading === false &&\n        rewardRateState?.loading === false &&\n        periodFinishState?.loading === false &&\n        amountsOutsState?.loading === false\n      ) {\n        if (\n          balanceState?.error ||\n          earnedAmountState?.error ||\n          stakingTotalSupplyState.error ||\n          rewardRateState.error ||\n          periodFinishState.error ||\n          amountsOutsState.error\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        const rewardToken = info[index].rewardToken\n        const valueOfPng = JSBI.BigInt(amountsOutsState.result?.[0]?.slice(-1)?.[0] ?? 0)\n        const periodFinishMs = periodFinishState.result?.[0]?.mul(1000)?.toNumber()\n\n        // periodFinish will be 0 immediately after a reward contract is initialized\n        const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now()\n\n        const totalSupplyStaked = JSBI.BigInt(stakingTotalSupplyState.result?.[0])\n\n        const stakedAmount = new TokenAmount(png, JSBI.BigInt(balanceState?.result?.[0] ?? 0))\n        const totalStakedAmount = new TokenAmount(png, JSBI.BigInt(totalSupplyStaked))\n        const totalRewardRatePerSecond = new TokenAmount(\n          rewardToken,\n          JSBI.BigInt(isPeriodFinished ? 0 : rewardRateState.result?.[0])\n        )\n\n        const totalRewardRatePerWeek = new TokenAmount(\n          png,\n          JSBI.multiply(totalRewardRatePerSecond.raw, BIG_INT_SECONDS_IN_WEEK)\n        )\n\n        const earnedAmount = new TokenAmount(png, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0))\n\n        const rewardRateInPng = calculateRewardRateInPng(totalRewardRatePerSecond.raw, valueOfPng)\n\n        const apr = isPeriodFinished ? JSBI.BigInt(0) : calculateApr(rewardRateInPng, totalSupplyStaked)\n\n        const getHypotheticalWeeklyRewardRate = (\n          stakedAmount: TokenAmount,\n          totalStakedAmount: TokenAmount,\n          totalRewardRatePerSecond: TokenAmount\n        ): TokenAmount => {\n          return new TokenAmount(\n            rewardToken,\n            JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n              ? JSBI.divide(\n                  JSBI.multiply(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK),\n                  totalStakedAmount.raw\n                )\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const individualWeeklyRewardRate = getHypotheticalWeeklyRewardRate(\n          stakedAmount,\n          totalStakedAmount,\n          totalRewardRatePerSecond\n        )\n\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          rewardToken: rewardToken,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished: isPeriodFinished,\n          earnedAmount: earnedAmount,\n          rewardRatePerWeek: individualWeeklyRewardRate,\n          totalRewardRatePerSecond: totalRewardRatePerSecond,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          totalStakedInPng: totalStakedAmount,\n          getHypotheticalWeeklyRewardRate,\n          apr: apr\n        })\n      }\n      return memo\n    }, [])\n  }, [\n    chainId,\n    png,\n    rewardsAddresses,\n    balances,\n    earnedAmounts,\n    stakingTotalSupplies,\n    rewardRates,\n    periodFinishes,\n    amountsOuts,\n    info\n  ])\n}\n\nexport function useTotalPngEarned(): TokenAmount | undefined {\n  const chainId = useChainId()\n\n  const png = PNG[chainId]\n  const stakingInfo0 = useStakingInfo(0)\n  const stakingInfo1 = useStakingInfo(1)\n  const stakingInfo2 = useMinichefStakingInfos(2)\n\n  const earned0 = useMemo(() => {\n    if (!png) new TokenAmount(png, '0')\n    return (\n      stakingInfo0?.reduce(\n        (accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount),\n        new TokenAmount(png, '0')\n      ) ?? new TokenAmount(png, '0')\n    )\n  }, [stakingInfo0, png])\n\n  const earned1 = useMemo(() => {\n    if (!png) new TokenAmount(png, '0')\n    return (\n      stakingInfo1?.reduce(\n        (accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount),\n        new TokenAmount(png, '0')\n      ) ?? new TokenAmount(png, '0')\n    )\n  }, [stakingInfo1, png])\n\n  const earned2 = useMemo(() => {\n    if (!png) new TokenAmount(png, '0')\n    return (\n      stakingInfo2?.reduce(\n        (accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount),\n        new TokenAmount(png, '0')\n      ) ?? new TokenAmount(png, '0')\n    )\n  }, [stakingInfo2, png])\n\n  return earned0.add(earned1).add(earned2)\n  // return earned0 ? (earned1 ? earned0.add(earned1) : earned0) : earned1 ? earned1 : undefined\n}\n\n// based on typed value\nexport function useDerivedStakeInfo(\n  typedValue: string,\n  stakingToken: Token,\n  userLiquidityUnstaked: TokenAmount | undefined\n): {\n  parsedAmount?: CurrencyAmount\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const { t } = useTranslation()\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(chainId, typedValue, stakingToken)\n\n  const parsedAmount =\n    parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined\n\n  let error: string | undefined\n  if (!account) {\n    error = t('stakeHooks.connectWallet')\n  }\n  if (!parsedAmount) {\n    error = error ?? t('stakeHooks.enterAmount')\n  }\n\n  return {\n    parsedAmount,\n    error\n  }\n}\n\n// based on typed value\nexport function useDerivedUnstakeInfo(\n  typedValue: string,\n  stakingAmount: TokenAmount\n): {\n  parsedAmount?: CurrencyAmount\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const { t } = useTranslation()\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(chainId, typedValue, stakingAmount.token)\n\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined\n\n  let error: string | undefined\n  if (!account) {\n    error = t('stakeHooks.connectWallet')\n  }\n  if (!parsedAmount) {\n    error = error ?? t('stakeHooks.enterAmount')\n  }\n\n  return {\n    parsedAmount,\n    error\n  }\n}\n\nexport function useGetStakingDataWithAPR(version: number) {\n  const stakingInfos = useStakingInfo(version)\n  const [stakingInfoData, setStakingInfoData] = useState<StakingInfo[]>(stakingInfos)\n\n  useEffect(() => {\n    if (stakingInfos?.length > 0) {\n      Promise.all(\n        stakingInfos.map(stakingInfo => {\n          const APR_URL =\n            version < 2\n              ? `${PANGOLIN_API_BASE_URL}/pangolin/apr/${stakingInfo.stakingRewardAddress}`\n              : `${PANGOLIN_API_BASE_URL}/pangolin/apr2/${stakingInfo.stakingRewardAddress}`\n          return fetch(APR_URL)\n            .then(res => res.json())\n            .then(res => ({\n              swapFeeApr: Number(res.swapFeeApr),\n              stakingApr: Number(res.stakingApr),\n              combinedApr: Number(res.combinedApr),\n              ...stakingInfo\n            }))\n        })\n      ).then(updatedStakingInfos => {\n        setStakingInfoData(updatedStakingInfos)\n      })\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [stakingInfos?.length, version])\n\n  return stakingInfoData\n}\n\nexport function useGetPairDataFromPair(pair: Pair) {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const dummyToken = new Token(chainId, ZERO_ADDRESS, 18, 'PNG', 'Pangolin')\n\n  const token0 = pair?.token0 || dummyToken\n  const token1 = pair?.token1 || dummyToken\n\n  const usdPriceCurrency0Tmp = useUSDCPrice(token0)\n  const usdPriceCurrency0 = CHAINS[chainId].is_mainnet ? usdPriceCurrency0Tmp : undefined\n  const usdPriceCurrency1Tmp = useUSDCPrice(token1)\n  const usdPriceCurrency1 = CHAINS[chainId].is_mainnet ? usdPriceCurrency1Tmp : undefined\n\n  const zeroTokenAmount0 = new TokenAmount(token0, '0')\n  const zeroTokenAmount1 = new TokenAmount(token1, '0')\n\n  const userPoolBalance = useTokenBalance(account ?? undefined, pair.liquidityToken)\n  const totalPoolTokens = useTotalSupply(pair.liquidityToken)\n\n  const getHypotheticalPoolOwnership = (userBalance: JSBI | undefined, poolTotalBalance: JSBI | undefined): Percent => {\n    if (!userBalance || !poolTotalBalance || JSBI.equal(poolTotalBalance, BIG_INT_ZERO)) {\n      return new Percent(BIG_INT_ZERO, BIG_INT_ONE)\n    }\n    return new Percent(userBalance, poolTotalBalance).multiply('100')\n  }\n\n  const poolTokenPercentage =\n    !!userPoolBalance && !!totalPoolTokens && JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)\n      ? new Percent(userPoolBalance.raw, totalPoolTokens.raw)\n      : undefined\n\n  const [token0Deposited, token1Deposited] =\n    !!pair &&\n    !!totalPoolTokens &&\n    !!userPoolBalance &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)\n      ? [\n          pair.getLiquidityValue(pair.token0, totalPoolTokens, userPoolBalance, false),\n          pair.getLiquidityValue(pair.token1, totalPoolTokens, userPoolBalance, false)\n        ]\n      : [zeroTokenAmount0, zeroTokenAmount1]\n\n  const usdAmountCurrency0: CurrencyAmount = usdPriceCurrency0?.quote(token0Deposited, chainId) ?? zeroTokenAmount0\n  const usdAmountCurrency1: CurrencyAmount = usdPriceCurrency1?.quote(token1Deposited, chainId) ?? zeroTokenAmount1\n\n  const totalAmountUsd: CurrencyAmount = usdAmountCurrency0?.add(usdAmountCurrency1)\n\n  return {\n    currency0: pair.token0,\n    currency1: pair.token1,\n    userPoolBalance: userPoolBalance,\n    totalPoolTokens: totalPoolTokens,\n    token0Deposited: token0Deposited,\n    token1Deposited: token1Deposited,\n    totalAmountUsd: totalAmountUsd,\n    poolTokenPercentage: poolTokenPercentage,\n    getHypotheticalPoolOwnership\n  }\n}\nexport const useMinichefPools = (): { [key: string]: number } => {\n  const chainId = useChainId()\n  const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId])\n  const lpTokens = useSingleCallResult(minichefContract, 'lpTokens', []).result\n  const lpTokensArr = lpTokens?.[0]\n\n  return useMemo(() => {\n    const poolMap: { [key: string]: number } = {}\n    if (lpTokensArr) {\n      lpTokensArr.forEach((address: string, index: number) => {\n        poolMap[address] = index\n      })\n    }\n    return poolMap\n  }, [lpTokensArr])\n}\n\nexport const useMinichefStakingInfos = (version = 2, pairToFilterBy?: Pair | null): DoubleSideStakingInfo[] => {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId])\n  const poolMap = useMinichefPools()\n  const png = PNG[chainId]\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? DOUBLE_SIDE_STAKING_REWARDS_INFO[chainId]?.[version]?.filter(item =>\n            pairToFilterBy === undefined\n              ? true\n              : pairToFilterBy === null\n              ? false\n              : pairToFilterBy.involvesToken(item.tokens[0]) && pairToFilterBy.involvesToken(item.tokens[1])\n          ) ?? []\n        : [],\n    [chainId, pairToFilterBy, version]\n  )\n\n  const tokens = useMemo(() => info.map(({ tokens }) => tokens), [info])\n  const pairs = usePairs(tokens)\n\n  // @dev: If no farms load, you likely loaded an incorrect config from doubleSideConfig.js\n  // Enable this and look for an invalid pair\n  // console.log(pairs)\n\n  const pairAddresses = useMemo(() => {\n    return pairs.map(([, pair]) => pair?.liquidityToken.address)\n  }, [pairs])\n\n  const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply')\n  const balances = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'balanceOf', [\n    MINICHEF_ADDRESS[chainId]\n  ])\n\n  const [avaxPngPairState, avaxPngPair] = usePair(WAVAX[chainId], png)\n\n  const poolIdArray = useMemo(() => {\n    if (!pairAddresses || !poolMap) return []\n    // TODO: clean up this logic. seems like a lot of work to ensure correct types\n    const NOT_FOUND = -1\n    const results = pairAddresses.map(address => poolMap[address ?? ''] ?? NOT_FOUND)\n    if (results.some(result => result === NOT_FOUND)) return []\n    return results\n  }, [poolMap, pairAddresses])\n\n  const poolsIdInput = useMemo(() => {\n    if (!poolIdArray) return []\n    return poolIdArray.map(pid => [pid])\n  }, [poolIdArray])\n\n  const poolInfos = useSingleContractMultipleData(minichefContract, 'poolInfo', poolsIdInput ?? [])\n\n  const rewarders = useSingleContractMultipleData(minichefContract, 'rewarder', poolsIdInput ?? [])\n\n  const userInfoInput = useMemo(() => {\n    if (!poolIdArray || !account) return []\n    return poolIdArray.map(pid => [pid, account])\n  }, [poolIdArray, account])\n  const userInfos = useSingleContractMultipleData(minichefContract, 'userInfo', userInfoInput ?? [])\n\n  const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput ?? [])\n\n  const rewardsAddresses = useMemo(() => {\n    if ((rewarders || []).length === 0) return []\n    if (rewarders.some(item => item.loading)) return []\n    return rewarders.map(reward => reward?.result?.[0])\n  }, [rewarders])\n\n  const rewardTokensAddresses = useMultipleContractSingleData(\n    rewardsAddresses,\n    REWARDER_VIA_MULTIPLIER_INTERFACE,\n    'getRewardTokens',\n    []\n  )\n\n  const rewardTokensMultipliers = useMultipleContractSingleData(\n    rewardsAddresses,\n    REWARDER_VIA_MULTIPLIER_INTERFACE,\n    'getRewardMultipliers',\n    []\n  )\n\n  const rewardPerSecond = useSingleCallResult(minichefContract, 'rewardPerSecond', []).result\n  const totalAllocPoint = useSingleCallResult(minichefContract, 'totalAllocPoint', []).result\n  const rewardsExpiration = useSingleCallResult(minichefContract, 'rewardsExpiration', []).result\n  const usdPriceTmp = useUSDCPrice(WAVAX[chainId])\n  const usdPrice = CHAINS[chainId].is_mainnet ? usdPriceTmp : undefined\n\n  const arr = useMemo(() => {\n    if (!chainId || !png) return []\n\n    return pairAddresses.reduce<any[]>((memo, pairAddress, index) => {\n      const pairTotalSupplyState = pairTotalSupplies[index]\n      const balanceState = balances[index]\n      const poolInfo = poolInfos[index]\n      const userPoolInfo = userInfos[index]\n      const [pairState, pair] = pairs[index]\n      const pendingRewardInfo = pendingRewards[index]\n      const rewardTokensAddress = rewardTokensAddresses[index]\n      const rewardTokensMultiplier = rewardTokensMultipliers[index]\n      const rewardsAddress = rewardsAddresses[index]\n\n      if (\n        pairTotalSupplyState?.loading === false &&\n        poolInfo?.loading === false &&\n        balanceState?.loading === false &&\n        pair &&\n        avaxPngPair &&\n        pairState !== PairState.LOADING &&\n        avaxPngPairState !== PairState.LOADING &&\n        rewardPerSecond &&\n        totalAllocPoint &&\n        rewardsExpiration?.[0] &&\n        rewardTokensAddress?.loading === false\n      ) {\n        if (\n          balanceState?.error ||\n          pairTotalSupplyState.error ||\n          pairState === PairState.INVALID ||\n          pairState === PairState.NOT_EXISTS ||\n          avaxPngPairState === PairState.INVALID ||\n          avaxPngPairState === PairState.NOT_EXISTS\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        // get the LP token\n        const token0 = pair?.token0\n        const token1 = pair?.token1\n\n        const tokens = [token0, token1].sort(({ address: addressA }, { address: addressB }) => {\n          // Sort AVAX last\n          if (addressA === WAVAX[ChainId.AVALANCHE].address) return 1\n          else if (addressB === WAVAX[ChainId.AVALANCHE].address) return -1\n          // Sort PNG first\n          else if (addressA === PNG[ChainId.AVALANCHE].address) return -1\n          else if (addressB === PNG[ChainId.AVALANCHE].address) return 1\n          // Sort axlUST first\n          else if (addressA === axlUST[ChainId.AVALANCHE].address) return -1\n          else if (addressB === axlUST[ChainId.AVALANCHE].address) return 1\n          // Sort USDC first\n          else if (addressA === USDC[ChainId.AVALANCHE].address) return -1\n          else if (addressB === USDC[ChainId.AVALANCHE].address) return 1\n          // Sort USDCe first\n          else if (addressA === USDCe[ChainId.AVALANCHE].address) return -1\n          else if (addressB === USDCe[ChainId.AVALANCHE].address) return 1\n          else return 0\n        })\n\n        const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId)\n        const lpToken = dummyPair.liquidityToken\n\n        const poolAllocPointAmount = new TokenAmount(lpToken, JSBI.BigInt(poolInfo?.result?.['allocPoint']))\n        const totalAllocPointAmount = new TokenAmount(lpToken, JSBI.BigInt(totalAllocPoint?.[0]))\n        const rewardRatePerSecAmount = new TokenAmount(png, JSBI.BigInt(rewardPerSecond?.[0]))\n        const poolRewardRate = new TokenAmount(\n          png,\n          JSBI.divide(JSBI.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw)\n        )\n\n        const totalRewardRatePerWeek = new TokenAmount(png, JSBI.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK))\n\n        const periodFinishMs = rewardsExpiration?.[0]?.mul(1000)?.toNumber()\n        // periodFinish will be 0 immediately after a reward contract is initialized\n        const isPeriodFinished =\n          periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0')\n\n        const totalSupplyStaked = JSBI.BigInt(balanceState?.result?.[0])\n        const totalSupplyAvailable = JSBI.BigInt(pairTotalSupplyState?.result?.[0])\n        const totalStakedAmount = new TokenAmount(lpToken, JSBI.BigInt(balanceState?.result?.[0]))\n        const stakedAmount = new TokenAmount(lpToken, JSBI.BigInt(userPoolInfo?.result?.['amount'] ?? 0))\n        const earnedAmount = new TokenAmount(png, JSBI.BigInt(pendingRewardInfo?.result?.['pending'] ?? 0))\n        const multiplier = JSBI.BigInt(poolInfo?.result?.['allocPoint'])\n\n        const isAvaxPool = pair.involvesToken(WAVAX[chainId])\n        const isPngPool = pair.involvesToken(PNG[chainId])\n\n        let totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n          ? new TokenAmount(DAIe[chainId], BIG_INT_ZERO)\n          : undefined\n        const totalStakedInWavax = new TokenAmount(WAVAX[chainId], BIG_INT_ZERO)\n\n        if (JSBI.equal(totalSupplyAvailable, BIG_INT_ZERO)) {\n          // Default to 0 values above avoiding division by zero errors\n        } else if (pair.involvesToken(DAIe[chainId])) {\n          const pairValueInDAI = JSBI.multiply(pair.reserveOf(DAIe[chainId]).raw, BIG_INT_TWO)\n          const stakedValueInDAI = JSBI.divide(JSBI.multiply(pairValueInDAI, totalSupplyStaked), totalSupplyAvailable)\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? new TokenAmount(DAIe[chainId], stakedValueInDAI)\n            : undefined\n        } else if (pair.involvesToken(USDCe[chainId])) {\n          const pairValueInUSDC = JSBI.multiply(pair.reserveOf(USDCe[chainId]).raw, BIG_INT_TWO)\n          const stakedValueInUSDC = JSBI.divide(JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable)\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? new TokenAmount(USDCe[chainId], stakedValueInUSDC)\n            : undefined\n        } else if (pair.involvesToken(USDC[chainId])) {\n          const pairValueInUSDC = JSBI.multiply(pair.reserveOf(USDC[chainId]).raw, BIG_INT_TWO)\n          const stakedValueInUSDC = JSBI.divide(JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable)\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? new TokenAmount(USDC[chainId], stakedValueInUSDC)\n            : undefined\n        } else if (pair.involvesToken(axlUST[chainId])) {\n          const pairValueInUST = JSBI.multiply(pair.reserveOf(axlUST[chainId]).raw, BIG_INT_TWO)\n          const stakedValueInUST = JSBI.divide(JSBI.multiply(pairValueInUST, totalSupplyStaked), totalSupplyAvailable)\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? new TokenAmount(axlUST[chainId], stakedValueInUST)\n            : undefined\n        } else if (pair.involvesToken(USDTe[chainId])) {\n          const pairValueInUSDT = JSBI.multiply(pair.reserveOf(USDTe[chainId]).raw, BIG_INT_TWO)\n          const stakedValueInUSDT = JSBI.divide(JSBI.multiply(pairValueInUSDT, totalSupplyStaked), totalSupplyAvailable)\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? new TokenAmount(USDTe[chainId], stakedValueInUSDT)\n            : undefined\n        } else if (isAvaxPool) {\n          const totalStakedInWavax = calculateTotalStakedAmountInAvax(\n            totalSupplyStaked,\n            totalSupplyAvailable,\n            pair.reserveOf(WAVAX[chainId]).raw,\n            chainId\n          )\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? totalStakedInWavax && (usdPrice?.quote(totalStakedInWavax, chainId) as TokenAmount)\n            : undefined\n        } else if (isPngPool) {\n          const totalStakedInWavax = calculateTotalStakedAmountInAvaxFromPng(\n            totalSupplyStaked,\n            totalSupplyAvailable,\n            avaxPngPair.reserveOf(png).raw,\n            avaxPngPair.reserveOf(WAVAX[chainId]).raw,\n            pair.reserveOf(png).raw,\n            chainId\n          )\n          totalStakedInUsd = CHAINS[chainId || ChainId].is_mainnet\n            ? totalStakedInWavax && (usdPrice?.quote(totalStakedInWavax, chainId) as TokenAmount)\n            : undefined\n        } else {\n          // Contains no stablecoin, WAVAX, nor PNG\n          console.error(`Could not identify total staked value for pair ${pair.liquidityToken.address}`)\n        }\n\n        const getHypotheticalWeeklyRewardRate = (\n          stakedAmount: TokenAmount,\n          totalStakedAmount: TokenAmount,\n          totalRewardRatePerSecond: TokenAmount\n        ): TokenAmount => {\n          return new TokenAmount(\n            png,\n            JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n              ? JSBI.divide(\n                  JSBI.multiply(JSBI.multiply(totalRewardRatePerSecond.raw, stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK),\n                  totalStakedAmount.raw\n                )\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const getExtraTokensWeeklyRewardRate = (\n          rewardRatePerWeek: TokenAmount,\n          token: Token,\n          tokenMultiplier: JSBI | undefined\n        ) => {\n          const TEN_EIGHTEEN = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(18))\n          // const secondToWeekConversion = JSBI.BigInt(60 * 60 * 24 * 7)\n          const rewardMultiplier = JSBI.BigInt(tokenMultiplier || 1)\n\n          const unadjustedRewardPerWeek = JSBI.multiply(rewardMultiplier, rewardRatePerWeek?.raw)\n\n          // const finalReward = JSBI.divide(JSBI.multiply(unadjustedRewardPerWeek, secondToWeekConversion), TEN_EIGHTEEN)\n          const finalReward = JSBI.divide(unadjustedRewardPerWeek, TEN_EIGHTEEN)\n\n          return new TokenAmount(token, finalReward)\n        }\n\n        const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate)\n\n        memo.push({\n          stakingRewardAddress: MINICHEF_ADDRESS[chainId],\n          tokens,\n          earnedAmount,\n          rewardRatePerWeek: userRewardRatePerWeek,\n          totalRewardRatePerSecond: poolRewardRate,\n          totalRewardRatePerWeek: totalRewardRatePerWeek,\n          stakedAmount,\n          totalStakedAmount,\n          totalStakedInWavax,\n          totalStakedInUsd,\n          multiplier: JSBI.divide(multiplier, JSBI.BigInt(100)),\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          isPeriodFinished,\n          getHypotheticalWeeklyRewardRate,\n          getExtraTokensWeeklyRewardRate,\n          rewardTokensAddress: rewardTokensAddress?.result?.[0],\n          rewardTokensMultiplier: rewardTokensMultiplier?.result?.[0],\n          rewardsAddress\n        })\n      }\n\n      return memo\n    }, [])\n  }, [\n    chainId,\n    png,\n    pairTotalSupplies,\n    poolInfos,\n    userInfos,\n    pairs,\n    avaxPngPair,\n    avaxPngPairState,\n    rewardPerSecond,\n    totalAllocPoint,\n    pendingRewards,\n    rewardsExpiration,\n    balances,\n    usdPrice,\n    pairAddresses,\n    rewardTokensAddresses,\n    rewardsAddresses,\n    rewardTokensMultipliers\n  ])\n\n  return arr\n}\n\nexport function useGetPoolDollerWorth(pair: Pair | null) {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const token0 = pair?.token0\n  const currency0 = unwrappedToken(token0 as Token, chainId)\n  const currency0PriceTmp = useUSDCPrice(currency0)\n  const currency0Price = CHAINS[chainId].is_mainnet ? currency0PriceTmp : undefined\n\n  const userPglTmp = useTokenBalance(account ?? undefined, pair?.liquidityToken)\n  const userPgl = CHAINS[chainId].is_mainnet ? userPglTmp : undefined\n\n  const totalPoolTokens = useTotalSupply(pair?.liquidityToken)\n\n  const [token0Deposited] =\n    !!pair &&\n    !!totalPoolTokens &&\n    !!userPgl &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPgl.raw)\n      ? [\n          pair.getLiquidityValue(pair.token0, totalPoolTokens, userPgl, false),\n          pair.getLiquidityValue(pair.token1, totalPoolTokens, userPgl, false)\n        ]\n      : [undefined, undefined]\n\n  const liquidityInUSD = CHAINS[chainId].is_mainnet\n    ? currency0Price && token0Deposited\n      ? Number(currency0Price.toFixed()) * 2 * Number(token0Deposited?.toSignificant(6))\n      : 0\n    : 0\n  //\n  return useMemo(\n    () => ({\n      userPgl,\n      liquidityInUSD\n    }),\n    [userPgl, liquidityInUSD]\n  )\n}\n\nexport function useMinichefPendingRewards(miniChefStaking: DoubleSideStakingInfo | null) {\n  const { account } = useActiveWeb3React()\n\n  const rewardAddress = miniChefStaking?.rewardsAddress\n\n  const rewardContract = useRewardViaMultiplierContract(rewardAddress !== ZERO_ADDRESS ? rewardAddress : undefined)\n\n  const earnedAmount = miniChefStaking?.earnedAmount\n    ? JSBI.BigInt(miniChefStaking?.earnedAmount?.raw).toString()\n    : JSBI.BigInt(0).toString()\n\n  const rewardTokenAmounts = useSingleContractMultipleData(\n    rewardContract,\n    'pendingTokens',\n    account ? [[0, account as string, earnedAmount]] : []\n  )\n  const rewardTokens = useTokens(miniChefStaking?.rewardTokensAddress)\n  const rewardAmounts = rewardTokenAmounts?.[0]?.result?.amounts || [] // eslint-disable-line react-hooks/exhaustive-deps\n\n  const rewardTokensAmount = useMemo(() => {\n    if (!rewardTokens) return []\n    return rewardTokens.map((rewardToken, index) => new TokenAmount(rewardToken as Token, rewardAmounts[index] || 0))\n  }, [rewardAmounts, rewardTokens])\n\n  return useMemo(\n    () => ({\n      rewardTokensAmount\n    }),\n    [rewardTokensAmount]\n  )\n}\n\nexport function useDerivedStakingProcess(stakingInfo: SingleSideStakingInfo) {\n  const { account, library } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const { t } = useTranslation()\n  const png = PNG[chainId]\n\n  const usdcPrice = useUSDCPrice(png)\n\n  // detect existing unstaked position to show purchase button if none found\n  const userPngUnstaked = useTokenBalance(account ?? undefined, stakingInfo?.stakedAmount?.token)\n\n  const stakeToken = stakingInfo?.stakedAmount?.token?.symbol\n\n  const [stepIndex, setStepIndex] = useState(4)\n\n  // track and parse user input\n  const [typedValue, setTypedValue] = useState((userPngUnstaked as TokenAmount)?.toExact() || '')\n  const { parsedAmount, error } = useDerivedStakeInfo(typedValue, stakingInfo.stakedAmount.token, userPngUnstaked)\n  const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId)\n\n  let hypotheticalRewardRatePerWeek: TokenAmount = new TokenAmount(stakingInfo.rewardRatePerWeek.token, '0')\n  if (parsedAmountWrapped?.greaterThan('0')) {\n    hypotheticalRewardRatePerWeek = stakingInfo.getHypotheticalWeeklyRewardRate(\n      stakingInfo.stakedAmount.add(parsedAmountWrapped),\n      stakingInfo.totalStakedAmount.add(parsedAmountWrapped),\n      stakingInfo.totalRewardRatePerSecond\n    )\n  }\n\n  const dollerWorth =\n    userPngUnstaked?.greaterThan('0') && usdcPrice ? Number(typedValue) * Number(usdcPrice.toFixed()) : undefined\n\n  // state for pending and submitted txn views\n  const addTransaction = useTransactionAdder()\n  const [attempting, setAttempting] = useState<boolean>(false)\n  const [hash, setHash] = useState<string | undefined>()\n  const wrappedOnDismiss = useCallback(() => {\n    setSignatureData(null)\n    setTypedValue('0')\n    setStepIndex(0)\n    setHash(undefined)\n    setAttempting(false)\n    // onClose && onClose()\n  }, [])\n\n  const stakingTokenContract = usePngContract()\n\n  // approval data for stake\n  const deadline = useTransactionDeadline()\n  const [signatureData, setSignatureData] = useState<{ v: number; r: string; s: string; deadline: number } | null>(null)\n  const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo.stakingRewardAddress)\n\n  const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress)\n\n  async function onStake() {\n    setAttempting(true)\n    if (stakingContract && parsedAmount && deadline) {\n      if (approval === ApprovalState.APPROVED) {\n        stakingContract\n          .stake(`0x${parsedAmount.raw.toString(16)}`)\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: t('earnPage.stakeStakingTokens', { symbol: 'PNG' })\n            })\n            setHash(response.hash)\n          })\n          .catch((error: any) => {\n            setAttempting(false)\n            // we only care if the error is something _other_ than the user rejected the tx\n            if (error?.code !== 4001) {\n              console.error(error)\n            }\n          })\n      } else if (signatureData) {\n        stakingContract\n          .stakeWithPermit(\n            `0x${parsedAmount.raw.toString(16)}`,\n            signatureData.deadline,\n            signatureData.v,\n            signatureData.r,\n            signatureData.s\n          )\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: t('earnPage.stakeStakingTokens', { symbol: 'PNG' })\n            })\n            setHash(response.hash)\n          })\n          .catch((error: any) => {\n            setAttempting(false)\n            // we only care if the error is something _other_ than the user rejected the tx\n            if (error?.code !== 4001) {\n              console.error(error)\n            }\n          })\n      } else {\n        setAttempting(false)\n        throw new Error(t('earn.attemptingToStakeError'))\n      }\n    }\n  }\n\n  const onChangePercentage = (value: number) => {\n    // setStepIndex(value)\n    if (!userPngUnstaked) {\n      setTypedValue('0')\n      return\n    }\n    if (value === 100) {\n      setTypedValue((userPngUnstaked as TokenAmount).toExact())\n    } else if (value === 0) {\n      setTypedValue('0')\n    } else {\n      const newAmount = (userPngUnstaked as TokenAmount)\n        .multiply(JSBI.BigInt(value))\n        .divide(JSBI.BigInt(100)) as TokenAmount\n\n      setTypedValue(newAmount.toSignificant(6))\n    }\n  }\n\n  // wrapped onUserInput to clear signatures\n  const onUserInput = useCallback((typedValue: string) => {\n    setSignatureData(null)\n    setTypedValue(typedValue)\n  }, [])\n\n  // used for max input button\n  const maxAmountInput = maxAmountSpend(chainId, userPngUnstaked)\n  // const atMaxAmount = Boolean(maxAmountInput && parsedAmount?.equalTo(maxAmountInput))\n  const handleMax = useCallback(() => {\n    maxAmountInput && onUserInput(maxAmountInput.toExact())\n    setStepIndex(4)\n  }, [maxAmountInput, onUserInput])\n\n  async function onAttemptToApprove() {\n    if (!stakingTokenContract || !library || !deadline) throw new Error(t('earn.missingDependencies'))\n    const liquidityAmount = parsedAmount\n    if (!liquidityAmount) throw new Error(t('earn.missingLiquidityAmount'))\n\n    // try to gather a signature for permission\n    const nonce = await stakingTokenContract.nonces(account)\n\n    const EIP712Domain = [\n      { name: 'name', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'verifyingContract', type: 'address' }\n    ]\n    const domain = {\n      name: 'Pangolin',\n      chainId: chainId,\n      verifyingContract: stakingTokenContract.address\n    }\n    const Permit = [\n      { name: 'owner', type: 'address' },\n      { name: 'spender', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' }\n    ]\n    const message = {\n      owner: account,\n      spender: stakingInfo.stakingRewardAddress,\n      value: liquidityAmount.raw.toString(),\n      nonce: nonce.toHexString(),\n      deadline: deadline.toNumber()\n    }\n    const data = JSON.stringify({\n      types: {\n        EIP712Domain,\n        Permit\n      },\n      domain,\n      primaryType: 'Permit',\n      message\n    })\n\n    library\n      .send('eth_signTypedData_v4', [account, data])\n      .then(splitSignature)\n      .then(signature => {\n        setSignatureData({\n          v: signature.v,\n          r: signature.r,\n          s: signature.s,\n          deadline: deadline.toNumber()\n        })\n      })\n      .catch(error => {\n        // for all errors other than 4001 (EIP-1193 user rejected request), fall back to manual approve\n        if (error?.code !== 4001) {\n          approveCallback()\n        }\n      })\n  }\n\n  return useMemo(\n    () => ({\n      attempting,\n      stakeToken,\n      parsedAmount,\n      hash,\n      userPngUnstaked,\n      stepIndex,\n      dollerWorth,\n      hypotheticalRewardRatePerWeek,\n      signatureData,\n      error,\n      approval,\n      account,\n      png,\n      onAttemptToApprove,\n      onUserInput,\n      wrappedOnDismiss,\n      handleMax,\n      onStake,\n      onChangePercentage,\n      setStepIndex\n    }),\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      attempting,\n      stakeToken,\n      parsedAmount,\n      hash,\n      userPngUnstaked,\n      stepIndex,\n      dollerWorth,\n      hypotheticalRewardRatePerWeek,\n      signatureData,\n      error,\n      approval,\n      account,\n      png,\n      onUserInput,\n      handleMax\n    ]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}