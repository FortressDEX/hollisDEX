{"ast":null,"code":"import { CurrencyAmount, CAVAX, InsufficientInputAmountError, JSBI, Percent, Price } from '@pangolindex/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nimport { useTranslation } from 'react-i18next';\nimport { useChainId } from 'src/hooks';\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  return useSelector(state => state.mint);\n}\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const {\n    t\n  } = useTranslation();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // error handling\n\n  let insufficientInput = false; // tokens\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]); // pair\n\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO)); // balances\n\n  const balances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // amounts\n\n  const independentAmount = tryParseAmount(chainId, typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(chainId, otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair && chainId) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount, chainId) : pair.priceOf(tokenB).quote(wrappedIndependentAmount, chainId);\n        return dependentCurrency === CAVAX[chainId] ? CurrencyAmount.ether(dependentTokenAmount.raw, chainId) : dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair]); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  const parsedAmounts = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  };\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n\n      return undefined;\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [wrappedCurrencyAmount(currencyAAmount, chainId), wrappedCurrencyAmount(currencyBAmount, chainId)];\n    insufficientInput = false; // eslint-disable-line react-hooks/exhaustive-deps\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n      } catch (err) {\n        if (err instanceof InsufficientInputAmountError) {\n          insufficientInput = true;\n          return undefined;\n        } else {\n          throw err;\n        }\n      }\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n\n  if (!account) {\n    error = t('mintHooks.connectWallet');\n  }\n\n  if (insufficientInput) {\n    error = t('mintHooks.insufficientInputAmount');\n  }\n\n  if (pairState === PairState.INVALID) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : t('mintHooks.invalidPair');\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : t('mintHooks.enterAmount');\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n\n    error = t('mintHooks.insufficient') + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + t('mintHooks.balance');\n  }\n\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n\n    error = t('mintHooks.insufficient') + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + t('mintHooks.balance');\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}\nexport function useMintActionHandlers(noLiquidity) {\n  const dispatch = useDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/mint/hooks.ts"],"names":["CurrencyAmount","CAVAX","InsufficientInputAmountError","JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","wrappedCurrency","wrappedCurrencyAmount","tryParseAmount","useCurrencyBalances","Field","typeInput","useTranslation","useChainId","ZERO","BigInt","useMintState","state","mint","useDerivedMintInfo","currencyA","currencyB","account","chainId","t","independentField","typedValue","otherTypedValue","dependentField","CURRENCY_A","CURRENCY_B","insufficientInput","currencies","undefined","pairState","pair","totalSupply","liquidityToken","noLiquidity","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","ether","parsedAmounts","price","currencyAAmount","currencyBAmount","currency","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","err","poolTokenPercentage","add","error","INVALID","lessThan","symbol","useMintActionHandlers","dispatch","onFieldAInput","field","onFieldBInput"],"mappings":"AAAA,SAEEA,cAFF,EAGEC,KAHF,EAIEC,4BAJF,EAKEC,IALF,EAOEC,OAPF,EAQEC,KARF,QAUO,kBAVP;AAWA,SAASC,WAAT,EAAsBC,OAAtB,QAAqC,OAArC;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,aAAzC;AACA,SAASC,SAAT,EAAoBC,OAApB,QAAmC,qBAAnC;AACA,SAASC,cAAT,QAA+B,wBAA/B;AAEA,SAASC,kBAAT,QAAmC,aAAnC;AACA,SAASC,eAAT,EAA0BC,qBAA1B,QAAuD,6BAAvD;AAEA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,mBAAT,QAAoC,iBAApC;AACA,SAASC,KAAT,EAAgBC,SAAhB,QAAiC,WAAjC;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,UAAT,QAA2B,WAA3B;AAEA,MAAMC,IAAI,GAAGnB,IAAI,CAACoB,MAAL,CAAY,CAAZ,CAAb;AAEA,OAAO,SAASC,YAAT,GAA0C;AAC/C,SAAOf,WAAW,CAA6BgB,KAAK,IAAIA,KAAK,CAACC,IAA5C,CAAlB;AACD;AAED,OAAO,SAASC,kBAAT,CACLC,SADK,EAELC,SAFK,EAeL;AAAA;;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAcjB,kBAAkB,EAAtC;AACA,QAAMkB,OAAO,GAAGV,UAAU,EAA1B;AAEA,QAAM;AAAEW,IAAAA;AAAF,MAAQZ,cAAc,EAA5B;AAEA,QAAM;AAAEa,IAAAA,gBAAF;AAAoBC,IAAAA,UAApB;AAAgCC,IAAAA;AAAhC,MAAoDX,YAAY,EAAtE;AAEA,QAAMY,cAAc,GAAGH,gBAAgB,KAAKf,KAAK,CAACmB,UAA3B,GAAwCnB,KAAK,CAACoB,UAA9C,GAA2DpB,KAAK,CAACmB,UAAxF,CARA,CAUA;;AACA,MAAIE,iBAAiB,GAAG,KAAxB,CAXA,CAaA;;AACA,QAAMC,UAA2C,GAAGjC,OAAO,CACzD,OAAO;AACL,KAACW,KAAK,CAACmB,UAAP,GAAoBT,SAApB,aAAoBA,SAApB,cAAoBA,SAApB,GAAiCa,SAD5B;AAEL,KAACvB,KAAK,CAACoB,UAAP,GAAoBT,SAApB,aAAoBA,SAApB,cAAoBA,SAApB,GAAiCY;AAF5B,GAAP,CADyD,EAKzD,CAACb,SAAD,EAAYC,SAAZ,CALyD,CAA3D,CAdA,CAsBA;;AACA,QAAM,CAACa,SAAD,EAAYC,IAAZ,IAAoBhC,OAAO,CAAC6B,UAAU,CAACtB,KAAK,CAACmB,UAAP,CAAX,EAA+BG,UAAU,CAACtB,KAAK,CAACoB,UAAP,CAAzC,CAAjC;AACA,QAAMM,WAAW,GAAGhC,cAAc,CAAC+B,IAAD,aAACA,IAAD,uBAACA,IAAI,CAAEE,cAAP,CAAlC;AAEA,QAAMC,WAAoB,GACxBJ,SAAS,KAAKhC,SAAS,CAACqC,UAAxB,IAAsCC,OAAO,CAACJ,WAAW,IAAIzC,IAAI,CAAC8C,KAAL,CAAWL,WAAW,CAACM,GAAvB,EAA4B5B,IAA5B,CAAhB,CAD/C,CA1BA,CA6BA;;AACA,QAAM6B,QAAQ,GAAGlC,mBAAmB,CAACc,OAAD,EAAUD,OAAV,aAAUA,OAAV,cAAUA,OAAV,GAAqBW,SAArB,EAAgC,CAClED,UAAU,CAACtB,KAAK,CAACmB,UAAP,CADwD,EAElEG,UAAU,CAACtB,KAAK,CAACoB,UAAP,CAFwD,CAAhC,CAApC;AAIA,QAAMc,gBAAuD,GAAG;AAC9D,KAAClC,KAAK,CAACmB,UAAP,GAAoBc,QAAQ,CAAC,CAAD,CADkC;AAE9D,KAACjC,KAAK,CAACoB,UAAP,GAAoBa,QAAQ,CAAC,CAAD;AAFkC,GAAhE,CAlCA,CAuCA;;AACA,QAAME,iBAA6C,GAAGrC,cAAc,CAClEe,OADkE,EAElEG,UAFkE,EAGlEM,UAAU,CAACP,gBAAD,CAHwD,CAApE;AAKA,QAAMqB,eAA2C,GAAG/C,OAAO,CAAC,MAAM;AAChE,QAAIuC,WAAJ,EAAiB;AACf,UAAIX,eAAe,IAAIK,UAAU,CAACJ,cAAD,CAAjC,EAAmD;AACjD,eAAOpB,cAAc,CAACe,OAAD,EAAUI,eAAV,EAA2BK,UAAU,CAACJ,cAAD,CAArC,CAArB;AACD;;AACD,aAAOK,SAAP;AACD,KALD,MAKO,IAAIY,iBAAJ,EAAuB;AAC5B;AACA,YAAME,wBAAwB,GAAGxC,qBAAqB,CAACsC,iBAAD,EAAoBtB,OAApB,CAAtD;AACA,YAAM,CAACyB,MAAD,EAASC,MAAT,IAAmB,CAAC3C,eAAe,CAACc,SAAD,EAAYG,OAAZ,CAAhB,EAAsCjB,eAAe,CAACe,SAAD,EAAYE,OAAZ,CAArD,CAAzB;;AACA,UAAIyB,MAAM,IAAIC,MAAV,IAAoBF,wBAApB,IAAgDZ,IAAhD,IAAwDZ,OAA5D,EAAqE;AACnE,cAAM2B,iBAAiB,GAAGtB,cAAc,KAAKlB,KAAK,CAACoB,UAAzB,GAAsCT,SAAtC,GAAkDD,SAA5E;AACA,cAAM+B,oBAAoB,GACxBvB,cAAc,KAAKlB,KAAK,CAACoB,UAAzB,GACIK,IAAI,CAACiB,OAAL,CAAaJ,MAAb,EAAqBK,KAArB,CAA2BN,wBAA3B,EAAqDxB,OAArD,CADJ,GAEIY,IAAI,CAACiB,OAAL,CAAaH,MAAb,EAAqBI,KAArB,CAA2BN,wBAA3B,EAAqDxB,OAArD,CAHN;AAIA,eAAO2B,iBAAiB,KAAKzD,KAAK,CAAC8B,OAAD,CAA3B,GACH/B,cAAc,CAAC8D,KAAf,CAAqBH,oBAAoB,CAACT,GAA1C,EAA+CnB,OAA/C,CADG,GAEH4B,oBAFJ;AAGD;;AACD,aAAOlB,SAAP;AACD,KAfM,MAeA;AACL,aAAOA,SAAP;AACD;AACF,GAxB0D,EAwBxD,CAACK,WAAD,EAAcX,eAAd,EAA+BK,UAA/B,EAA2CJ,cAA3C,EAA2DiB,iBAA3D,EAA8EzB,SAA9E,EAAyFG,OAAzF,EAAkGF,SAAlG,EAA6Gc,IAA7G,CAxBwD,CAA3D,CA7CA,CAsEA;;AACA,QAAMoB,aAA+D,GAAG;AACtE,KAAC7C,KAAK,CAACmB,UAAP,GAAoBJ,gBAAgB,KAAKf,KAAK,CAACmB,UAA3B,GAAwCgB,iBAAxC,GAA4DC,eADV;AAEtE,KAACpC,KAAK,CAACoB,UAAP,GAAoBL,gBAAgB,KAAKf,KAAK,CAACmB,UAA3B,GAAwCiB,eAAxC,GAA0DD;AAFR,GAAxE;AAKA,QAAMW,KAAK,GAAGzD,OAAO,CAAC,MAAM;AAC1B,QAAIuC,WAAJ,EAAiB;AACf,YAAM;AAAE,SAAC5B,KAAK,CAACmB,UAAP,GAAoB4B,eAAtB;AAAuC,SAAC/C,KAAK,CAACoB,UAAP,GAAoB4B;AAA3D,UAA+EH,aAArF;;AACA,UAAIE,eAAe,IAAIC,eAAvB,EAAwC;AACtC,eAAO,IAAI7D,KAAJ,CAAU4D,eAAe,CAACE,QAA1B,EAAoCD,eAAe,CAACC,QAApD,EAA8DF,eAAe,CAACf,GAA9E,EAAmFgB,eAAe,CAAChB,GAAnG,CAAP;AACD;;AACD,aAAOT,SAAP;AACD,KAND,MAMO;AACL,YAAM2B,gBAAgB,GAAGtD,eAAe,CAACc,SAAD,EAAYG,OAAZ,CAAxC;AACA,aAAOY,IAAI,IAAIyB,gBAAR,GAA2BzB,IAAI,CAACiB,OAAL,CAAaQ,gBAAb,CAA3B,GAA4D3B,SAAnE;AACD;AACF,GAXoB,EAWlB,CAACV,OAAD,EAAUH,SAAV,EAAqBkB,WAArB,EAAkCH,IAAlC,EAAwCoB,aAAxC,CAXkB,CAArB,CA5EA,CAyFA;;AACA,QAAMM,eAAe,GAAG9D,OAAO,CAAC,MAAM;AACpC,UAAM;AAAE,OAACW,KAAK,CAACmB,UAAP,GAAoB4B,eAAtB;AAAuC,OAAC/C,KAAK,CAACoB,UAAP,GAAoB4B;AAA3D,QAA+EH,aAArF;AACA,UAAM,CAACO,YAAD,EAAeC,YAAf,IAA+B,CACnCxD,qBAAqB,CAACkD,eAAD,EAAkBlC,OAAlB,CADc,EAEnChB,qBAAqB,CAACmD,eAAD,EAAkBnC,OAAlB,CAFc,CAArC;AAIAQ,IAAAA,iBAAiB,GAAG,KAApB,CANoC,CAMV;;AAC1B,QAAII,IAAI,IAAIC,WAAR,IAAuB0B,YAAvB,IAAuCC,YAA3C,EAAyD;AACvD,UAAI;AACF,eAAO5B,IAAI,CAAC6B,kBAAL,CAAwB5B,WAAxB,EAAqC0B,YAArC,EAAmDC,YAAnD,CAAP;AACD,OAFD,CAEE,OAAOE,GAAP,EAAY;AACZ,YAAIA,GAAG,YAAYvE,4BAAnB,EAAiD;AAC/CqC,UAAAA,iBAAiB,GAAG,IAApB;AACA,iBAAOE,SAAP;AACD,SAHD,MAGO;AACL,gBAAMgC,GAAN;AACD;AACF;AACF,KAXD,MAWO;AACL,aAAOhC,SAAP;AACD;AACF,GArB8B,EAqB5B,CAACsB,aAAD,EAAgBhC,OAAhB,EAAyBY,IAAzB,EAA+BC,WAA/B,CArB4B,CAA/B;AAuBA,QAAM8B,mBAAmB,GAAGnE,OAAO,CAAC,MAAM;AACxC,QAAI8D,eAAe,IAAIzB,WAAvB,EAAoC;AAClC,aAAO,IAAIxC,OAAJ,CAAYiE,eAAe,CAACnB,GAA5B,EAAiCN,WAAW,CAAC+B,GAAZ,CAAgBN,eAAhB,EAAiCnB,GAAlE,CAAP;AACD,KAFD,MAEO;AACL,aAAOT,SAAP;AACD;AACF,GANkC,EAMhC,CAAC4B,eAAD,EAAkBzB,WAAlB,CANgC,CAAnC;AAQA,MAAIgC,KAAJ;;AACA,MAAI,CAAC9C,OAAL,EAAc;AACZ8C,IAAAA,KAAK,GAAG5C,CAAC,CAAC,yBAAD,CAAT;AACD;;AAED,MAAIO,iBAAJ,EAAuB;AACrBqC,IAAAA,KAAK,GAAG5C,CAAC,CAAC,mCAAD,CAAT;AACD;;AAED,MAAIU,SAAS,KAAKhC,SAAS,CAACmE,OAA5B,EAAqC;AAAA;;AACnCD,IAAAA,KAAK,aAAGA,KAAH,2CAAY5C,CAAC,CAAC,uBAAD,CAAlB;AACD;;AAED,MAAI,CAAC+B,aAAa,CAAC7C,KAAK,CAACmB,UAAP,CAAd,IAAoC,CAAC0B,aAAa,CAAC7C,KAAK,CAACoB,UAAP,CAAtD,EAA0E;AAAA;;AACxEsC,IAAAA,KAAK,cAAGA,KAAH,6CAAY5C,CAAC,CAAC,uBAAD,CAAlB;AACD;;AAED,QAAM;AAAE,KAACd,KAAK,CAACmB,UAAP,GAAoB4B,eAAtB;AAAuC,KAAC/C,KAAK,CAACoB,UAAP,GAAoB4B;AAA3D,MAA+EH,aAArF;;AAEA,MAAIE,eAAe,KAAIb,gBAAJ,aAAIA,gBAAJ,gDAAIA,gBAAgB,CAAGlC,KAAK,CAACmB,UAAT,CAApB,0DAAI,sBAAsCyC,QAAtC,CAA+Cb,eAA/C,CAAJ,CAAnB,EAAwF;AAAA;;AACtFW,IAAAA,KAAK,GAAG5C,CAAC,CAAC,wBAAD,CAAD,6BAA8BQ,UAAU,CAACtB,KAAK,CAACmB,UAAP,CAAxC,0DAA8B,sBAA8B0C,MAA5D,IAAqE/C,CAAC,CAAC,mBAAD,CAA9E;AACD;;AAED,MAAIkC,eAAe,KAAId,gBAAJ,aAAIA,gBAAJ,iDAAIA,gBAAgB,CAAGlC,KAAK,CAACoB,UAAT,CAApB,2DAAI,uBAAsCwC,QAAtC,CAA+CZ,eAA/C,CAAJ,CAAnB,EAAwF;AAAA;;AACtFU,IAAAA,KAAK,GAAG5C,CAAC,CAAC,wBAAD,CAAD,8BAA8BQ,UAAU,CAACtB,KAAK,CAACoB,UAAP,CAAxC,2DAA8B,uBAA8ByC,MAA5D,IAAqE/C,CAAC,CAAC,mBAAD,CAA9E;AACD;;AAED,SAAO;AACLI,IAAAA,cADK;AAELI,IAAAA,UAFK;AAGLG,IAAAA,IAHK;AAILD,IAAAA,SAJK;AAKLU,IAAAA,gBALK;AAMLW,IAAAA,aANK;AAOLC,IAAAA,KAPK;AAQLlB,IAAAA,WARK;AASLuB,IAAAA,eATK;AAULK,IAAAA,mBAVK;AAWLE,IAAAA;AAXK,GAAP;AAaD;AAED,OAAO,SAASI,qBAAT,CACLlC,WADK,EAKL;AACA,QAAMmC,QAAQ,GAAGzE,WAAW,EAA5B;AAEA,QAAM0E,aAAa,GAAG5E,WAAW,CAC9B4B,UAAD,IAAwB;AACtB+C,IAAAA,QAAQ,CAAC9D,SAAS,CAAC;AAAEgE,MAAAA,KAAK,EAAEjE,KAAK,CAACmB,UAAf;AAA2BH,MAAAA,UAA3B;AAAuCY,MAAAA,WAAW,EAAEA,WAAW,KAAK;AAApE,KAAD,CAAV,CAAR;AACD,GAH8B,EAI/B,CAACmC,QAAD,EAAWnC,WAAX,CAJ+B,CAAjC;AAMA,QAAMsC,aAAa,GAAG9E,WAAW,CAC9B4B,UAAD,IAAwB;AACtB+C,IAAAA,QAAQ,CAAC9D,SAAS,CAAC;AAAEgE,MAAAA,KAAK,EAAEjE,KAAK,CAACoB,UAAf;AAA2BJ,MAAAA,UAA3B;AAAuCY,MAAAA,WAAW,EAAEA,WAAW,KAAK;AAApE,KAAD,CAAV,CAAR;AACD,GAH8B,EAI/B,CAACmC,QAAD,EAAWnC,WAAX,CAJ+B,CAAjC;AAOA,SAAO;AACLoC,IAAAA,aADK;AAELE,IAAAA;AAFK,GAAP;AAID","sourcesContent":["import {\n  Currency,\n  CurrencyAmount,\n  CAVAX,\n  InsufficientInputAmountError,\n  JSBI,\n  Pair,\n  Percent,\n  Price,\n  TokenAmount\n} from '@pangolindex/sdk'\nimport { useCallback, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { PairState, usePair } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency'\nimport { AppDispatch, AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, typeInput } from './actions'\nimport { useTranslation } from 'react-i18next'\nimport { useChainId } from 'src/hooks'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>(state => state.mint)\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount }\n  parsedAmounts: { [field in Field]?: CurrencyAmount }\n  price?: Price\n  noLiquidity?: boolean\n  liquidityMinted?: TokenAmount\n  poolTokenPercentage?: Percent\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const { t } = useTranslation()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // error handling\n  let insufficientInput = false\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined\n    }),\n    [currencyA, currencyB]\n  )\n\n  // pair\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B])\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO))\n\n  // balances\n  const balances = useCurrencyBalances(chainId, account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B]\n  ])\n  const currencyBalances: { [field in Field]?: CurrencyAmount } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }\n\n  // amounts\n  const independentAmount: CurrencyAmount | undefined = tryParseAmount(\n    chainId,\n    typedValue,\n    currencies[independentField]\n  )\n  const dependentAmount: CurrencyAmount | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(chainId, otherTypedValue, currencies[dependentField])\n      }\n      return undefined\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId)\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n      if (tokenA && tokenB && wrappedIndependentAmount && pair && chainId) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount, chainId)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount, chainId)\n        return dependentCurrency === CAVAX[chainId]\n          ? CurrencyAmount.ether(dependentTokenAmount.raw, chainId)\n          : dependentTokenAmount\n      }\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair])\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const parsedAmounts: { [field in Field]: CurrencyAmount | undefined } = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  }\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw)\n      }\n      return undefined\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA, chainId)\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [\n      wrappedCurrencyAmount(currencyAAmount, chainId),\n      wrappedCurrencyAmount(currencyBAmount, chainId)\n    ]\n    insufficientInput = false // eslint-disable-line react-hooks/exhaustive-deps\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n      } catch (err) {\n        if (err instanceof InsufficientInputAmountError) {\n          insufficientInput = true\n          return undefined\n        } else {\n          throw err\n        }\n      }\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: string | undefined\n  if (!account) {\n    error = t('mintHooks.connectWallet')\n  }\n\n  if (insufficientInput) {\n    error = t('mintHooks.insufficientInputAmount')\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? t('mintHooks.invalidPair')\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? t('mintHooks.enterAmount')\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = t('mintHooks.insufficient') + currencies[Field.CURRENCY_A]?.symbol + t('mintHooks.balance')\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = t('mintHooks.insufficient') + currencies[Field.CURRENCY_B]?.symbol + t('mintHooks.balance')\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  }\n}\n\nexport function useMintActionHandlers(\n  noLiquidity: boolean | undefined\n): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput\n  }\n}\n"]},"metadata":{},"sourceType":"module"}