{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GelatoBase = exports.isETHOrWETH = exports.isFlashbotsCompatibleChainId = exports.isValidChainIdAndHandler = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst abstract_provider_1 = require(\"@ethersproject/abstract-provider\");\n\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\n\nconst constants_1 = require(\"../constants\");\n\nconst types_1 = require(\"../contracts/types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst isValidChainIdAndHandler = (chainId, handler) => {\n  return constants_1.NETWORK_HANDLERS[chainId].includes(handler);\n};\n\nexports.isValidChainIdAndHandler = isValidChainIdAndHandler;\n\nconst isFlashbotsCompatibleChainId = chainId => {\n  return chainId == constants_1.CHAIN_ID.MAINNET || chainId == constants_1.CHAIN_ID.GOERLI;\n};\n\nexports.isFlashbotsCompatibleChainId = isFlashbotsCompatibleChainId;\n\nconst isETHOrWETH = (tokenAddress, chainID) => {\n  const WETH_ADDRESS = constants_1.NATIVE_WRAPPED_TOKEN_ADDRESS[chainID];\n  return tokenAddress.toLowerCase() === constants_1.ETH_ADDRESS.toLowerCase() || tokenAddress.toLowerCase() === WETH_ADDRESS.toLowerCase();\n};\n\nexports.isETHOrWETH = isETHOrWETH;\n\nclass GelatoBase {\n  constructor(chainId, moduleAddress, signerOrProvider, handler, handlerAddress) {\n    if (handler && !(0, exports.isValidChainIdAndHandler)(chainId, handler)) {\n      throw new Error(\"Invalid chainId and handler\");\n    }\n\n    this._chainId = chainId;\n    this._gelatoFeeBPS = !(0, utils_1.isEthereumChain)(chainId) ? constants_1.BPS_GELATO_FEE[chainId] : 0;\n    this._slippageBPS = constants_1.STOP_LIMIT_SLIPPAGE_BPS[chainId];\n    this._subgraphUrl = constants_1.SUBGRAPH_URL[chainId];\n    this._signer = abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider : undefined;\n    this._provider = abstract_provider_1.Provider.isProvider(signerOrProvider) ? signerOrProvider : abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : undefined;\n    this._gelatoCore = this._signer ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._signer) : this._provider ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._provider) : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], types_1.GelatoLimitOrders__factory.createInterface());\n    this._abiEncoder = new ethers_1.utils.AbiCoder();\n    this._erc20OrderRouter = this._signer ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._signer) : this._provider ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._provider) : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], types_1.ERC20OrderRouter__factory.createInterface());\n    this._handler = handler;\n    this._handlerAddress = handlerAddress;\n    this._moduleAddress = moduleAddress;\n  }\n\n  get gelatoFeeBPS() {\n    return this._gelatoFeeBPS;\n  }\n\n  get slippageBPS() {\n    return this._slippageBPS;\n  }\n\n  get chainId() {\n    return this._chainId;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  get provider() {\n    return this._provider;\n  }\n\n  get subgraphUrl() {\n    return this._subgraphUrl;\n  }\n\n  get handler() {\n    return this._handler;\n  }\n\n  get handlerAddress() {\n    return this._handlerAddress;\n  }\n\n  get moduleAddress() {\n    return this._moduleAddress;\n  }\n\n  get contract() {\n    return this._gelatoCore;\n  }\n\n  get erc20OrderRouter() {\n    return this._erc20OrderRouter;\n  }\n\n  get abiEncoder() {\n    return this._abiEncoder;\n  }\n\n  encodeLimitOrderCancellation(order, checkIsActiveOrder) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n      if (!order.inputToken) throw new Error(\"No input token in order\");\n      if (!order.witness) throw new Error(\"No witness in order\");\n      if (!order.outputToken) throw new Error(\"No output token in order\");\n      if (!order.minReturn) throw new Error(\"No minReturn in order\");\n      if (!order.owner) throw new Error(\"No owner\");\n\n      if (checkIsActiveOrder) {\n        const isActiveOrder = yield this.isActiveOrder(order);\n        if (!isActiveOrder) throw new Error(\"Order not found. Please review your order data.\");\n      }\n\n      const data = this._gelatoCore.interface.encodeFunctionData(\"cancelOrder\", [this._moduleAddress, order.inputToken, order.owner, order.witness, order.data]);\n\n      return {\n        data,\n        to: this._gelatoCore.address,\n        value: ethers_1.constants.Zero\n      };\n    });\n  }\n\n  cancelStopLimitOrder(order, checkIsActiveOrder, overrides) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._signer) throw new Error(\"No signer\");\n      if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n      if (!order.inputToken) throw new Error(\"No input token in order\");\n      if (!order.witness) throw new Error(\"No witness in order\");\n      if (!order.outputToken) throw new Error(\"No output token in order\");\n      if (!order.minReturn) throw new Error(\"No minReturn in order\");\n      if (!order.data) throw new Error(\"No data in order\");\n\n      if (checkIsActiveOrder) {\n        const isActiveOrder = yield this.isActiveOrder(order);\n        if (!isActiveOrder) throw new Error(\"Order not found. Please review your order data.\");\n      }\n\n      const owner = yield this._signer.getAddress();\n      if (owner.toLowerCase() !== order.owner.toLowerCase()) throw new Error(\"Owner and signer mismatch\");\n      return this._gelatoCore.cancelOrder(this._moduleAddress, order.inputToken, order.owner, order.witness, order.data, overrides !== null && overrides !== void 0 ? overrides : {\n        gasLimit: (0, utils_1.isEthereumChain)(this._chainId) ? 500000 : 1500000\n      });\n    });\n  }\n\n  approveTokenAmount(inputToken, amount, overrides) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._signer) throw new Error(\"No signer\");\n      return overrides ? types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount, overrides) : types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount);\n    });\n  }\n\n  isActiveOrder(order) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._provider) throw new Error(\"No provider\");\n      if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n      if (!order.module) throw new Error(\"No module in order\");\n      if (!order.inputToken) throw new Error(\"No input token in order\");\n      if (!order.owner) throw new Error(\"No owner in order\");\n      if (!order.witness) throw new Error(\"No witness in order\");\n      if (!order.data) throw new Error(\"No data in order\");\n      return this._gelatoCore.existOrder(order.module, order.inputToken, order.owner, order.witness, order.data);\n    });\n  }\n\n  getExchangeRate(inputValue, inputDecimals, outputValue, outputDecimals) {\n    let invert = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(18));\n\n    if (invert) {\n      return ethers_1.BigNumber.from(inputValue).mul(factor).div(outputValue).mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals))).div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals))).toString();\n    } else {\n      return ethers_1.BigNumber.from(outputValue).mul(factor).div(inputValue).mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals))).div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals))).toString();\n    }\n  }\n\n  getFeeAndSlippageAdjustedMinReturn(outputAmount, extraSlippageBPS) {\n    if (extraSlippageBPS) {\n      if (!Number.isInteger(extraSlippageBPS)) throw new Error(\"Extra Slippage BPS must an unsigned integer\");\n    }\n\n    const gelatoFee = (0, utils_1.isEthereumChain)(this._chainId) ? 0 : ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000).gte(1) ? ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000) : ethers_1.BigNumber.from(1);\n    const slippageBPS = extraSlippageBPS ? extraSlippageBPS : this._slippageBPS;\n    const slippage = ethers_1.BigNumber.from(outputAmount).mul(slippageBPS).div(10000);\n    const minReturn = ethers_1.BigNumber.from(outputAmount).sub(gelatoFee).sub(slippage);\n    return {\n      minReturn: minReturn.toString(),\n      slippage: slippage.toString(),\n      gelatoFee: gelatoFee.toString()\n    };\n  }\n\n  getAdjustedMinReturn(minReturn, extraSlippageBPS) {\n    if ((0, utils_1.isEthereumChain)(this._chainId)) throw new Error(\"Method not available for current chain.\");\n    const gelatoFee = ethers_1.BigNumber.from(this._gelatoFeeBPS);\n    const slippage = extraSlippageBPS ? ethers_1.BigNumber.from(extraSlippageBPS) : ethers_1.BigNumber.from(this._slippageBPS);\n    const fees = gelatoFee.add(slippage);\n    const adjustedMinReturn = ethers_1.BigNumber.from(minReturn).mul(10000).div(ethers_1.BigNumber.from(10000).sub(fees));\n    return adjustedMinReturn.toString();\n  }\n\n  getExecutionPrice(inputAmount, inputDecimals, outputAmount, outputDecimals) {\n    let isInverted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(isInverted ? outputDecimals : inputDecimals));\n\n    if (isInverted) {\n      return ethers_1.BigNumber.from(inputAmount).mul(factor).div(outputAmount).toString();\n    } else {\n      return ethers_1.BigNumber.from(outputAmount).mul(factor).div(inputAmount).toString();\n    }\n  }\n\n  _getKey(order) {\n    return ethers_1.utils.keccak256(this._abiEncoder.encode([\"address\", \"address\", \"address\", \"address\", \"bytes\"], [order.module, order.inputToken, order.owner, order.witness, order.data]));\n  }\n\n  _encodeSubmitData(inputToken, outputToken, owner, witness, amount, maxReturn, minReturn, secret, checkAllowance) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this.provider) throw new Error(\"No provider\");\n      if (!this.handlerAddress) throw new Error(\"No handlerAddress\");\n      if (inputToken.toLowerCase() === outputToken.toLowerCase()) throw new Error(\"Input token and output token can not be equal\");\n      const encodedData = this.abiEncoder.encode([\"address\", \"uint256\", \"address\", \"uint256\"], [outputToken, minReturn, this.handlerAddress, maxReturn]);\n      let data, value, to;\n\n      if ((0, utils_1.isNetworkGasToken)(inputToken)) {\n        const encodedEthOrder = yield this.contract.encodeEthOrder(this.moduleAddress, constants_1.ETH_ADDRESS, // we also use ETH_ADDRESS if it's MATIC\n        owner, witness, encodedData, secret);\n        data = this.contract.interface.encodeFunctionData(\"depositEth\", [encodedEthOrder]);\n        value = amount;\n        to = this.contract.address;\n      } else {\n        if (checkAllowance) {\n          const allowance = yield types_1.ERC20__factory.connect(inputToken, this.provider).allowance(owner, this.erc20OrderRouter.address);\n          if (allowance.lt(amount)) throw new Error(\"Insufficient token allowance for placing order\");\n        }\n\n        data = this.erc20OrderRouter.interface.encodeFunctionData(\"depositToken\", [amount, this.moduleAddress, inputToken, owner, witness, encodedData, secret]);\n        value = ethers_1.constants.Zero;\n        to = this.erc20OrderRouter.address;\n      }\n\n      return {\n        data,\n        value,\n        to\n      };\n    });\n  }\n\n}\n\nexports.GelatoBase = GelatoBase;","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/node_modules/@gelatonetwork/limit-orders-lib/dist/stoplimit-orders/core.js"],"names":["Object","defineProperty","exports","value","GelatoBase","isETHOrWETH","isFlashbotsCompatibleChainId","isValidChainIdAndHandler","tslib_1","require","ethers_1","abstract_provider_1","abstract_signer_1","constants_1","types_1","utils_1","chainId","handler","NETWORK_HANDLERS","includes","CHAIN_ID","MAINNET","GOERLI","tokenAddress","chainID","WETH_ADDRESS","NATIVE_WRAPPED_TOKEN_ADDRESS","toLowerCase","ETH_ADDRESS","constructor","moduleAddress","signerOrProvider","handlerAddress","Error","_chainId","_gelatoFeeBPS","isEthereumChain","BPS_GELATO_FEE","_slippageBPS","STOP_LIMIT_SLIPPAGE_BPS","_subgraphUrl","SUBGRAPH_URL","_signer","Signer","isSigner","undefined","_provider","Provider","isProvider","provider","_gelatoCore","GelatoLimitOrders__factory","connect","GELATO_LIMIT_ORDERS_ADDRESS","Contract","createInterface","_abiEncoder","utils","AbiCoder","_erc20OrderRouter","ERC20OrderRouter__factory","GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER","_handler","_handlerAddress","_moduleAddress","gelatoFeeBPS","slippageBPS","signer","subgraphUrl","contract","erc20OrderRouter","abiEncoder","encodeLimitOrderCancellation","order","checkIsActiveOrder","__awaiter","inputToken","witness","outputToken","minReturn","owner","isActiveOrder","data","interface","encodeFunctionData","to","address","constants","Zero","cancelStopLimitOrder","overrides","getAddress","cancelOrder","gasLimit","approveTokenAmount","amount","ERC20__factory","approve","module","existOrder","getExchangeRate","inputValue","inputDecimals","outputValue","outputDecimals","invert","factor","BigNumber","from","pow","mul","div","toString","getFeeAndSlippageAdjustedMinReturn","outputAmount","extraSlippageBPS","Number","isInteger","gelatoFee","gte","slippage","sub","getAdjustedMinReturn","fees","add","adjustedMinReturn","getExecutionPrice","inputAmount","isInverted","_getKey","keccak256","encode","_encodeSubmitData","maxReturn","secret","checkAllowance","encodedData","isNetworkGasToken","encodedEthOrder","encodeEthOrder","allowance","lt"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GelatoBase = exports.isETHOrWETH = exports.isFlashbotsCompatibleChainId = exports.isValidChainIdAndHandler = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ethers_1 = require(\"ethers\");\nconst abstract_provider_1 = require(\"@ethersproject/abstract-provider\");\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\nconst constants_1 = require(\"../constants\");\nconst types_1 = require(\"../contracts/types\");\nconst utils_1 = require(\"../utils\");\nconst isValidChainIdAndHandler = (chainId, handler) => {\n    return constants_1.NETWORK_HANDLERS[chainId].includes(handler);\n};\nexports.isValidChainIdAndHandler = isValidChainIdAndHandler;\nconst isFlashbotsCompatibleChainId = (chainId) => {\n    return chainId == constants_1.CHAIN_ID.MAINNET || chainId == constants_1.CHAIN_ID.GOERLI;\n};\nexports.isFlashbotsCompatibleChainId = isFlashbotsCompatibleChainId;\nconst isETHOrWETH = (tokenAddress, chainID) => {\n    const WETH_ADDRESS = constants_1.NATIVE_WRAPPED_TOKEN_ADDRESS[chainID];\n    return (tokenAddress.toLowerCase() === constants_1.ETH_ADDRESS.toLowerCase() ||\n        tokenAddress.toLowerCase() === WETH_ADDRESS.toLowerCase());\n};\nexports.isETHOrWETH = isETHOrWETH;\nclass GelatoBase {\n    constructor(chainId, moduleAddress, signerOrProvider, handler, handlerAddress) {\n        if (handler && !(0, exports.isValidChainIdAndHandler)(chainId, handler)) {\n            throw new Error(\"Invalid chainId and handler\");\n        }\n        this._chainId = chainId;\n        this._gelatoFeeBPS = !(0, utils_1.isEthereumChain)(chainId)\n            ? constants_1.BPS_GELATO_FEE[chainId]\n            : 0;\n        this._slippageBPS = constants_1.STOP_LIMIT_SLIPPAGE_BPS[chainId];\n        this._subgraphUrl = constants_1.SUBGRAPH_URL[chainId];\n        this._signer = abstract_signer_1.Signer.isSigner(signerOrProvider)\n            ? signerOrProvider\n            : undefined;\n        this._provider = abstract_provider_1.Provider.isProvider(signerOrProvider)\n            ? signerOrProvider\n            : abstract_signer_1.Signer.isSigner(signerOrProvider)\n                ? signerOrProvider.provider\n                : undefined;\n        this._gelatoCore = this._signer\n            ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._signer)\n            : this._provider\n                ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._provider)\n                : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], types_1.GelatoLimitOrders__factory.createInterface());\n        this._abiEncoder = new ethers_1.utils.AbiCoder();\n        this._erc20OrderRouter = this._signer\n            ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._signer)\n            : this._provider\n                ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._provider)\n                : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], types_1.ERC20OrderRouter__factory.createInterface());\n        this._handler = handler;\n        this._handlerAddress = handlerAddress;\n        this._moduleAddress = moduleAddress;\n    }\n    get gelatoFeeBPS() {\n        return this._gelatoFeeBPS;\n    }\n    get slippageBPS() {\n        return this._slippageBPS;\n    }\n    get chainId() {\n        return this._chainId;\n    }\n    get signer() {\n        return this._signer;\n    }\n    get provider() {\n        return this._provider;\n    }\n    get subgraphUrl() {\n        return this._subgraphUrl;\n    }\n    get handler() {\n        return this._handler;\n    }\n    get handlerAddress() {\n        return this._handlerAddress;\n    }\n    get moduleAddress() {\n        return this._moduleAddress;\n    }\n    get contract() {\n        return this._gelatoCore;\n    }\n    get erc20OrderRouter() {\n        return this._erc20OrderRouter;\n    }\n    get abiEncoder() {\n        return this._abiEncoder;\n    }\n    encodeLimitOrderCancellation(order, checkIsActiveOrder) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._gelatoCore)\n                throw new Error(\"No gelato limit orders contract\");\n            if (!order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!order.witness)\n                throw new Error(\"No witness in order\");\n            if (!order.outputToken)\n                throw new Error(\"No output token in order\");\n            if (!order.minReturn)\n                throw new Error(\"No minReturn in order\");\n            if (!order.owner)\n                throw new Error(\"No owner\");\n            if (checkIsActiveOrder) {\n                const isActiveOrder = yield this.isActiveOrder(order);\n                if (!isActiveOrder)\n                    throw new Error(\"Order not found. Please review your order data.\");\n            }\n            const data = this._gelatoCore.interface.encodeFunctionData(\"cancelOrder\", [\n                this._moduleAddress,\n                order.inputToken,\n                order.owner,\n                order.witness,\n                order.data,\n            ]);\n            return {\n                data,\n                to: this._gelatoCore.address,\n                value: ethers_1.constants.Zero,\n            };\n        });\n    }\n    cancelStopLimitOrder(order, checkIsActiveOrder, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._signer)\n                throw new Error(\"No signer\");\n            if (!this._gelatoCore)\n                throw new Error(\"No gelato limit orders contract\");\n            if (!order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!order.witness)\n                throw new Error(\"No witness in order\");\n            if (!order.outputToken)\n                throw new Error(\"No output token in order\");\n            if (!order.minReturn)\n                throw new Error(\"No minReturn in order\");\n            if (!order.data)\n                throw new Error(\"No data in order\");\n            if (checkIsActiveOrder) {\n                const isActiveOrder = yield this.isActiveOrder(order);\n                if (!isActiveOrder)\n                    throw new Error(\"Order not found. Please review your order data.\");\n            }\n            const owner = yield this._signer.getAddress();\n            if (owner.toLowerCase() !== order.owner.toLowerCase())\n                throw new Error(\"Owner and signer mismatch\");\n            return this._gelatoCore.cancelOrder(this._moduleAddress, order.inputToken, order.owner, order.witness, order.data, overrides !== null && overrides !== void 0 ? overrides : {\n                gasLimit: (0, utils_1.isEthereumChain)(this._chainId) ? 500000 : 1500000,\n            });\n        });\n    }\n    approveTokenAmount(inputToken, amount, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._signer)\n                throw new Error(\"No signer\");\n            return overrides\n                ? types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount, overrides)\n                : types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount);\n        });\n    }\n    isActiveOrder(order) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._provider)\n                throw new Error(\"No provider\");\n            if (!this._gelatoCore)\n                throw new Error(\"No gelato limit orders contract\");\n            if (!order.module)\n                throw new Error(\"No module in order\");\n            if (!order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!order.owner)\n                throw new Error(\"No owner in order\");\n            if (!order.witness)\n                throw new Error(\"No witness in order\");\n            if (!order.data)\n                throw new Error(\"No data in order\");\n            return this._gelatoCore.existOrder(order.module, order.inputToken, order.owner, order.witness, order.data);\n        });\n    }\n    getExchangeRate(inputValue, inputDecimals, outputValue, outputDecimals, invert = false) {\n        const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(18));\n        if (invert) {\n            return ethers_1.BigNumber.from(inputValue)\n                .mul(factor)\n                .div(outputValue)\n                .mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals)))\n                .div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals)))\n                .toString();\n        }\n        else {\n            return ethers_1.BigNumber.from(outputValue)\n                .mul(factor)\n                .div(inputValue)\n                .mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals)))\n                .div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals)))\n                .toString();\n        }\n    }\n    getFeeAndSlippageAdjustedMinReturn(outputAmount, extraSlippageBPS) {\n        if (extraSlippageBPS) {\n            if (!Number.isInteger(extraSlippageBPS))\n                throw new Error(\"Extra Slippage BPS must an unsigned integer\");\n        }\n        const gelatoFee = (0, utils_1.isEthereumChain)(this._chainId)\n            ? 0\n            : ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000).gte(1)\n                ? ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000)\n                : ethers_1.BigNumber.from(1);\n        const slippageBPS = extraSlippageBPS ? extraSlippageBPS : this._slippageBPS;\n        const slippage = ethers_1.BigNumber.from(outputAmount).mul(slippageBPS).div(10000);\n        const minReturn = ethers_1.BigNumber.from(outputAmount).sub(gelatoFee).sub(slippage);\n        return {\n            minReturn: minReturn.toString(),\n            slippage: slippage.toString(),\n            gelatoFee: gelatoFee.toString(),\n        };\n    }\n    getAdjustedMinReturn(minReturn, extraSlippageBPS) {\n        if ((0, utils_1.isEthereumChain)(this._chainId))\n            throw new Error(\"Method not available for current chain.\");\n        const gelatoFee = ethers_1.BigNumber.from(this._gelatoFeeBPS);\n        const slippage = extraSlippageBPS\n            ? ethers_1.BigNumber.from(extraSlippageBPS)\n            : ethers_1.BigNumber.from(this._slippageBPS);\n        const fees = gelatoFee.add(slippage);\n        const adjustedMinReturn = ethers_1.BigNumber.from(minReturn)\n            .mul(10000)\n            .div(ethers_1.BigNumber.from(10000).sub(fees));\n        return adjustedMinReturn.toString();\n    }\n    getExecutionPrice(inputAmount, inputDecimals, outputAmount, outputDecimals, isInverted = false) {\n        const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(isInverted ? outputDecimals : inputDecimals));\n        if (isInverted) {\n            return ethers_1.BigNumber.from(inputAmount)\n                .mul(factor)\n                .div(outputAmount)\n                .toString();\n        }\n        else {\n            return ethers_1.BigNumber.from(outputAmount)\n                .mul(factor)\n                .div(inputAmount)\n                .toString();\n        }\n    }\n    _getKey(order) {\n        return ethers_1.utils.keccak256(this._abiEncoder.encode([\"address\", \"address\", \"address\", \"address\", \"bytes\"], [order.module, order.inputToken, order.owner, order.witness, order.data]));\n    }\n    _encodeSubmitData(inputToken, outputToken, owner, witness, amount, maxReturn, minReturn, secret, checkAllowance) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this.provider)\n                throw new Error(\"No provider\");\n            if (!this.handlerAddress)\n                throw new Error(\"No handlerAddress\");\n            if (inputToken.toLowerCase() === outputToken.toLowerCase())\n                throw new Error(\"Input token and output token can not be equal\");\n            const encodedData = this.abiEncoder.encode([\"address\", \"uint256\", \"address\", \"uint256\"], [outputToken, minReturn, this.handlerAddress, maxReturn]);\n            let data, value, to;\n            if ((0, utils_1.isNetworkGasToken)(inputToken)) {\n                const encodedEthOrder = yield this.contract.encodeEthOrder(this.moduleAddress, constants_1.ETH_ADDRESS, // we also use ETH_ADDRESS if it's MATIC\n                owner, witness, encodedData, secret);\n                data = this.contract.interface.encodeFunctionData(\"depositEth\", [\n                    encodedEthOrder,\n                ]);\n                value = amount;\n                to = this.contract.address;\n            }\n            else {\n                if (checkAllowance) {\n                    const allowance = yield types_1.ERC20__factory.connect(inputToken, this.provider).allowance(owner, this.erc20OrderRouter.address);\n                    if (allowance.lt(amount))\n                        throw new Error(\"Insufficient token allowance for placing order\");\n                }\n                data = this.erc20OrderRouter.interface.encodeFunctionData(\"depositToken\", [\n                    amount,\n                    this.moduleAddress,\n                    inputToken,\n                    owner,\n                    witness,\n                    encodedData,\n                    secret,\n                ]);\n                value = ethers_1.constants.Zero;\n                to = this.erc20OrderRouter.address;\n            }\n            return { data, value, to };\n        });\n    }\n}\nexports.GelatoBase = GelatoBase;\n"]},"metadata":{},"sourceType":"script"}