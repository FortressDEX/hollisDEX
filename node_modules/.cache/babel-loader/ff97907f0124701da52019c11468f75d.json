{"ast":null,"code":"import { __read } from \"tslib\";\nimport { eventToSentryRequest, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, initAPIDetails, sessionToSentryRequest } from '@sentry/core';\nimport { createClientReportEnvelope, disabledUntil, dsnToString, eventStatusFromHttpCode, getGlobalObject, isDebugBuild, isRateLimited, logger, makePromiseBuffer, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nimport { sendReport } from './utils';\n\nfunction requestTypeToCategory(ty) {\n  var tyStr = ty;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\n\nvar global = getGlobalObject();\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  function BaseTransport(options) {\n    var _this = this;\n\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = makePromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n\n    this._rateLimits = {};\n    this._outcomes = {};\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel); // eslint-disable-next-line deprecation/deprecation\n\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', function () {\n        if (global.document.visibilityState === 'hidden') {\n          _this._flushOutcomes();\n        }\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.recordLostEvent = function (reason, category) {\n    var _a;\n\n    if (!this.options.sendClientReports) {\n      return;\n    } // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n\n\n    var key = requestTypeToCategory(category) + \":\" + reason;\n    isDebugBuild() && logger.log(\"Adding outcome: \" + key);\n    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;\n  };\n  /**\n   * Send outcomes as an envelope\n   */\n\n\n  BaseTransport.prototype._flushOutcomes = function () {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    var outcomes = this._outcomes;\n    this._outcomes = {}; // Nothing to send\n\n    if (!Object.keys(outcomes).length) {\n      isDebugBuild() && logger.log('No outcomes to flush');\n      return;\n    }\n\n    isDebugBuild() && logger.log(\"Flushing outcomes:\\n\" + JSON.stringify(outcomes, null, 2));\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n    var discardedEvents = Object.keys(outcomes).map(function (key) {\n      var _a = __read(key.split(':'), 2),\n          category = _a[0],\n          reason = _a[1];\n\n      return {\n        reason: reason,\n        category: category,\n        quantity: outcomes[key]\n      }; // TODO: Improve types on discarded_events to get rid of cast\n    });\n    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      isDebugBuild() && logger.error(e);\n    }\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n\n\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n        response = _a.response,\n        headers = _a.headers,\n        resolve = _a.resolve,\n        reject = _a.reject;\n    var status = eventStatusFromHttpCode(response.status);\n    this._rateLimits = updateRateLimits(this._rateLimits, headers); // eslint-disable-next-line deprecation/deprecation\n\n    if (this._isRateLimited(requestType) && isDebugBuild()) {\n      isDebugBuild() && // eslint-disable-next-line deprecation/deprecation\n      logger.warn(\"Too many \" + requestType + \" requests, backing off until: \" + this._disabledUntil(requestType));\n    }\n\n    if (status === 'success') {\n      resolve({\n        status: status\n      });\n      return;\n    }\n\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   *\n   * @deprecated Please use `disabledUntil` from @sentry/utils\n   */\n\n\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return new Date(disabledUntil(this._rateLimits, category));\n  };\n  /**\n   * Checks if a category is rate limited\n   *\n   * @deprecated Please use `isRateLimited` from @sentry/utils\n   */\n\n\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return isRateLimited(this._rateLimits, category);\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport };","map":{"version":3,"sources":["../../../src/transports/base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  APIDetails,\n  eventToSentryRequest,\n  getEnvelopeEndpointWithUrlEncodedAuth,\n  getStoreEndpointWithUrlEncodedAuth,\n  initAPIDetails,\n  sessionToSentryRequest,\n} from '@sentry/core';\nimport {\n  ClientReport,\n  Event,\n  Outcome,\n  Response as SentryResponse,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  createClientReportEnvelope,\n  disabledUntil,\n  dsnToString,\n  eventStatusFromHttpCode,\n  getGlobalObject,\n  isDebugBuild,\n  isRateLimited,\n  logger,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nimport { sendReport } from './utils';\n\nfunction requestTypeToCategory(ty: SentryRequestType): string {\n  const tyStr = ty as string;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\n\nconst global = getGlobalObject<Window>();\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: APIDetails;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = makePromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected _rateLimits: RateLimits = {};\n\n  protected _outcomes: { [key: string]: number } = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', () => {\n        if (global.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<SentryResponse> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<SentryResponse> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordLostEvent(reason: Outcome, category: SentryRequestType): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    const key = `${requestTypeToCategory(category)}:${reason}`;\n    isDebugBuild() && logger.log(`Adding outcome: ${key}`);\n    this._outcomes[key] = (this._outcomes[key] ?? 0) + 1;\n  }\n\n  /**\n   * Send outcomes as an envelope\n   */\n  protected _flushOutcomes(): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      isDebugBuild() && logger.log('No outcomes to flush');\n      return;\n    }\n\n    isDebugBuild() && logger.log(`Flushing outcomes:\\n${JSON.stringify(outcomes, null, 2)}`);\n\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n\n    const discardedEvents = Object.keys(outcomes).map(key => {\n      const [category, reason] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    }) as ClientReport['discarded_events'];\n    const envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      isDebugBuild() && logger.error(e);\n    }\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = eventStatusFromHttpCode(response.status);\n\n    this._rateLimits = updateRateLimits(this._rateLimits, headers);\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(requestType) && isDebugBuild()) {\n      isDebugBuild() &&\n        // eslint-disable-next-line deprecation/deprecation\n        logger.warn(`Too many ${requestType} requests, backing off until: ${this._disabledUntil(requestType)}`);\n    }\n\n    if (status === 'success') {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   *\n   * @deprecated Please use `disabledUntil` from @sentry/utils\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = requestTypeToCategory(requestType);\n    return new Date(disabledUntil(this._rateLimits, category));\n  }\n\n  /**\n   * Checks if a category is rate limited\n   *\n   * @deprecated Please use `isRateLimited` from @sentry/utils\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    const category = requestTypeToCategory(requestType);\n    return isRateLimited(this._rateLimits, category);\n  }\n\n  protected abstract _sendRequest(\n    sentryRequest: SentryRequest,\n    originalPayload: Event | Session,\n  ): PromiseLike<SentryResponse>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}