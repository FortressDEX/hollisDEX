{"ast":null,"code":"import { useEffect } from 'react';\nimport { client, blockClient } from '../../apollo/client';\nimport { GET_TOKEN_DAY_DATAS } from '../../apollo/tokenDayDatas';\nimport { GET_BLOCKS, PRICES_BY_BLOCK } from '../../apollo/block';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updateTokenWeeklyPriceChartData, updateTokenPriceChartData } from 'src/state/token/actions';\nimport { splitQuery } from 'src/utils/query';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\ndayjs.extend(utc);\nexport function useAllTokenWeeklyPriceChartData() {\n  const allTokenCharts = useSelector(state => {\n    var _state$token;\n\n    return (state === null || state === void 0 ? void 0 : (_state$token = state.token) === null || _state$token === void 0 ? void 0 : _state$token.weekly) || {};\n  });\n  return allTokenCharts;\n}\nexport function useAllTokenPricesChartData() {\n  const allTokenCharts = useSelector(state => {\n    var _state$token2;\n\n    return (state === null || state === void 0 ? void 0 : (_state$token2 = state.token) === null || _state$token2 === void 0 ? void 0 : _state$token2.tokenPrices) || {};\n  });\n  return allTokenCharts;\n}\nexport function useTokenWeeklyChartData(tokenAddress) {\n  const data1 = useAllTokenWeeklyPriceChartData();\n  const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];\n  const dispatch = useDispatch();\n  useEffect(() => {\n    async function checkForChartData() {\n      if (!chartData) {\n        const data = await getTokenWeeklyChartData(tokenAddress);\n        dispatch(updateTokenWeeklyPriceChartData({\n          address: tokenAddress,\n          chartData: data\n        }));\n      }\n    }\n\n    checkForChartData(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [chartData, tokenAddress]);\n  return chartData;\n}\n\nconst getTokenWeeklyChartData = async tokenAddress => {\n  let data = [];\n\n  try {\n    var _result$data;\n\n    const result = await client.query({\n      query: GET_TOKEN_DAY_DATAS,\n      variables: {\n        token: tokenAddress\n      },\n      fetchPolicy: 'cache-first'\n    });\n    data = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.tokenDayDatas;\n  } catch (e) {\n    console.log(e);\n  }\n\n  data = data.sort((a, b) => parseInt(a.date) > parseInt(b.date) ? 1 : -1);\n  return data;\n};\n\nexport function useTokenPriceData(tokenAddress, timeWindow) {\n  let interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3600;\n  let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'ALL';\n  const data1 = useAllTokenPricesChartData();\n  const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];\n  const dispatch = useDispatch();\n  useEffect(() => {\n    const currentTime = dayjs === null || dayjs === void 0 ? void 0 : dayjs.utc(); // February 8th 2021 - Pangolin Factory is created\n\n    const startTime = type === 'ALL' ? dayjs('2021-02-11').startOf('hour').unix() : currentTime.subtract(1, timeWindow).startOf('hour').unix();\n\n    async function fetch() {\n      const data = await getIntervalTokenData(tokenAddress, startTime, undefined, interval);\n      dispatch(updateTokenPriceChartData({\n        address: tokenAddress,\n        chartData: data\n      }));\n    }\n\n    fetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [interval, timeWindow, tokenAddress]);\n  return chartData;\n}\nexport const getIntervalTokenData = async function (tokenAddress, startTime) {\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : dayjs.utc().unix();\n  let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3600 * 24;\n  const utcEndTime = to;\n  let time = startTime; // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n\n  const timestamps = [];\n\n  while (time < utcEndTime) {\n    timestamps.push(time);\n    time += interval;\n  } // backout if invalid timestamp format\n\n\n  if (timestamps.length === 0) {\n    return [];\n  } // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n\n\n  let blocks;\n\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100); // catch failing case\n\n    if (!blocks || blocks.length === 0) {\n      return [];\n    }\n\n    const result = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50); // format token ETH price results\n\n    const values = [];\n\n    for (const row in result) {\n      var _result$, _result$2;\n\n      const timestamp = row.split('t')[1];\n      if (!timestamp) continue;\n      const derivedETH = parseFloat((_result$ = result[`t${timestamp}`]) === null || _result$ === void 0 ? void 0 : _result$.derivedETH);\n      const ethPrice = parseFloat((_result$2 = result[`b${timestamp}`]) === null || _result$2 === void 0 ? void 0 : _result$2.ethPrice);\n      const priceUSD = ethPrice * derivedETH;\n      values.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      });\n    }\n\n    const formattedHistory = []; // for each hour, construct the open and close price\n\n    for (let i = 0; i < values.length - 1; i++) {\n      formattedHistory.push({\n        timestamp: values[i].timestamp,\n        priceUSD: parseFloat(values === null || values === void 0 ? void 0 : values[i].priceUSD)\n      });\n    }\n\n    return formattedHistory;\n  } catch (e) {\n    console.log(e);\n    console.log('error fetching blocks');\n    return [];\n  }\n};\nexport async function getBlocksFromTimestamps(timestamps) {\n  let skipCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n\n  if ((timestamps === null || timestamps === void 0 ? void 0 : timestamps.length) === 0) {\n    return [];\n  }\n\n  const fetchedData = await splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount);\n  const blocks = [];\n\n  if (fetchedData) {\n    for (const t in fetchedData) {\n      if (fetchedData[t].length > 0) {\n        blocks.push({\n          timestamp: t.split('t')[1],\n          number: fetchedData[t][0]['number']\n        });\n      }\n    }\n  }\n\n  return blocks;\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/token/hooks.ts"],"names":["useEffect","client","blockClient","GET_TOKEN_DAY_DATAS","GET_BLOCKS","PRICES_BY_BLOCK","useDispatch","useSelector","updateTokenWeeklyPriceChartData","updateTokenPriceChartData","splitQuery","dayjs","utc","extend","useAllTokenWeeklyPriceChartData","allTokenCharts","state","token","weekly","useAllTokenPricesChartData","tokenPrices","useTokenWeeklyChartData","tokenAddress","data1","chartData","dispatch","checkForChartData","data","getTokenWeeklyChartData","address","result","query","variables","fetchPolicy","tokenDayDatas","e","console","log","sort","a","b","parseInt","date","useTokenPriceData","timeWindow","interval","type","currentTime","startTime","startOf","unix","subtract","fetch","getIntervalTokenData","undefined","to","utcEndTime","time","timestamps","push","length","blocks","getBlocksFromTimestamps","values","row","timestamp","split","derivedETH","parseFloat","ethPrice","priceUSD","formattedHistory","i","skipCount","fetchedData","t","number"],"mappings":"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","sourcesContent":["import { useEffect } from 'react'\nimport { client, blockClient } from '../../apollo/client'\nimport { GET_TOKEN_DAY_DATAS } from '../../apollo/tokenDayDatas'\nimport { GET_BLOCKS, PRICES_BY_BLOCK } from '../../apollo/block'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { AppDispatch, AppState } from '../index'\nimport { updateTokenWeeklyPriceChartData, updateTokenPriceChartData } from 'src/state/token/actions'\nimport { splitQuery } from 'src/utils/query'\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\nimport { ChartState, WeeklyState } from './reducer'\n\ndayjs.extend(utc)\n\nexport function useAllTokenWeeklyPriceChartData(): WeeklyState | undefined {\n  const allTokenCharts = useSelector<AppState, AppState['token']['weekly']>(state => state?.token?.weekly || {})\n\n  return allTokenCharts\n}\n\nexport function useAllTokenPricesChartData(): ChartState | undefined {\n  const allTokenCharts = useSelector<AppState, AppState['token']['tokenPrices']>(\n    state => state?.token?.tokenPrices || {}\n  )\n\n  return allTokenCharts\n}\n\nexport function useTokenWeeklyChartData(tokenAddress: string) {\n  const data1 = useAllTokenWeeklyPriceChartData()\n\n  const chartData = data1?.[tokenAddress]\n\n  const dispatch = useDispatch<AppDispatch>()\n\n  useEffect(() => {\n    async function checkForChartData() {\n      if (!chartData) {\n        const data = await getTokenWeeklyChartData(tokenAddress)\n\n        dispatch(updateTokenWeeklyPriceChartData({ address: tokenAddress, chartData: data }))\n      }\n    }\n    checkForChartData()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [chartData, tokenAddress])\n  return chartData\n}\n\nconst getTokenWeeklyChartData = async (tokenAddress: string) => {\n  let data = [] as Array<{ id: string; priceUSD: number; date: string }>\n\n  try {\n    const result = await client.query({\n      query: GET_TOKEN_DAY_DATAS,\n      variables: {\n        token: tokenAddress\n      },\n      fetchPolicy: 'cache-first'\n    })\n\n    data = result?.data?.tokenDayDatas\n  } catch (e) {\n    console.log(e)\n  }\n  data = data.sort((a, b) => (parseInt(a.date) > parseInt(b.date) ? 1 : -1))\n  return data\n}\n\nexport function useTokenPriceData(tokenAddress: string, timeWindow: string, interval = 3600, type = 'ALL') {\n  const data1 = useAllTokenPricesChartData()\n\n  const chartData = data1?.[tokenAddress]\n\n  const dispatch = useDispatch<AppDispatch>()\n\n  useEffect(() => {\n    const currentTime = dayjs?.utc()\n\n    // February 8th 2021 - Pangolin Factory is created\n    const startTime =\n      type === 'ALL'\n        ? dayjs('2021-02-11')\n            .startOf('hour')\n            .unix()\n        : currentTime\n            .subtract(1, timeWindow)\n            .startOf('hour')\n            .unix()\n\n    async function fetch() {\n      const data = await getIntervalTokenData(tokenAddress, startTime, undefined, interval)\n\n      dispatch(updateTokenPriceChartData({ address: tokenAddress, chartData: data }))\n    }\n\n    fetch()\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [interval, timeWindow, tokenAddress])\n\n  return chartData\n}\n\nexport const getIntervalTokenData = async (\n  tokenAddress: string,\n  startTime: number,\n  to = dayjs.utc().unix(),\n  interval = 3600 * 24\n) => {\n  const utcEndTime = to\n  let time = startTime\n\n  // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n\n  const timestamps = [] as Array<number>\n  while (time < utcEndTime) {\n    timestamps.push(time)\n    time += interval\n  }\n\n  // backout if invalid timestamp format\n  if (timestamps.length === 0) {\n    return []\n  }\n\n  // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n  let blocks\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100)\n\n    // catch failing case\n    if (!blocks || blocks.length === 0) {\n      return []\n    }\n\n    const result: any = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50)\n\n    // format token ETH price results\n    const values = [] as Array<{ timestamp: string; derivedETH: number; ethPrice: number; priceUSD: any }>\n    for (const row in result) {\n      const timestamp = row.split('t')[1]\n      if (!timestamp) continue\n\n      const derivedETH = parseFloat(result[`t${timestamp}`]?.derivedETH)\n      const ethPrice = parseFloat(result[`b${timestamp}`]?.ethPrice)\n      const priceUSD = ethPrice * derivedETH\n\n      values.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      })\n    }\n\n    const formattedHistory = [] as Array<{ timestamp: string; priceUSD: number }>\n\n    // for each hour, construct the open and close price\n    for (let i = 0; i < values.length - 1; i++) {\n      formattedHistory.push({\n        timestamp: values[i].timestamp,\n        priceUSD: parseFloat(values?.[i].priceUSD)\n      })\n    }\n\n    return formattedHistory\n  } catch (e) {\n    console.log(e)\n    console.log('error fetching blocks')\n    return []\n  }\n}\n\nexport async function getBlocksFromTimestamps(timestamps: Array<number>, skipCount = 500) {\n  if (timestamps?.length === 0) {\n    return []\n  }\n  const fetchedData: any = await splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount)\n  const blocks = []\n  if (fetchedData) {\n    for (const t in fetchedData) {\n      if (fetchedData[t].length > 0) {\n        blocks.push({\n          timestamp: t.split('t')[1],\n          number: fetchedData[t][0]['number']\n        })\n      }\n    }\n  }\n\n  return blocks\n}\n"]},"metadata":{},"sourceType":"module"}