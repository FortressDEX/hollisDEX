{"ast":null,"code":"import { currencyEquals, CAVAX, WAVAX, ChainId } from '@pangolindex/sdk';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useActiveWeb3React } from './index';\nimport { useWETHContract } from './useContract';\nimport { useChainId } from 'src/hooks';\nexport let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, inputCurrency); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  const inputAmount = useMemo(() => tryParseAmount(chainId, typedValue, inputCurrency), [chainId, inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  const NETWORK_CURRENCY = {\n    [ChainId.FUJI]: 'AVAX',\n    [ChainId.AVALANCHE]: 'AVAX',\n    [ChainId.WAGMI]: 'WGM'\n  };\n  const NETWORK_WRAPPED_CURRENCY = {\n    [ChainId.FUJI]: 'WAVAX',\n    [ChainId.AVALANCHE]: 'WAVAX',\n    [ChainId.WAGMI]: 'wWAGMI'\n  };\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (inputCurrency === CAVAX[chainId] && currencyEquals(WAVAX[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${inputAmount.toSignificant(6)} ${NETWORK_CURRENCY[chainId]} to ${NETWORK_WRAPPED_CURRENCY[chainId]}`\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : `Insufficient ${NETWORK_CURRENCY[chainId]} balance`\n      };\n    } else if (currencyEquals(WAVAX[chainId], inputCurrency) && outputCurrency === CAVAX[chainId]) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${inputAmount.toSignificant(6)} ${NETWORK_WRAPPED_CURRENCY[chainId]} to ${NETWORK_CURRENCY[chainId]}`\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : `Insufficient ${NETWORK_WRAPPED_CURRENCY[chainId]} balance`\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction, NETWORK_WRAPPED_CURRENCY, NETWORK_CURRENCY]);\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/hooks/useWrapCallback.ts"],"names":["currencyEquals","CAVAX","WAVAX","ChainId","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWETHContract","useChainId","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","account","chainId","wethContract","balance","undefined","inputAmount","addTransaction","NETWORK_CURRENCY","FUJI","AVALANCHE","WAGMI","NETWORK_WRAPPED_CURRENCY","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"mappings":"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","sourcesContent":["import { Currency, currencyEquals, CAVAX, WAVAX, ChainId } from '@pangolindex/sdk'\nimport { useMemo } from 'react'\nimport { tryParseAmount } from '../state/swap/hooks'\nimport { useTransactionAdder } from '../state/transactions/hooks'\nimport { useCurrencyBalance } from '../state/wallet/hooks'\nimport { useActiveWeb3React } from './index'\nimport { useWETHContract } from './useContract'\nimport { useChainId } from 'src/hooks'\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  typedValue: string | undefined\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n  const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(chainId, account ?? undefined, inputCurrency)\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(chainId, typedValue, inputCurrency), [\n    chainId,\n    inputCurrency,\n    typedValue\n  ])\n  const addTransaction = useTransactionAdder()\n\n  const NETWORK_CURRENCY: { [chainId in ChainId]?: string } = {\n    [ChainId.FUJI]: 'AVAX',\n    [ChainId.AVALANCHE]: 'AVAX',\n    [ChainId.WAGMI]: 'WGM'\n  }\n\n  const NETWORK_WRAPPED_CURRENCY: { [chainId in ChainId]?: string } = {\n    [ChainId.FUJI]: 'WAVAX',\n    [ChainId.AVALANCHE]: 'WAVAX',\n    [ChainId.WAGMI]: 'wWAGMI'\n  }\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\n\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\n\n    if (inputCurrency === CAVAX[chainId] && currencyEquals(WAVAX[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` })\n                  addTransaction(txReceipt, {\n                    summary: `Wrap ${inputAmount.toSignificant(6)} ${NETWORK_CURRENCY[chainId]} to ${\n                      NETWORK_WRAPPED_CURRENCY[chainId]\n                    }`\n                  })\n                } catch (error) {\n                  console.error('Could not deposit', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : `Insufficient ${NETWORK_CURRENCY[chainId]} balance`\n      }\n    } else if (currencyEquals(WAVAX[chainId], inputCurrency) && outputCurrency === CAVAX[chainId]) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`)\n                  addTransaction(txReceipt, {\n                    summary: `Unwrap ${inputAmount.toSignificant(6)} ${NETWORK_WRAPPED_CURRENCY[chainId]} to ${\n                      NETWORK_CURRENCY[chainId]\n                    }`\n                  })\n                } catch (error) {\n                  console.error('Could not withdraw', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance ? undefined : `Insufficient ${NETWORK_WRAPPED_CURRENCY[chainId]} balance`\n      }\n    } else {\n      return NOT_APPLICABLE\n    }\n  }, [\n    wethContract,\n    chainId,\n    inputCurrency,\n    outputCurrency,\n    inputAmount,\n    balance,\n    addTransaction,\n    NETWORK_WRAPPED_CURRENCY,\n    NETWORK_CURRENCY\n  ])\n}\n"]},"metadata":{},"sourceType":"module"}