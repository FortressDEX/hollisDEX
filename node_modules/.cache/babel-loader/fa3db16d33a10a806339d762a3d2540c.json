{"ast":null,"code":"import { Version } from '../../hooks/useToggledVersion';\nimport { parseUnits } from '@ethersproject/units';\nimport { CurrencyAmount, CAVAX, JSBI, Token, TokenAmount, FACTORY_ADDRESS, ChainId } from '@pangolindex/sdk';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useCurrency } from '../../hooks/Tokens';\nimport { useTradeExactIn, useTradeExactOut } from '../../hooks/Trades';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport { isAddress } from '../../utils';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nimport useToggledVersion from '../../hooks/useToggledVersion';\nimport { useUserSlippageTolerance } from '../user/hooks';\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices';\nimport { ROUTER_ADDRESS, SWAP_DEFAULT_CURRENCY } from '../../constants';\nimport { useTranslation } from 'react-i18next';\nimport { useChainId } from 'src/hooks';\nexport function useSwapState() {\n  return useSelector(state => state.swap);\n}\nexport function useSwapActionHandlers(chainId) {\n  const dispatch = useDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : chainId && currency === CAVAX[chainId] ? 'AVAX' : ''\n    }));\n  }, [chainId, dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n} // try to parse a user entered amount for a given token\n\nexport function tryParseAmount(chainId, value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n\n    if (typedValueParsed !== '0') {\n      return currency instanceof Token ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed)) : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed), chainId);\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  } // necessary for all paths to return a value\n\n\n  return undefined;\n}\nconst BAD_RECIPIENT_ADDRESSES = [FACTORY_ADDRESS[ChainId.AVALANCHE], // v2 factory\nROUTER_ADDRESS[ChainId.AVALANCHE] // v2 router 02\n];\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\n\nfunction involvesAddress(trade, checksummedAddress) {\n  return trade.route.path.some(token => token.address === checksummedAddress) || trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress);\n} // from the current swap inputs, compute the best trade and return it.\n\n\nexport function useDerivedSwapInfo() {\n  var _ref, _ref2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const chainId = useChainId();\n  const {\n    t\n  } = useTranslation();\n  const toggledVersion = useToggledVersion();\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    },\n    recipient\n  } = useSwapState();\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientAddress = isAddress(recipient);\n  const to = (_ref = recipientAddress ? recipientAddress : account) !== null && _ref !== void 0 ? _ref : null;\n  const relevantTokenBalances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined]);\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = tryParseAmount(chainId, typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  const bestTradeExactIn = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);\n  const bestTradeExactOut = useTradeExactOut(inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, !isExactIn ? parsedAmount : undefined);\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  };\n  const currencies = {\n    [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,\n    [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined\n  }; // get link to trade on v1, if a better rate exists\n\n  const v1Trade = undefined;\n  let inputError;\n\n  if (!account) {\n    inputError = t('swapHooks.connectWallet');\n  }\n\n  if (!parsedAmount) {\n    var _inputError;\n\n    inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError : t('swapHooks.enterAmount');\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError2;\n\n    inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 : t('swapHooks.selectToken');\n  }\n\n  const formattedTo = isAddress(to);\n\n  if (!to || !formattedTo) {\n    var _inputError3;\n\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 : t('swapHooks.enterRecipient');\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 || bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo) || bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo)) {\n      var _inputError4;\n\n      inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 : t('swapHooks.invalidRecipient');\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance();\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage, chainId);\n  const slippageAdjustedAmountsV1 = v1Trade && allowedSlippage && computeSlippageAdjustedAmounts(v1Trade, allowedSlippage, chainId); // compare input balance to max input based on version\n\n  const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], toggledVersion === Version.v1 ? slippageAdjustedAmountsV1 ? slippageAdjustedAmountsV1[Field.INPUT] : null : slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null];\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = t('swapHooks.insufficient') + amountIn.currency.symbol + t('swapHooks.balance');\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,\n    inputError,\n    v1Trade\n  };\n}\n\nfunction parseCurrencyFromURLParameter(urlParam) {\n  var _AVAX;\n\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'AVAX') return 'AVAX';\n    if (valid === false) return 'AVAX';\n  }\n\n  return (_AVAX = 'AVAX') !== null && _AVAX !== void 0 ? _AVAX : '';\n}\n\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\n\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs) {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n} // updates the swap state to use the defaults for a given network\n\nexport function useDefaultsFromURLSearch() {\n  const chainId = useChainId();\n  const dispatch = useDispatch();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState();\n  useEffect(() => {\n    var _SWAP_DEFAULT_CURRENC, _SWAP_DEFAULT_CURRENC2;\n\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n    dispatch(replaceSwapState({\n      typedValue: parsed.typedValue,\n      field: parsed.independentField,\n      inputCurrencyId: parsed[Field.INPUT].currencyId || ((_SWAP_DEFAULT_CURRENC = SWAP_DEFAULT_CURRENCY[chainId]) === null || _SWAP_DEFAULT_CURRENC === void 0 ? void 0 : _SWAP_DEFAULT_CURRENC.inputCurrency),\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId || ((_SWAP_DEFAULT_CURRENC2 = SWAP_DEFAULT_CURRENCY[chainId]) === null || _SWAP_DEFAULT_CURRENC2 === void 0 ? void 0 : _SWAP_DEFAULT_CURRENC2.outputCurrency),\n      recipient: parsed.recipient\n    }));\n    setResult({\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n  return result;\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/swap/hooks.ts"],"names":["Version","parseUnits","CurrencyAmount","CAVAX","JSBI","Token","TokenAmount","FACTORY_ADDRESS","ChainId","useCallback","useEffect","useState","useDispatch","useSelector","useActiveWeb3React","useCurrency","useTradeExactIn","useTradeExactOut","useParsedQueryString","isAddress","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useToggledVersion","useUserSlippageTolerance","computeSlippageAdjustedAmounts","ROUTER_ADDRESS","SWAP_DEFAULT_CURRENCY","useTranslation","useChainId","useSwapState","state","swap","useSwapActionHandlers","chainId","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","ether","error","console","debug","BAD_RECIPIENT_ADDRESSES","AVALANCHE","involvesAddress","trade","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","account","t","toggledVersion","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientAddress","to","relevantTokenBalances","isExactIn","parsedAmount","bestTradeExactIn","bestTradeExactOut","v2Trade","currencyBalances","currencies","v1Trade","inputError","formattedTo","indexOf","allowedSlippage","slippageAdjustedAmounts","slippageAdjustedAmountsV1","balanceIn","amountIn","v1","lessThan","symbol","parseCurrencyFromURLParameter","urlParam","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","result","setResult","parsed"],"mappings":"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","sourcesContent":["import { Version } from '../../hooks/useToggledVersion'\nimport { parseUnits } from '@ethersproject/units'\nimport {\n  Currency,\n  CurrencyAmount,\n  CAVAX,\n  JSBI,\n  Token,\n  TokenAmount,\n  Trade,\n  FACTORY_ADDRESS,\n  ChainId\n} from '@pangolindex/sdk'\nimport { ParsedQs } from 'qs'\nimport { useCallback, useEffect, useState } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useCurrency } from '../../hooks/Tokens'\nimport { useTradeExactIn, useTradeExactOut } from '../../hooks/Trades'\nimport useParsedQueryString from '../../hooks/useParsedQueryString'\nimport { isAddress } from '../../utils'\nimport { AppDispatch, AppState } from '../index'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\nimport useToggledVersion from '../../hooks/useToggledVersion'\nimport { useUserSlippageTolerance } from '../user/hooks'\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices'\nimport { ROUTER_ADDRESS, SWAP_DEFAULT_CURRENCY } from '../../constants'\nimport { useTranslation } from 'react-i18next'\nimport { useChainId } from 'src/hooks'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>(state => state.swap)\n}\n\nexport function useSwapActionHandlers(\n  chainId: ChainId\n): {\n  onCurrencySelection: (field: Field, currency: Currency) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId:\n            currency instanceof Token ? currency.address : chainId && currency === CAVAX[chainId] ? 'AVAX' : ''\n        })\n      )\n    },\n    [chainId, dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(chainId: ChainId, value?: string, currency?: Currency): CurrencyAmount | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n    if (typedValueParsed !== '0') {\n      return currency instanceof Token\n        ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed))\n        : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed), chainId)\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return undefined\n}\n\nconst BAD_RECIPIENT_ADDRESSES: string[] = [\n  FACTORY_ADDRESS[ChainId.AVALANCHE], // v2 factory\n  ROUTER_ADDRESS[ChainId.AVALANCHE] // v2 router 02\n]\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some(token => token.address === checksummedAddress) ||\n    trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress)\n  )\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount }\n  parsedAmount: CurrencyAmount | undefined\n  v2Trade: Trade | undefined\n  inputError?: string\n  v1Trade: Trade | undefined\n} {\n  const { account } = useActiveWeb3React()\n  const chainId = useChainId()\n\n  const { t } = useTranslation()\n\n  const toggledVersion = useToggledVersion()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientAddress = isAddress(recipient)\n  const to: string | null = (recipientAddress ? recipientAddress : account) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(chainId, account ?? undefined, [\n    inputCurrency ?? undefined,\n    outputCurrency ?? undefined\n  ])\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = tryParseAmount(chainId, typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined)\n\n  const bestTradeExactIn = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const bestTradeExactOut = useTradeExactOut(inputCurrency ?? undefined, !isExactIn ? parsedAmount : undefined)\n\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut\n\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  }\n\n  const currencies: { [field in Field]?: Currency } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined\n  }\n\n  // get link to trade on v1, if a better rate exists\n  const v1Trade = undefined\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = t('swapHooks.connectWallet')\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? t('swapHooks.enterAmount')\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? t('swapHooks.selectToken')\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? t('swapHooks.enterRecipient')\n  } else {\n    if (\n      BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n      (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||\n      (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))\n    ) {\n      inputError = inputError ?? t('swapHooks.invalidRecipient')\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const slippageAdjustedAmounts =\n    v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage, chainId)\n\n  const slippageAdjustedAmountsV1 =\n    v1Trade && allowedSlippage && computeSlippageAdjustedAmounts(v1Trade, allowedSlippage, chainId)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    toggledVersion === Version.v1\n      ? slippageAdjustedAmountsV1\n        ? slippageAdjustedAmountsV1[Field.INPUT]\n        : null\n      : slippageAdjustedAmounts\n      ? slippageAdjustedAmounts[Field.INPUT]\n      : null\n  ]\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = t('swapHooks.insufficient') + amountIn.currency.symbol + t('swapHooks.balance')\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    inputError,\n    v1Trade\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'AVAX') return 'AVAX'\n    if (valid === false) return 'AVAX'\n  }\n  return 'AVAX' ?? ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const chainId = useChainId()\n\n  const dispatch = useDispatch<AppDispatch>()\n  const parsedQs = useParsedQueryString()\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >()\n\n  useEffect(() => {\n    if (!chainId) return\n    const parsed = queryParametersToSwapState(parsedQs)\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId || SWAP_DEFAULT_CURRENCY[chainId]?.inputCurrency,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId || SWAP_DEFAULT_CURRENCY[chainId]?.outputCurrency,\n        recipient: parsed.recipient\n      })\n    )\n\n    setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId })\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId])\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}