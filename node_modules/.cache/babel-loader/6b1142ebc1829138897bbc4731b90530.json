{"ast":null,"code":"import { useEffect } from 'react';\nimport { client } from '../../apollo/client';\nimport { HOURLY_PAIR_RATES } from '../../apollo/pair';\nimport { PRICES_BY_BLOCK } from '../../apollo/block';\nimport { splitQuery } from 'src/utils/query';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { updatePairChartData, updatePairTokensChartData } from 'src/state/pair/actions';\nimport { getBlocksFromTimestamps } from 'src/state/token/hooks';\ndayjs.extend(utc);\nexport function useAllPairChartData() {\n  const allTokenCharts = useSelector(state => {\n    var _state$pair;\n\n    return (state === null || state === void 0 ? void 0 : (_state$pair = state.pair) === null || _state$pair === void 0 ? void 0 : _state$pair.pairData) || {};\n  });\n  return allTokenCharts;\n}\n/* eslint-disable prefer-const */\n\nexport function usePairHourlyRateData(pairAddress, timeWindow) {\n  let interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3600;\n  let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'ALL';\n  const data1 = useAllPairChartData();\n  const chartData = data1 === null || data1 === void 0 ? void 0 : data1[pairAddress];\n  const dispatch = useDispatch();\n  useEffect(() => {\n    const currentTime = dayjs.utc(); // February 8th 2021 - Pangolin Factory is created\n\n    const startTime = type === 'ALL' ? dayjs('2021-02-11').startOf('hour').unix() : currentTime.subtract(1, timeWindow).startOf('hour').unix();\n\n    async function fetch() {\n      let data = await getPairHourlyRateData(pairAddress, startTime, undefined, interval);\n      dispatch(updatePairChartData({\n        address: pairAddress,\n        chartData: data\n      }));\n    }\n\n    fetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [interval, timeWindow, pairAddress]);\n  return chartData;\n}\nexport const getPairHourlyRateData = async function (pairAddress, startTime) {\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : dayjs.utc().unix();\n  let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3600 * 24;\n\n  try {\n    var _blocks;\n\n    const utcEndTime = to;\n    let time = startTime; // create an array of hour start times until we reach current hour\n\n    const timestamps = [];\n\n    while (time < utcEndTime) {\n      timestamps.push(time);\n      time += interval;\n    } // backout if invalid timestamp format\n\n\n    if (timestamps.length === 0) {\n      return [];\n    } // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n\n\n    let blocks;\n    blocks = await getBlocksFromTimestamps(timestamps, 100); // catch failing case\n\n    if (!blocks || ((_blocks = blocks) === null || _blocks === void 0 ? void 0 : _blocks.length) === 0) {\n      return [];\n    }\n\n    const result = await splitQuery(HOURLY_PAIR_RATES, client, [pairAddress], blocks, 100); // format token ETH price results\n\n    let values = [];\n\n    for (let row in result) {\n      let timestamp = row.split('t')[1];\n      const year = dayjs.utc(dayjs.unix(Number(timestamp))).get('year');\n      const month = dayjs.utc(dayjs.unix(Number(timestamp))).get('month') + 1;\n      const day = dayjs.utc(dayjs.unix(Number(timestamp))).get('date');\n\n      if (timestamp) {\n        var _result$row, _result$row2;\n\n        values.push({\n          timestamp: {\n            year: year,\n            month: month,\n            day: day\n          },\n          rate0: parseFloat((_result$row = result[row]) === null || _result$row === void 0 ? void 0 : _result$row.token0Price) || 0,\n          rate1: parseFloat((_result$row2 = result[row]) === null || _result$row2 === void 0 ? void 0 : _result$row2.token1Price) || 0\n        });\n      }\n    }\n\n    let formattedHistoryRate0 = [];\n    let formattedHistoryRate1 = []; // for each hour, construct the open and close price\n\n    for (let i = 0; i < values.length - 1; i++) {\n      if (values[i].rate0 !== 0) {\n        formattedHistoryRate0.push({\n          time: values[i].timestamp,\n          open: parseFloat(values[i].rate0 || 0),\n          close: parseFloat(values[i + 1].rate0 || 0),\n          low: parseFloat(values[i].rate0 || 0),\n          high: parseFloat(values[i + 1].rate0 || 0)\n        });\n      }\n\n      if (values[i].rate1 !== 0) {\n        formattedHistoryRate1.push({\n          time: values[i].timestamp,\n          open: parseFloat(values[i].rate1 || 0),\n          close: parseFloat(values[i + 1].rate1 || 0),\n          low: parseFloat(values[i].rate1 || 0),\n          high: parseFloat(values[i + 1].rate1 || 0)\n        });\n      }\n    }\n\n    return [formattedHistoryRate0, formattedHistoryRate1];\n  } catch (e) {\n    console.log(e);\n    return [[], []];\n  }\n};\nexport function useAllPairTokensChartData() {\n  const allTokenCharts = useSelector(state => {\n    var _state$pair2;\n\n    return (state === null || state === void 0 ? void 0 : (_state$pair2 = state.pair) === null || _state$pair2 === void 0 ? void 0 : _state$pair2.tokenPairData) || {};\n  });\n  return allTokenCharts;\n}\nexport function useHourlyPairTokensChartData(tokenAddress0, tokenAddress1, timeWindow) {\n  let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3600;\n  let type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ALL';\n  tokenAddress0 = (tokenAddress0 || '').toLowerCase();\n  tokenAddress1 = (tokenAddress1 || '').toLowerCase();\n  const pairAddress = `${tokenAddress0}_${tokenAddress1}`;\n  const data1 = useAllPairTokensChartData();\n  const chartData = data1 === null || data1 === void 0 ? void 0 : data1[pairAddress];\n  const dispatch = useDispatch();\n  useEffect(() => {\n    const currentTime = dayjs.utc(); // February 8th 2021 - Pangolin Factory is created\n\n    const startTime = type === 'ALL' ? dayjs('2021-02-11').startOf('hour').unix() : currentTime.subtract(1, timeWindow).startOf('hour').unix();\n\n    async function fetch() {\n      let data = await getHourlyPairTokensChartData(tokenAddress0, tokenAddress1, startTime, undefined, interval);\n      dispatch(updatePairTokensChartData({\n        address: pairAddress,\n        chartData: data\n      }));\n    }\n\n    if (tokenAddress0 && tokenAddress1) {\n      fetch();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [interval, timeWindow, pairAddress]);\n  return chartData;\n}\nexport const getHourlyPairTokensChartData = async function (tokenAddress0, tokenAddress1, startTime) {\n  let to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : dayjs.utc().unix();\n  let interval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 3600 * 24;\n  const utcEndTime = to;\n  let time = startTime; // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n\n  const timestamps = [];\n\n  while (time < utcEndTime) {\n    timestamps.push(time);\n    time += interval;\n  } // backout if invalid timestamp format\n\n\n  if (timestamps.length === 0) {\n    return [];\n  } // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n\n\n  let blocks;\n\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100); // catch failing case\n\n    if (!blocks || blocks.length === 0) {\n      return [];\n    }\n\n    let result0 = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress0], blocks, 50); // format token ETH price results\n\n    let values0 = [];\n\n    for (let row in result0) {\n      var _result0$, _result0$2;\n\n      let timestamp = row.split('t')[1];\n      if (!timestamp) continue;\n      const derivedETH = parseFloat((_result0$ = result0[`t${timestamp}`]) === null || _result0$ === void 0 ? void 0 : _result0$.derivedETH);\n      const ethPrice = parseFloat((_result0$2 = result0[`b${timestamp}`]) === null || _result0$2 === void 0 ? void 0 : _result0$2.ethPrice);\n      const priceUSD = ethPrice * derivedETH;\n      values0.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      });\n    }\n\n    let result1 = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress1], blocks, 50); // format token ETH price results\n\n    let values1 = [];\n\n    for (let row in result1) {\n      var _result1$, _result1$2;\n\n      let timestamp = row.split('t')[1];\n      if (!timestamp) continue;\n      const derivedETH = parseFloat((_result1$ = result1[`t${timestamp}`]) === null || _result1$ === void 0 ? void 0 : _result1$.derivedETH);\n      const ethPrice = parseFloat((_result1$2 = result1[`b${timestamp}`]) === null || _result1$2 === void 0 ? void 0 : _result1$2.ethPrice);\n      const priceUSD = ethPrice * derivedETH;\n      values1.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      });\n    } // we need to take that array which length small and map on that one\n\n\n    const mapOn = (values0 || []).length >= (values1 || []).length ? 'map1' : 'map0';\n    let finalValues = [];\n\n    if (mapOn === 'map1') {\n      for (let row in values1) {\n        var _values1$row;\n\n        let timestamp = (_values1$row = values1[row]) === null || _values1$row === void 0 ? void 0 : _values1$row.timestamp;\n        let dayjsTimestamp = dayjs.utc(dayjs.unix(Number(timestamp)));\n        const year = dayjsTimestamp.get('year');\n        const month = dayjsTimestamp.get('month') + 1;\n        const day = dayjsTimestamp.get('date');\n        let v0 = values0.find(data => (data === null || data === void 0 ? void 0 : data.timestamp) === timestamp);\n        let v1 = values1.find(data => (data === null || data === void 0 ? void 0 : data.timestamp) === timestamp);\n        const inputUsdcPrice = parseFloat(v1 === null || v1 === void 0 ? void 0 : v1.priceUSD) || 0;\n        const outputUsdcPrice = parseFloat(v0 === null || v0 === void 0 ? void 0 : v0.priceUSD) || 0;\n        const rate0UsdcPrice = inputUsdcPrice && outputUsdcPrice ? Number(inputUsdcPrice.toFixed()) / Number(outputUsdcPrice.toFixed()) : 0;\n        const rate1UsdcPrice = inputUsdcPrice && outputUsdcPrice ? Number(outputUsdcPrice.toFixed()) / Number(inputUsdcPrice.toFixed()) : 0;\n\n        if (timestamp) {\n          finalValues.push({\n            timestamp: {\n              year: year,\n              month: month,\n              day: day\n            },\n            rate0: parseFloat(rate0UsdcPrice.toFixed(4)) || 0,\n            rate1: parseFloat(rate1UsdcPrice.toFixed(4)) || 0\n          });\n        }\n      }\n    } else {\n      for (let row1 in values0) {\n        var _values0$row;\n\n        let timestamp = (_values0$row = values0[row1]) === null || _values0$row === void 0 ? void 0 : _values0$row.timestamp;\n        let dayjsTimestamp = dayjs.utc(dayjs.unix(Number(timestamp)));\n        const year = dayjsTimestamp.get('year');\n        const month = dayjsTimestamp.get('month') + 1;\n        const day = dayjsTimestamp.get('date');\n        let v0 = values0.find(data => (data === null || data === void 0 ? void 0 : data.timestamp) === timestamp);\n        let v1 = values1.find(data => (data === null || data === void 0 ? void 0 : data.timestamp) === timestamp);\n        const inputUsdcPrice = parseFloat(v0 === null || v0 === void 0 ? void 0 : v0.priceUSD) || 0;\n        const outputUsdcPrice = parseFloat(v1 === null || v1 === void 0 ? void 0 : v1.priceUSD) || 0;\n        const rate0UsdcPrice = inputUsdcPrice && outputUsdcPrice ? Number(inputUsdcPrice.toFixed()) / Number(outputUsdcPrice.toFixed()) : 0;\n        const rate1UsdcPrice = inputUsdcPrice && outputUsdcPrice ? Number(outputUsdcPrice.toFixed()) / Number(inputUsdcPrice.toFixed()) : 0;\n\n        if (timestamp) {\n          finalValues.push({\n            timestamp: {\n              year: year,\n              month: month,\n              day: day\n            },\n            rate0: parseFloat(rate0UsdcPrice.toFixed(4)) || 0,\n            rate1: parseFloat(rate1UsdcPrice.toFixed(4)) || 0\n          });\n        }\n      }\n    }\n\n    let formattedHistoryRate0 = [];\n    let formattedHistoryRate1 = []; // for each hour, construct the open and close price\n\n    for (let i = 0; i < finalValues.length - 1; i++) {\n      if (finalValues[i].rate0 !== 0) {\n        formattedHistoryRate0.push({\n          time: finalValues[i].timestamp,\n          open: parseFloat(finalValues[i].rate0 || 0),\n          close: parseFloat(finalValues[i + 1].rate0 || 0),\n          low: parseFloat(finalValues[i].rate0 || 0),\n          high: parseFloat(finalValues[i + 1].rate0 || 0)\n        });\n      }\n\n      if (finalValues[i].rate1 !== 0) {\n        formattedHistoryRate1.push({\n          time: finalValues[i].timestamp,\n          open: parseFloat(finalValues[i].rate1 || 0),\n          close: parseFloat(finalValues[i + 1].rate1 || 0),\n          low: parseFloat(finalValues[i].rate1 || 0),\n          high: parseFloat(finalValues[i + 1].rate1 || 0)\n        });\n      }\n    }\n\n    return [formattedHistoryRate0, formattedHistoryRate1];\n  } catch (e) {\n    console.log(e);\n    console.log('error fetching blocks');\n    return [];\n  }\n};","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/pair/hooks.ts"],"names":["useEffect","client","HOURLY_PAIR_RATES","PRICES_BY_BLOCK","splitQuery","dayjs","utc","useDispatch","useSelector","updatePairChartData","updatePairTokensChartData","getBlocksFromTimestamps","extend","useAllPairChartData","allTokenCharts","state","pair","pairData","usePairHourlyRateData","pairAddress","timeWindow","interval","type","data1","chartData","dispatch","currentTime","startTime","startOf","unix","subtract","fetch","data","getPairHourlyRateData","undefined","address","to","utcEndTime","time","timestamps","push","length","blocks","result","values","row","timestamp","split","year","Number","get","month","day","rate0","parseFloat","token0Price","rate1","token1Price","formattedHistoryRate0","formattedHistoryRate1","i","open","close","low","high","e","console","log","useAllPairTokensChartData","tokenPairData","useHourlyPairTokensChartData","tokenAddress0","tokenAddress1","toLowerCase","getHourlyPairTokensChartData","result0","values0","derivedETH","ethPrice","priceUSD","result1","values1","mapOn","finalValues","dayjsTimestamp","v0","find","v1","inputUsdcPrice","outputUsdcPrice","rate0UsdcPrice","toFixed","rate1UsdcPrice","row1"],"mappings":"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","sourcesContent":["import { useEffect } from 'react'\nimport { client } from '../../apollo/client'\nimport { HOURLY_PAIR_RATES } from '../../apollo/pair'\nimport { PRICES_BY_BLOCK } from '../../apollo/block'\nimport { splitQuery } from 'src/utils/query'\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { AppDispatch, AppState } from '../index'\nimport { updatePairChartData, updatePairTokensChartData } from 'src/state/pair/actions'\nimport { getBlocksFromTimestamps } from 'src/state/token/hooks'\nimport { ChartState } from './reducer'\n\ndayjs.extend(utc)\n\nexport function useAllPairChartData(): ChartState | undefined {\n  const allTokenCharts = useSelector<AppState, AppState['pair']['pairData']>(state => state?.pair?.pairData || {})\n\n  return allTokenCharts\n}\n/* eslint-disable prefer-const */\nexport function usePairHourlyRateData(pairAddress: string, timeWindow: string, interval = 3600, type = 'ALL') {\n  const data1 = useAllPairChartData()\n\n  const chartData = data1?.[pairAddress]\n\n  const dispatch = useDispatch<AppDispatch>()\n\n  useEffect(() => {\n    const currentTime = dayjs.utc()\n\n    // February 8th 2021 - Pangolin Factory is created\n    const startTime =\n      type === 'ALL'\n        ? dayjs('2021-02-11')\n            .startOf('hour')\n            .unix()\n        : currentTime\n            .subtract(1, timeWindow)\n            .startOf('hour')\n            .unix()\n\n    async function fetch() {\n      let data = await getPairHourlyRateData(pairAddress, startTime, undefined, interval)\n\n      dispatch(updatePairChartData({ address: pairAddress, chartData: data }))\n    }\n\n    fetch()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [interval, timeWindow, pairAddress])\n\n  return chartData\n}\n\nexport const getPairHourlyRateData = async (\n  pairAddress: string,\n  startTime: number,\n  to = dayjs.utc().unix(),\n  interval = 3600 * 24\n) => {\n  try {\n    const utcEndTime = to\n    let time = startTime\n\n    // create an array of hour start times until we reach current hour\n    const timestamps = []\n\n    while (time < utcEndTime) {\n      timestamps.push(time)\n      time += interval\n    }\n\n    // backout if invalid timestamp format\n    if (timestamps.length === 0) {\n      return []\n    }\n\n    // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n    let blocks\n\n    blocks = await getBlocksFromTimestamps(timestamps, 100)\n\n    // catch failing case\n    if (!blocks || blocks?.length === 0) {\n      return []\n    }\n\n    const result: any = await splitQuery(HOURLY_PAIR_RATES, client, [pairAddress], blocks, 100)\n\n    // format token ETH price results\n    let values = [] as any\n    for (let row in result) {\n      let timestamp = row.split('t')[1]\n\n      const year = dayjs.utc(dayjs.unix(Number(timestamp))).get('year')\n      const month = dayjs.utc(dayjs.unix(Number(timestamp))).get('month') + 1\n      const day = dayjs.utc(dayjs.unix(Number(timestamp))).get('date')\n\n      if (timestamp) {\n        values.push({\n          timestamp: { year: year, month: month, day: day },\n          rate0: parseFloat(result[row]?.token0Price) || 0,\n          rate1: parseFloat(result[row]?.token1Price) || 0\n        })\n      }\n    }\n\n    let formattedHistoryRate0 = []\n    let formattedHistoryRate1 = []\n\n    // for each hour, construct the open and close price\n    for (let i = 0; i < values.length - 1; i++) {\n      if (values[i].rate0 !== 0) {\n        formattedHistoryRate0.push({\n          time: values[i].timestamp,\n          open: parseFloat(values[i].rate0 || 0),\n          close: parseFloat(values[i + 1].rate0 || 0),\n          low: parseFloat(values[i].rate0 || 0),\n          high: parseFloat(values[i + 1].rate0 || 0)\n        })\n      }\n\n      if (values[i].rate1 !== 0) {\n        formattedHistoryRate1.push({\n          time: values[i].timestamp,\n          open: parseFloat(values[i].rate1 || 0),\n          close: parseFloat(values[i + 1].rate1 || 0),\n          low: parseFloat(values[i].rate1 || 0),\n          high: parseFloat(values[i + 1].rate1 || 0)\n        })\n      }\n    }\n\n    return [formattedHistoryRate0, formattedHistoryRate1]\n  } catch (e) {\n    console.log(e)\n    return [[], []]\n  }\n}\n\nexport function useAllPairTokensChartData(): ChartState | undefined {\n  const allTokenCharts = useSelector<AppState, AppState['pair']['tokenPairData']>(\n    state => state?.pair?.tokenPairData || {}\n  )\n\n  return allTokenCharts\n}\n\nexport function useHourlyPairTokensChartData(\n  tokenAddress0: string,\n  tokenAddress1: string,\n  timeWindow: string,\n  interval = 3600,\n  type = 'ALL'\n) {\n  tokenAddress0 = (tokenAddress0 || '').toLowerCase()\n  tokenAddress1 = (tokenAddress1 || '').toLowerCase()\n  const pairAddress = `${tokenAddress0}_${tokenAddress1}`\n\n  const data1 = useAllPairTokensChartData()\n\n  const chartData = data1?.[pairAddress]\n\n  const dispatch = useDispatch<AppDispatch>()\n\n  useEffect(() => {\n    const currentTime = dayjs.utc()\n\n    // February 8th 2021 - Pangolin Factory is created\n    const startTime =\n      type === 'ALL'\n        ? dayjs('2021-02-11')\n            .startOf('hour')\n            .unix()\n        : currentTime\n            .subtract(1, timeWindow)\n            .startOf('hour')\n            .unix()\n\n    async function fetch() {\n      let data = await getHourlyPairTokensChartData(tokenAddress0, tokenAddress1, startTime, undefined, interval)\n\n      dispatch(updatePairTokensChartData({ address: pairAddress, chartData: data }))\n    }\n\n    if (tokenAddress0 && tokenAddress1) {\n      fetch()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [interval, timeWindow, pairAddress])\n\n  return chartData\n}\n\nexport const getHourlyPairTokensChartData = async (\n  tokenAddress0: string,\n  tokenAddress1: string,\n  startTime: number,\n  to = dayjs.utc().unix(),\n  interval = 3600 * 24\n) => {\n  const utcEndTime = to\n  let time = startTime\n\n  // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n\n  const timestamps = [] as Array<number>\n  while (time < utcEndTime) {\n    timestamps.push(time)\n    time += interval\n  }\n\n  // backout if invalid timestamp format\n  if (timestamps.length === 0) {\n    return []\n  }\n\n  // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n  let blocks\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100)\n\n    // catch failing case\n    if (!blocks || blocks.length === 0) {\n      return []\n    }\n\n    let result0: any = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress0], blocks, 50)\n\n    // format token ETH price results\n    let values0 = [] as Array<{ timestamp: string; derivedETH: number; ethPrice: number; priceUSD: any }>\n    for (let row in result0) {\n      let timestamp = row.split('t')[1]\n      if (!timestamp) continue\n\n      const derivedETH = parseFloat(result0[`t${timestamp}`]?.derivedETH)\n      const ethPrice = parseFloat(result0[`b${timestamp}`]?.ethPrice)\n      const priceUSD = ethPrice * derivedETH\n\n      values0.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      })\n    }\n\n    let result1: any = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress1], blocks, 50)\n\n    // format token ETH price results\n    let values1 = [] as Array<{ timestamp: string; derivedETH: number; ethPrice: number; priceUSD: any }>\n    for (let row in result1) {\n      let timestamp = row.split('t')[1]\n      if (!timestamp) continue\n\n      const derivedETH = parseFloat(result1[`t${timestamp}`]?.derivedETH)\n      const ethPrice = parseFloat(result1[`b${timestamp}`]?.ethPrice)\n      const priceUSD = ethPrice * derivedETH\n\n      values1.push({\n        timestamp,\n        derivedETH,\n        ethPrice,\n        priceUSD\n      })\n    }\n\n    // we need to take that array which length small and map on that one\n    const mapOn = (values0 || []).length >= (values1 || []).length ? 'map1' : 'map0'\n\n    let finalValues = [] as any\n    if (mapOn === 'map1') {\n      for (let row in values1) {\n        let timestamp = values1[row]?.timestamp\n\n        let dayjsTimestamp = dayjs.utc(dayjs.unix(Number(timestamp)))\n\n        const year = dayjsTimestamp.get('year')\n        const month = dayjsTimestamp.get('month') + 1\n        const day = dayjsTimestamp.get('date')\n\n        let v0 = values0.find(data => data?.timestamp === timestamp)\n\n        let v1 = values1.find(data => data?.timestamp === timestamp)\n\n        const inputUsdcPrice = parseFloat(v1?.priceUSD) || 0\n\n        const outputUsdcPrice = parseFloat(v0?.priceUSD) || 0\n\n        const rate0UsdcPrice =\n          inputUsdcPrice && outputUsdcPrice ? Number(inputUsdcPrice.toFixed()) / Number(outputUsdcPrice.toFixed()) : 0\n\n        const rate1UsdcPrice =\n          inputUsdcPrice && outputUsdcPrice ? Number(outputUsdcPrice.toFixed()) / Number(inputUsdcPrice.toFixed()) : 0\n\n        if (timestamp) {\n          finalValues.push({\n            timestamp: { year: year, month: month, day: day },\n            rate0: parseFloat(rate0UsdcPrice.toFixed(4)) || 0,\n            rate1: parseFloat(rate1UsdcPrice.toFixed(4)) || 0\n          })\n        }\n      }\n    } else {\n      for (let row1 in values0) {\n        let timestamp = values0[row1]?.timestamp\n        let dayjsTimestamp = dayjs.utc(dayjs.unix(Number(timestamp)))\n        const year = dayjsTimestamp.get('year')\n        const month = dayjsTimestamp.get('month') + 1\n        const day = dayjsTimestamp.get('date')\n\n        let v0 = values0.find(data => data?.timestamp === timestamp)\n\n        let v1 = values1.find(data => data?.timestamp === timestamp)\n\n        const inputUsdcPrice = parseFloat(v0?.priceUSD) || 0\n\n        const outputUsdcPrice = parseFloat(v1?.priceUSD) || 0\n\n        const rate0UsdcPrice =\n          inputUsdcPrice && outputUsdcPrice ? Number(inputUsdcPrice.toFixed()) / Number(outputUsdcPrice.toFixed()) : 0\n\n        const rate1UsdcPrice =\n          inputUsdcPrice && outputUsdcPrice ? Number(outputUsdcPrice.toFixed()) / Number(inputUsdcPrice.toFixed()) : 0\n\n        if (timestamp) {\n          finalValues.push({\n            timestamp: { year: year, month: month, day: day },\n            rate0: parseFloat(rate0UsdcPrice.toFixed(4)) || 0,\n            rate1: parseFloat(rate1UsdcPrice.toFixed(4)) || 0\n          })\n        }\n      }\n    }\n\n    let formattedHistoryRate0 = []\n    let formattedHistoryRate1 = []\n\n    // for each hour, construct the open and close price\n    for (let i = 0; i < finalValues.length - 1; i++) {\n      if (finalValues[i].rate0 !== 0) {\n        formattedHistoryRate0.push({\n          time: finalValues[i].timestamp,\n          open: parseFloat(finalValues[i].rate0 || 0),\n          close: parseFloat(finalValues[i + 1].rate0 || 0),\n          low: parseFloat(finalValues[i].rate0 || 0),\n          high: parseFloat(finalValues[i + 1].rate0 || 0)\n        })\n      }\n\n      if (finalValues[i].rate1 !== 0) {\n        formattedHistoryRate1.push({\n          time: finalValues[i].timestamp,\n          open: parseFloat(finalValues[i].rate1 || 0),\n          close: parseFloat(finalValues[i + 1].rate1 || 0),\n          low: parseFloat(finalValues[i].rate1 || 0),\n          high: parseFloat(finalValues[i + 1].rate1 || 0)\n        })\n      }\n    }\n\n    return [formattedHistoryRate0, formattedHistoryRate1]\n  } catch (e) {\n    console.log(e)\n    console.log('error fetching blocks')\n    return []\n  }\n}\n"]},"metadata":{},"sourceType":"module"}