{"ast":null,"code":"import { PNG } from 'src/constants/tokens';\nimport { TokenAmount, JSBI } from '@pangolindex/sdk';\nimport { isAddress } from 'ethers/lib/utils';\nimport { useGovernanceContract, usePngContract } from 'src/hooks/useContract';\nimport { useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks';\nimport { useActiveWeb3React } from 'src/hooks';\nimport { ethers, utils } from 'ethers';\nimport { calculateGasMargin } from 'src/utils';\nimport { useTransactionAdder } from '../transactions/hooks';\nimport { useState, useEffect, useCallback } from 'react';\nimport GOV from '@pangolindex/governance/artifacts/contracts/GovernorAlpha.sol/GovernorAlpha.json';\nimport { GET_BLOCK } from 'src/apollo/block';\nimport { blockClient, governanceClient } from 'src/apollo/client';\nimport { GET_PROPOSALS } from 'src/apollo/vote';\nexport let ProposalState;\n\n(function (ProposalState) {\n  ProposalState[\"pending\"] = \"pending\";\n  ProposalState[\"active\"] = \"active\";\n  ProposalState[\"canceled\"] = \"canceled\";\n  ProposalState[\"defeated\"] = \"defeated\";\n  ProposalState[\"succeeded\"] = \"succeeded\";\n  ProposalState[\"queued\"] = \"queued\";\n  ProposalState[\"expired\"] = \"expired\";\n  ProposalState[\"executed\"] = \"executed\";\n})(ProposalState || (ProposalState = {}));\n\nconst enumerateProposalState = state => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed'];\n  return proposalStates[state];\n};\n\nconst getProposalState = proposal => {\n  const currentTimestamp = () => new Date().getTime();\n\n  if (proposal.canceled) {\n    return ProposalState.canceled;\n  } else if (currentTimestamp() <= proposal.startTime) {\n    return ProposalState.pending;\n  } else if (currentTimestamp() <= proposal.endTime) {\n    return ProposalState.active;\n  } else if (proposal.againstCount && JSBI.lessThanOrEqual(JSBI.BigInt(proposal.forCount), JSBI.BigInt((proposal === null || proposal === void 0 ? void 0 : proposal.againstCount) || 0))) {\n    return ProposalState.defeated;\n  } else if (proposal.eta === 0) {\n    return ProposalState.succeeded;\n  } else if (proposal.executed) {\n    return ProposalState.executed; // } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n    //     return ProposalState.expired;\n  } else {\n    return ProposalState.queued;\n  }\n}; // get count of all proposals made\n\n\nexport function useProposalCount() {\n  const gov = useGovernanceContract();\n  const res = useSingleCallResult(gov, 'proposalCount');\n\n  if (res.result && !res.loading) {\n    var _parseInt;\n\n    return (_parseInt = parseInt(res.result[0])) !== null && _parseInt !== void 0 ? _parseInt : 0;\n  }\n\n  return undefined;\n}\n/**\n * @notice Fetches first block after a given timestamp\n * @dev Query speed is optimized by limiting to a 600-second period\n * @param {Number} timestamp in seconds\n */\n\nexport async function getBlockFromTimestamp(timestamp) {\n  var _result$data, _result$data$blocks, _result$data$blocks$;\n\n  const result = await blockClient.query({\n    query: GET_BLOCK,\n    variables: {\n      timestampFrom: timestamp,\n      timestampTo: timestamp + 60 * 60 * 24 * 7\n    },\n    fetchPolicy: 'cache-first'\n  });\n  return result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$blocks = _result$data.blocks) === null || _result$data$blocks === void 0 ? void 0 : (_result$data$blocks$ = _result$data$blocks[0]) === null || _result$data$blocks$ === void 0 ? void 0 : _result$data$blocks$.number;\n}\n/**\n * Need proposal events to get description data emitted from\n * new proposal event.\n */\n\nexport function useDataFromEventLogs() {\n  const {\n    library\n  } = useActiveWeb3React();\n  const [formattedEvents, setFormattedEvents] = useState();\n  const govContract = useGovernanceContract();\n  const proposalCount = useProposalCount();\n  const proposalIndexes = [];\n\n  for (let i = 1; i <= (proposalCount !== null && proposalCount !== void 0 ? proposalCount : 0); i++) {\n    proposalIndexes.push([i]);\n  }\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes);\n  useEffect(() => {\n    const voteDelay = 60 * 60 * 24;\n    const eventParser = new ethers.utils.Interface(GOV.abi);\n\n    async function fetchData() {\n      var _pastEvents, _pastEvents$map;\n\n      let pastEvents = [];\n\n      for (const proposal of allProposals) {\n        var _proposal$result, _proposal$result$star;\n\n        const startTime = parseInt(proposal === null || proposal === void 0 ? void 0 : (_proposal$result = proposal.result) === null || _proposal$result === void 0 ? void 0 : (_proposal$result$star = _proposal$result.startTime) === null || _proposal$result$star === void 0 ? void 0 : _proposal$result$star.toString());\n\n        if (startTime) {\n          var _govContract$filters;\n\n          const eventTime = startTime - voteDelay;\n          const block = parseInt(await getBlockFromTimestamp(eventTime)); // Actual returns the \"next\" block\n\n          const filter = { ...(govContract === null || govContract === void 0 ? void 0 : (_govContract$filters = govContract.filters) === null || _govContract$filters === void 0 ? void 0 : _govContract$filters['ProposalCreated']()),\n            fromBlock: block - 10,\n            toBlock: block + 10\n          };\n          pastEvents = pastEvents.concat(await (library === null || library === void 0 ? void 0 : library.getLogs(filter)));\n        }\n      }\n\n      const formattedEventData = (_pastEvents = pastEvents) === null || _pastEvents === void 0 ? void 0 : (_pastEvents$map = _pastEvents.map(event => eventParser.parseLog(event).args)) === null || _pastEvents$map === void 0 ? void 0 : _pastEvents$map.map(eventParsed => ({\n        description: eventParsed.description,\n        details: eventParsed.targets.map((target, i) => {\n          const signature = eventParsed.signatures[i];\n          const [name, types] = signature.substr(0, signature.length - 1).split('(');\n          const calldata = eventParsed.calldatas[i];\n          const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata);\n          return {\n            target,\n            functionSig: name,\n            callData: decoded.join(', ')\n          };\n        })\n      })).reverse(); // reverse events to get them from newest to oldest\n\n      setFormattedEvents(formattedEventData);\n    }\n\n    if (library && govContract && proposalCount !== undefined && allProposals && allProposals.length === proposalCount && allProposals.every(proposal => !proposal.loading) && !formattedEvents) {\n      fetchData();\n    }\n  }, [library, govContract, proposalCount, allProposals, formattedEvents]);\n  return formattedEvents;\n}\n\nconst getAllProposalData = async id => {\n  let data = [];\n\n  try {\n    var _result$data2;\n\n    const queryData = {\n      query: GET_PROPOSALS,\n      fetchPolicy: 'cache-first'\n    };\n\n    if (!!id) {\n      queryData['variables'] = {\n        where: {\n          id: id\n        }\n      };\n    }\n\n    const result = await governanceClient.query(queryData);\n    data = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : _result$data2.proposals;\n  } catch (e) {\n    console.log(e);\n  }\n\n  return data;\n}; // get data for all past and active proposals\n\n\nexport function useAllProposalData() {\n  const proposalCount = useProposalCount();\n  const govContract = useGovernanceContract();\n  const proposalIndexes = [];\n\n  for (let i = 1; i <= (proposalCount !== null && proposalCount !== void 0 ? proposalCount : 0); i++) {\n    proposalIndexes.push([i]);\n  } // get metadata from past events\n\n\n  const formattedEvents = useDataFromEventLogs(); // get all proposal entities\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes); // get all proposal states\n\n  const allProposalStates = useSingleContractMultipleData(govContract, 'state', proposalIndexes);\n\n  if (formattedEvents && allProposals && allProposalStates) {\n    allProposals.reverse();\n    allProposalStates.reverse();\n    return allProposals.filter((p, i) => {\n      var _allProposalStates$i;\n\n      return Boolean(p.result) && Boolean((_allProposalStates$i = allProposalStates[i]) === null || _allProposalStates$i === void 0 ? void 0 : _allProposalStates$i.result) && Boolean(formattedEvents[i]);\n    }).map((p, i) => {\n      var _allProposals$i, _allProposals$i$resul, _allProposals$i2, _allProposals$i2$resu, _enumerateProposalSta, _allProposalStates$i2, _allProposalStates$i3, _allProposals$i3, _allProposals$i3$resu, _allProposals$i4, _allProposals$i4$resu, _allProposals$i5, _allProposals$i5$resu, _allProposals$i5$resu2, _allProposals$i6, _allProposals$i6$resu, _allProposals$i6$resu2, _allProposals$i7, _allProposals$i7$resu, _allProposals$i7$resu2;\n\n      const description = formattedEvents[i].description;\n      const formattedProposal = {\n        id: (_allProposals$i = allProposals[i]) === null || _allProposals$i === void 0 ? void 0 : (_allProposals$i$resul = _allProposals$i.result) === null || _allProposals$i$resul === void 0 ? void 0 : _allProposals$i$resul.id.toString(),\n        title: (description === null || description === void 0 ? void 0 : description.split(/# |\\n/g)[1]) || 'Untitled',\n        description: description || 'No description.',\n        proposer: (_allProposals$i2 = allProposals[i]) === null || _allProposals$i2 === void 0 ? void 0 : (_allProposals$i2$resu = _allProposals$i2.result) === null || _allProposals$i2$resu === void 0 ? void 0 : _allProposals$i2$resu.proposer,\n        status: (_enumerateProposalSta = enumerateProposalState((_allProposalStates$i2 = allProposalStates[i]) === null || _allProposalStates$i2 === void 0 ? void 0 : (_allProposalStates$i3 = _allProposalStates$i2.result) === null || _allProposalStates$i3 === void 0 ? void 0 : _allProposalStates$i3[0])) !== null && _enumerateProposalSta !== void 0 ? _enumerateProposalSta : 'Undetermined',\n        forCount: parseFloat(ethers.utils.formatUnits((_allProposals$i3 = allProposals[i]) === null || _allProposals$i3 === void 0 ? void 0 : (_allProposals$i3$resu = _allProposals$i3.result) === null || _allProposals$i3$resu === void 0 ? void 0 : _allProposals$i3$resu.forVotes.toString(), 18)),\n        againstCount: parseFloat(ethers.utils.formatUnits((_allProposals$i4 = allProposals[i]) === null || _allProposals$i4 === void 0 ? void 0 : (_allProposals$i4$resu = _allProposals$i4.result) === null || _allProposals$i4$resu === void 0 ? void 0 : _allProposals$i4$resu.againstVotes.toString(), 18)),\n        startTime: parseInt((_allProposals$i5 = allProposals[i]) === null || _allProposals$i5 === void 0 ? void 0 : (_allProposals$i5$resu = _allProposals$i5.result) === null || _allProposals$i5$resu === void 0 ? void 0 : (_allProposals$i5$resu2 = _allProposals$i5$resu.startTime) === null || _allProposals$i5$resu2 === void 0 ? void 0 : _allProposals$i5$resu2.toString()),\n        endTime: parseInt((_allProposals$i6 = allProposals[i]) === null || _allProposals$i6 === void 0 ? void 0 : (_allProposals$i6$resu = _allProposals$i6.result) === null || _allProposals$i6$resu === void 0 ? void 0 : (_allProposals$i6$resu2 = _allProposals$i6$resu.endTime) === null || _allProposals$i6$resu2 === void 0 ? void 0 : _allProposals$i6$resu2.toString()),\n        startBlock: parseInt((_allProposals$i7 = allProposals[i]) === null || _allProposals$i7 === void 0 ? void 0 : (_allProposals$i7$resu = _allProposals$i7.result) === null || _allProposals$i7$resu === void 0 ? void 0 : (_allProposals$i7$resu2 = _allProposals$i7$resu.startBlock) === null || _allProposals$i7$resu2 === void 0 ? void 0 : _allProposals$i7$resu2.toString()),\n        details: formattedEvents[i].details\n      };\n      return formattedProposal;\n    });\n  } else {\n    return [];\n  }\n} // get data for all past and active proposals\n\nexport function useGetProposalsViaSubgraph(id) {\n  const [allProposalsData, setAllProposalsData] = useState([]);\n  useEffect(() => {\n    async function checkForChartData() {\n      const allProposals = await getAllProposalData(id);\n\n      if (allProposals) {\n        const allData = allProposals.map(proposal => {\n          var _proposal$description, _getProposalState, _proposal$startTime, _proposal$endTime;\n\n          const details = ((proposal === null || proposal === void 0 ? void 0 : proposal.targets) || []).map((target, i) => {\n            const signature = proposal === null || proposal === void 0 ? void 0 : proposal.signatures[i];\n            const [name, types] = signature === null || signature === void 0 ? void 0 : signature.substr(0, (signature === null || signature === void 0 ? void 0 : signature.length) - 1).split('(');\n            const calldata = proposal === null || proposal === void 0 ? void 0 : proposal.calldatas[i];\n            const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata);\n            return {\n              target,\n              functionSig: name,\n              callData: decoded.join(', ')\n            };\n          });\n          return {\n            id: proposal === null || proposal === void 0 ? void 0 : proposal.id.toString(),\n            title: (proposal === null || proposal === void 0 ? void 0 : (_proposal$description = proposal.description) === null || _proposal$description === void 0 ? void 0 : _proposal$description.split(/# |\\n/g)[1]) || 'Untitled',\n            description: (proposal === null || proposal === void 0 ? void 0 : proposal.description) || 'No description.',\n            proposer: proposal === null || proposal === void 0 ? void 0 : proposal.proposer,\n            status: (_getProposalState = getProposalState({ ...proposal,\n              forCount: proposal === null || proposal === void 0 ? void 0 : proposal.forVotes,\n              againstCount: proposal === null || proposal === void 0 ? void 0 : proposal.againstVotes\n            })) !== null && _getProposalState !== void 0 ? _getProposalState : 'Undetermined',\n            forCount: (proposal === null || proposal === void 0 ? void 0 : proposal.forVotes) ? parseFloat(ethers.utils.formatUnits(proposal === null || proposal === void 0 ? void 0 : proposal.forVotes.toString(), 18)) : 0,\n            againstCount: (proposal === null || proposal === void 0 ? void 0 : proposal.againstVotes) ? parseFloat(ethers.utils.formatUnits(proposal === null || proposal === void 0 ? void 0 : proposal.againstVotes.toString(), 18)) : 0,\n            startTime: parseInt(proposal === null || proposal === void 0 ? void 0 : (_proposal$startTime = proposal.startTime) === null || _proposal$startTime === void 0 ? void 0 : _proposal$startTime.toString()),\n            endTime: parseInt(proposal === null || proposal === void 0 ? void 0 : (_proposal$endTime = proposal.endTime) === null || _proposal$endTime === void 0 ? void 0 : _proposal$endTime.toString()),\n            details: details\n          };\n        });\n        setAllProposalsData(allData);\n      }\n    }\n\n    checkForChartData();\n  }, [id]);\n  return allProposalsData;\n}\nexport function useProposalData(id) {\n  const allProposalData = useAllProposalData();\n  return allProposalData === null || allProposalData === void 0 ? void 0 : allProposalData.find(p => p.id === id);\n}\nexport function useGetProposalDetail(id) {\n  const allProposalData = useGetProposalsViaSubgraph(id);\n  return allProposalData === null || allProposalData === void 0 ? void 0 : allProposalData.find(p => p.id === id);\n} // get the users delegatee if it exists\n\nexport function useUserDelegatee() {\n  var _result$;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const uniContract = usePngContract();\n  const {\n    result\n  } = useSingleCallResult(uniContract, 'delegates', [account !== null && account !== void 0 ? account : undefined]);\n  return (_result$ = result === null || result === void 0 ? void 0 : result[0]) !== null && _result$ !== void 0 ? _result$ : undefined;\n}\nexport function useUserVotes() {\n  var _useSingleCallResult, _useSingleCallResult$;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const pngContract = usePngContract(); // check for available votes\n\n  const png = chainId ? PNG[chainId] : undefined;\n  const votes = (_useSingleCallResult = useSingleCallResult(pngContract, 'getCurrentVotes', [account !== null && account !== void 0 ? account : undefined])) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n  return votes && png ? new TokenAmount(png, votes) : undefined;\n}\nexport function useDelegateCallback() {\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const addTransaction = useTransactionAdder();\n  const uniContract = usePngContract();\n  return useCallback(delegatee => {\n    if (!library || !chainId || !account || !isAddress(delegatee !== null && delegatee !== void 0 ? delegatee : '')) return undefined;\n    const args = [delegatee];\n    if (!uniContract) throw new Error('No UNI Contract!');\n    return uniContract.estimateGas.delegate(...args, {}).then(estimatedGasLimit => {\n      return uniContract.delegate(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          summary: `Delegated votes`\n        });\n        return response.hash;\n      });\n    });\n  }, [account, addTransaction, chainId, library, uniContract]);\n}\nexport function useVoteCallback() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const govContract = useGovernanceContract();\n  const addTransaction = useTransactionAdder();\n  const voteCallback = useCallback((proposalId, support) => {\n    if (!account || !govContract || !proposalId) return;\n    const args = [proposalId, support];\n    return govContract.estimateGas.castVote(...args, {}).then(estimatedGasLimit => {\n      return govContract.castVote(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          summary: `Voted ${support ? 'for ' : 'against'} proposal ${proposalId}`\n        });\n        return response.hash;\n      });\n    });\n  }, [account, addTransaction, govContract]);\n  return {\n    voteCallback\n  };\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/state/governance/hooks.ts"],"names":["PNG","TokenAmount","JSBI","isAddress","useGovernanceContract","usePngContract","useSingleCallResult","useSingleContractMultipleData","useActiveWeb3React","ethers","utils","calculateGasMargin","useTransactionAdder","useState","useEffect","useCallback","GOV","GET_BLOCK","blockClient","governanceClient","GET_PROPOSALS","ProposalState","enumerateProposalState","state","proposalStates","getProposalState","proposal","currentTimestamp","Date","getTime","canceled","startTime","pending","endTime","active","againstCount","lessThanOrEqual","BigInt","forCount","defeated","eta","succeeded","executed","queued","useProposalCount","gov","res","result","loading","parseInt","undefined","getBlockFromTimestamp","timestamp","query","variables","timestampFrom","timestampTo","fetchPolicy","data","blocks","number","useDataFromEventLogs","library","formattedEvents","setFormattedEvents","govContract","proposalCount","proposalIndexes","i","push","allProposals","voteDelay","eventParser","Interface","abi","fetchData","pastEvents","toString","eventTime","block","filter","filters","fromBlock","toBlock","concat","getLogs","formattedEventData","map","event","parseLog","args","eventParsed","description","details","targets","target","signature","signatures","name","types","substr","length","split","calldata","calldatas","decoded","defaultAbiCoder","decode","functionSig","callData","join","reverse","every","getAllProposalData","id","queryData","where","proposals","e","console","log","useAllProposalData","allProposalStates","p","Boolean","formattedProposal","title","proposer","status","parseFloat","formatUnits","forVotes","againstVotes","startBlock","useGetProposalsViaSubgraph","allProposalsData","setAllProposalsData","checkForChartData","allData","useProposalData","allProposalData","find","useGetProposalDetail","useUserDelegatee","account","uniContract","useUserVotes","chainId","pngContract","png","votes","useDelegateCallback","addTransaction","delegatee","Error","estimateGas","delegate","then","estimatedGasLimit","value","gasLimit","response","summary","hash","useVoteCallback","voteCallback","proposalId","support","castVote"],"mappings":"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","sourcesContent":["import { PNG } from 'src/constants/tokens'\nimport { TokenAmount, JSBI } from '@pangolindex/sdk'\nimport { isAddress } from 'ethers/lib/utils'\nimport { useGovernanceContract, usePngContract } from 'src/hooks/useContract'\nimport { useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks'\nimport { useActiveWeb3React } from 'src/hooks'\nimport { ethers, utils } from 'ethers'\nimport { calculateGasMargin } from 'src/utils'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { useTransactionAdder } from '../transactions/hooks'\nimport { useState, useEffect, useCallback } from 'react'\nimport GOV from '@pangolindex/governance/artifacts/contracts/GovernorAlpha.sol/GovernorAlpha.json'\nimport { GET_BLOCK } from 'src/apollo/block'\nimport { blockClient, governanceClient } from 'src/apollo/client'\nimport { GET_PROPOSALS } from 'src/apollo/vote'\n\ninterface ProposalDetail {\n  target: string\n  functionSig: string\n  callData: string\n}\n\nexport interface ProposalData {\n  id: string\n  title: string\n  description: string\n  proposer: string\n  status: string\n  forCount: number\n  againstCount: number\n  startTime: number\n  endTime: number\n  startBlock?: number\n  details: ProposalDetail[]\n  canceled?: boolean\n  executed?: boolean\n  eta?: number\n}\n\nexport enum ProposalState {\n  pending = 'pending',\n  active = 'active',\n  canceled = 'canceled',\n  defeated = 'defeated',\n  succeeded = 'succeeded',\n  queued = 'queued',\n  expired = 'expired',\n  executed = 'executed'\n}\n\nconst enumerateProposalState = (state: number) => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed']\n  return proposalStates[state]\n}\n\nconst getProposalState = (proposal: ProposalData) => {\n  const currentTimestamp = () => new Date().getTime()\n\n  if (proposal.canceled) {\n    return ProposalState.canceled\n  } else if (currentTimestamp() <= proposal.startTime) {\n    return ProposalState.pending\n  } else if (currentTimestamp() <= proposal.endTime) {\n    return ProposalState.active\n  } else if (\n    proposal.againstCount &&\n    JSBI.lessThanOrEqual(JSBI.BigInt(proposal.forCount), JSBI.BigInt(proposal?.againstCount || 0))\n  ) {\n    return ProposalState.defeated\n  } else if (proposal.eta === 0) {\n    return ProposalState.succeeded\n  } else if (proposal.executed) {\n    return ProposalState.executed\n    // } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n    //     return ProposalState.expired;\n  } else {\n    return ProposalState.queued\n  }\n}\n\n// get count of all proposals made\nexport function useProposalCount(): number | undefined {\n  const gov = useGovernanceContract()\n  const res = useSingleCallResult(gov, 'proposalCount')\n  if (res.result && !res.loading) {\n    return parseInt(res.result[0]) ?? 0\n  }\n  return undefined\n}\n\n/**\n * @notice Fetches first block after a given timestamp\n * @dev Query speed is optimized by limiting to a 600-second period\n * @param {Number} timestamp in seconds\n */\nexport async function getBlockFromTimestamp(timestamp: number) {\n  const result = await blockClient.query({\n    query: GET_BLOCK,\n    variables: {\n      timestampFrom: timestamp,\n      timestampTo: timestamp + 60 * 60 * 24 * 7\n    },\n    fetchPolicy: 'cache-first'\n  })\n  return result?.data?.blocks?.[0]?.number\n}\n\n/**\n * Need proposal events to get description data emitted from\n * new proposal event.\n */\nexport function useDataFromEventLogs() {\n  const { library } = useActiveWeb3React()\n  const [formattedEvents, setFormattedEvents] = useState<any>()\n  const govContract = useGovernanceContract()\n\n  const proposalCount = useProposalCount()\n\n  const proposalIndexes = []\n  for (let i = 1; i <= (proposalCount ?? 0); i++) {\n    proposalIndexes.push([i])\n  }\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes)\n\n  useEffect(() => {\n    const voteDelay: number = 60 * 60 * 24\n    const eventParser = new ethers.utils.Interface(GOV.abi)\n\n    async function fetchData() {\n      let pastEvents = [] as any[]\n\n      for (const proposal of allProposals) {\n        const startTime: number = parseInt(proposal?.result?.startTime?.toString())\n        if (startTime) {\n          const eventTime: number = startTime - voteDelay\n          const block: number = parseInt(await getBlockFromTimestamp(eventTime)) // Actual returns the \"next\" block\n          const filter = {\n            ...govContract?.filters?.['ProposalCreated'](),\n            fromBlock: block - 10,\n            toBlock: block + 10\n          }\n          pastEvents = pastEvents.concat(await library?.getLogs(filter))\n        }\n      }\n\n      const formattedEventData = pastEvents\n        ?.map(event => eventParser.parseLog(event).args)\n        ?.map(eventParsed => ({\n          description: eventParsed.description,\n          details: eventParsed.targets.map((target: string, i: number) => {\n            const signature = eventParsed.signatures[i]\n            const [name, types] = signature.substr(0, signature.length - 1).split('(')\n\n            const calldata = eventParsed.calldatas[i]\n            const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata)\n\n            return {\n              target,\n              functionSig: name,\n              callData: decoded.join(', ')\n            }\n          })\n        }))\n        .reverse() // reverse events to get them from newest to oldest\n\n      setFormattedEvents(formattedEventData)\n    }\n\n    if (\n      library &&\n      govContract &&\n      proposalCount !== undefined &&\n      allProposals &&\n      allProposals.length === proposalCount &&\n      allProposals.every(proposal => !proposal.loading) &&\n      !formattedEvents\n    ) {\n      fetchData()\n    }\n  }, [library, govContract, proposalCount, allProposals, formattedEvents])\n\n  return formattedEvents\n}\n\nconst getAllProposalData = async (id?: string) => {\n  let data = [] as Array<any>\n\n  try {\n    const queryData: any = {\n      query: GET_PROPOSALS,\n      fetchPolicy: 'cache-first'\n    }\n\n    if (!!id) {\n      queryData['variables'] = { where: { id: id } }\n    }\n    const result = await governanceClient.query(queryData)\n    data = result?.data?.proposals\n  } catch (e) {\n    console.log(e)\n  }\n\n  return data\n}\n\n// get data for all past and active proposals\nexport function useAllProposalData() {\n  const proposalCount = useProposalCount()\n  const govContract = useGovernanceContract()\n\n  const proposalIndexes = []\n  for (let i = 1; i <= (proposalCount ?? 0); i++) {\n    proposalIndexes.push([i])\n  }\n\n  // get metadata from past events\n  const formattedEvents = useDataFromEventLogs()\n\n  // get all proposal entities\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes)\n  // get all proposal states\n  const allProposalStates = useSingleContractMultipleData(govContract, 'state', proposalIndexes)\n\n  if (formattedEvents && allProposals && allProposalStates) {\n    allProposals.reverse()\n    allProposalStates.reverse()\n\n    return allProposals\n      .filter((p, i) => {\n        return Boolean(p.result) && Boolean(allProposalStates[i]?.result) && Boolean(formattedEvents[i])\n      })\n      .map((p, i) => {\n        const description = formattedEvents[i].description\n\n        const formattedProposal: ProposalData = {\n          id: allProposals[i]?.result?.id.toString(),\n          title: description?.split(/# |\\n/g)[1] || 'Untitled',\n          description: description || 'No description.',\n          proposer: allProposals[i]?.result?.proposer,\n          status: enumerateProposalState(allProposalStates[i]?.result?.[0]) ?? 'Undetermined',\n          forCount: parseFloat(ethers.utils.formatUnits(allProposals[i]?.result?.forVotes.toString(), 18)),\n          againstCount: parseFloat(ethers.utils.formatUnits(allProposals[i]?.result?.againstVotes.toString(), 18)),\n          startTime: parseInt(allProposals[i]?.result?.startTime?.toString()),\n          endTime: parseInt(allProposals[i]?.result?.endTime?.toString()),\n          startBlock: parseInt(allProposals[i]?.result?.startBlock?.toString()),\n          details: formattedEvents[i].details\n        }\n        return formattedProposal\n      })\n  } else {\n    return []\n  }\n}\n\n// get data for all past and active proposals\nexport function useGetProposalsViaSubgraph(id?: string) {\n  const [allProposalsData, setAllProposalsData] = useState<Array<ProposalData>>([])\n\n  useEffect(() => {\n    async function checkForChartData() {\n      const allProposals = await getAllProposalData(id)\n\n      if (allProposals) {\n        const allData = allProposals.map(proposal => {\n          const details = (proposal?.targets || []).map((target: string, i: number) => {\n            const signature = proposal?.signatures[i]\n\n            const [name, types] = signature?.substr(0, signature?.length - 1).split('(')\n\n            const calldata = proposal?.calldatas[i]\n\n            const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata)\n\n            return {\n              target,\n              functionSig: name,\n              callData: decoded.join(', ')\n            }\n          })\n\n          return {\n            id: proposal?.id.toString(),\n            title: proposal?.description?.split(/# |\\n/g)[1] || 'Untitled',\n            description: proposal?.description || 'No description.',\n            proposer: proposal?.proposer,\n            status:\n              getProposalState({ ...proposal, forCount: proposal?.forVotes, againstCount: proposal?.againstVotes }) ??\n              'Undetermined',\n            forCount: proposal?.forVotes ? parseFloat(ethers.utils.formatUnits(proposal?.forVotes.toString(), 18)) : 0,\n            againstCount: proposal?.againstVotes\n              ? parseFloat(ethers.utils.formatUnits(proposal?.againstVotes.toString(), 18))\n              : 0,\n            startTime: parseInt(proposal?.startTime?.toString()),\n            endTime: parseInt(proposal?.endTime?.toString()),\n            details: details\n          }\n        })\n\n        setAllProposalsData(allData)\n      }\n    }\n    checkForChartData()\n  }, [id])\n\n  return allProposalsData\n}\n\nexport function useProposalData(id: string): ProposalData | undefined {\n  const allProposalData = useAllProposalData()\n  return allProposalData?.find(p => p.id === id)\n}\n\nexport function useGetProposalDetail(id: string): ProposalData | undefined {\n  const allProposalData = useGetProposalsViaSubgraph(id)\n  return allProposalData?.find((p: ProposalData) => p.id === id)\n}\n\n// get the users delegatee if it exists\nexport function useUserDelegatee(): string {\n  const { account } = useActiveWeb3React()\n  const uniContract = usePngContract()\n  const { result } = useSingleCallResult(uniContract, 'delegates', [account ?? undefined])\n  return result?.[0] ?? undefined\n}\n\nexport function useUserVotes(): TokenAmount | undefined {\n  const { account, chainId } = useActiveWeb3React()\n  const pngContract = usePngContract()\n\n  // check for available votes\n  const png = chainId ? PNG[chainId] : undefined\n  const votes = useSingleCallResult(pngContract, 'getCurrentVotes', [account ?? undefined])?.result?.[0]\n  return votes && png ? new TokenAmount(png, votes) : undefined\n}\n\nexport function useDelegateCallback(): (delegatee: string | undefined) => undefined | Promise<string> {\n  const { account, chainId, library } = useActiveWeb3React()\n  const addTransaction = useTransactionAdder()\n\n  const uniContract = usePngContract()\n\n  return useCallback(\n    (delegatee: string | undefined) => {\n      if (!library || !chainId || !account || !isAddress(delegatee ?? '')) return undefined\n      const args = [delegatee]\n      if (!uniContract) throw new Error('No UNI Contract!')\n      return uniContract.estimateGas.delegate(...args, {}).then((estimatedGasLimit: any) => {\n        return uniContract\n          .delegate(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: `Delegated votes`\n            })\n            return response.hash\n          })\n      })\n    },\n    [account, addTransaction, chainId, library, uniContract]\n  )\n}\n\nexport function useVoteCallback(): {\n  voteCallback: (proposalId: string | undefined, support: boolean) => undefined | Promise<string>\n} {\n  const { account } = useActiveWeb3React()\n\n  const govContract = useGovernanceContract()\n  const addTransaction = useTransactionAdder()\n\n  const voteCallback = useCallback(\n    (proposalId: string | undefined, support: boolean) => {\n      if (!account || !govContract || !proposalId) return\n      const args = [proposalId, support]\n      return govContract.estimateGas.castVote(...args, {}).then((estimatedGasLimit: any) => {\n        return govContract\n          .castVote(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: `Voted ${support ? 'for ' : 'against'} proposal ${proposalId}`\n            })\n            return response.hash\n          })\n      })\n    },\n    [account, addTransaction, govContract]\n  )\n  return { voteCallback }\n}\n"]},"metadata":{},"sourceType":"module"}