{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GelatoLimitOrders = exports.isFlashbotsCompatibleChainId = exports.isValidChainIdAndHandler = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst abstract_provider_1 = require(\"@ethersproject/abstract-provider\");\n\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\n\nconst constants_1 = require(\"../constants\");\n\nconst types_1 = require(\"../contracts/types\");\n\nconst queries_1 = require(\"../utils/queries\");\n\nconst utils_1 = require(\"../utils\");\n\nconst isValidChainIdAndHandler = (chainId, handler) => {\n  return constants_1.NETWORK_HANDLERS[chainId].includes(handler);\n};\n\nexports.isValidChainIdAndHandler = isValidChainIdAndHandler;\n\nconst isFlashbotsCompatibleChainId = chainId => {\n  return chainId == constants_1.CHAIN_ID.MAINNET || chainId == constants_1.CHAIN_ID.GOERLI;\n};\n\nexports.isFlashbotsCompatibleChainId = isFlashbotsCompatibleChainId;\n\nclass GelatoLimitOrders {\n  constructor(chainId, signerOrProvider, handler) {\n    let isFlashbotsProtected = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var _a;\n\n    if (handler && !(0, exports.isValidChainIdAndHandler)(chainId, handler)) {\n      throw new Error(\"Invalid chainId and handler\");\n    } else if (isFlashbotsProtected && (handler || !(0, exports.isFlashbotsCompatibleChainId)(chainId))) {\n      throw new Error(\"Invalid chainId or handler for Flashbots bundle submission. handler must be undefined, and chainId either 1 (mainnet) or 5 (goerli)\");\n    }\n\n    this._chainId = chainId;\n    this._gelatoFeeBPS = constants_1.BPS_GELATO_FEE[chainId];\n    this._slippageBPS = constants_1.LIMIT_ORDER_SLIPPAGE[chainId];\n    this._subgraphUrl = constants_1.SUBGRAPH_URL[chainId];\n    this._signer = abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider : undefined;\n    this._provider = abstract_provider_1.Provider.isProvider(signerOrProvider) ? signerOrProvider : abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : undefined;\n    this._gelatoLimitOrders = this._signer ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._signer) : this._provider ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._provider) : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], types_1.GelatoLimitOrders__factory.createInterface());\n    this._moduleAddress = isFlashbotsProtected ? constants_1.GELATO_LIMIT_ORDERS_MODULE_FLASHBOTS_ADDRESS[this._chainId] : constants_1.GELATO_LIMIT_ORDERS_MODULE_ADDRESS[this._chainId];\n    this._handler = handler;\n    this._handlerAddress = handler ? (_a = constants_1.HANDLERS_ADDRESSES[this._chainId][handler]) === null || _a === void 0 ? void 0 : _a.toLowerCase() : undefined;\n    this._isFlashbotsProtected = isFlashbotsProtected;\n    this._abiEncoder = new ethers_1.utils.AbiCoder();\n    this._erc20OrderRouter = this._signer ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._signer) : this._provider ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._provider) : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], types_1.ERC20OrderRouter__factory.createInterface());\n  }\n\n  get gelatoFeeBPS() {\n    return this._gelatoFeeBPS;\n  }\n\n  get slippageBPS() {\n    return this._slippageBPS;\n  }\n\n  get chainId() {\n    return this._chainId;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  get provider() {\n    return this._provider;\n  }\n\n  get subgraphUrl() {\n    return this._subgraphUrl;\n  }\n\n  get handler() {\n    return this._handler;\n  }\n\n  get handlerAddress() {\n    return this._handlerAddress;\n  }\n\n  get moduleAddress() {\n    return this._moduleAddress;\n  }\n\n  get contract() {\n    return this._gelatoLimitOrders;\n  }\n\n  get erc20OrderRouter() {\n    return this._erc20OrderRouter;\n  }\n\n  get isFlashbotsProtected() {\n    return this._isFlashbotsProtected;\n  }\n\n  encodeLimitOrderSubmission(inputToken, outputToken, inputAmount, minReturn, owner) {\n    let checkAllowance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const {\n        payload\n      } = yield this.encodeLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, minReturn, owner, checkAllowance);\n      return payload;\n    });\n  }\n\n  encodeLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, minReturnToBeParsed, owner) {\n    let checkAllowance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    var _a;\n\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const randomSecret = ethers_1.utils.hexlify(ethers_1.utils.randomBytes(19)).replace(\"0x\", \"\"); // 0x67656c61746f6e6574776f726b = gelatonetwork in hex\n\n      const fullSecret = `0x67656c61746f6e6574776f726b${randomSecret}`;\n      const {\n        privateKey: secret,\n        address: witness\n      } = new ethers_1.Wallet(fullSecret);\n      const {\n        minReturn\n      } = this.getFeeAndSlippageAdjustedMinReturn(minReturnToBeParsed);\n      const payload = yield this._encodeSubmitData(inputToken, outputToken, owner, witness, inputAmount, minReturn, secret, checkAllowance);\n      const encodedData = this._handlerAddress ? this._abiEncoder.encode([\"address\", \"uint256\", \"address\"], [outputToken, minReturn, this._handlerAddress]) : this._abiEncoder.encode([\"address\", \"uint256\"], [outputToken, minReturn]);\n      return {\n        payload,\n        secret,\n        witness,\n        order: {\n          id: this._getKey({\n            module: this._moduleAddress,\n            inputToken,\n            owner,\n            witness,\n            data: encodedData\n          }),\n          module: this._moduleAddress.toLowerCase(),\n          data: encodedData,\n          inputToken: inputToken.toLowerCase(),\n          outputToken: outputToken.toLowerCase(),\n          owner: owner.toLowerCase(),\n          witness: witness.toLowerCase(),\n          inputAmount: inputAmount.toString(),\n          minReturn: minReturn.toString(),\n          adjustedMinReturn: minReturnToBeParsed.toString(),\n          inputData: payload.data.toString(),\n          secret: secret.toLowerCase(),\n          handler: (_a = this._handlerAddress) !== null && _a !== void 0 ? _a : null\n        }\n      };\n    });\n  }\n\n  submitLimitOrder(inputToken, outputToken, inputAmount, minReturn) {\n    let checkAllowance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let overrides = arguments.length > 5 ? arguments[5] : undefined;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._signer) throw new Error(\"No signer\");\n      const owner = yield this._signer.getAddress();\n      const txData = yield this.encodeLimitOrderSubmission(inputToken, outputToken, inputAmount, minReturn, owner, checkAllowance);\n      return this._signer.sendTransaction(Object.assign(Object.assign({}, overrides), {\n        to: txData.to,\n        data: txData.data,\n        value: ethers_1.BigNumber.from(txData.value)\n      }));\n    });\n  }\n\n  encodeLimitOrderCancellation(order, checkIsActiveOrder) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._gelatoLimitOrders) throw new Error(\"No gelato limit orders contract\");\n      if (!order.inputToken) throw new Error(\"No input token in order\");\n      if (!order.witness) throw new Error(\"No witness in order\");\n      if (!order.outputToken) throw new Error(\"No output token in order\");\n      if (!order.minReturn) throw new Error(\"No minReturn in order\");\n      if (!order.owner) throw new Error(\"No owner\");\n      if (!order.module) throw new Error(\"No module in order\");\n\n      if (checkIsActiveOrder) {\n        const isActiveOrder = yield this.isActiveOrder(order);\n        if (!isActiveOrder) throw new Error(\"Order not found. Please review your order data.\");\n      }\n\n      const data = this._gelatoLimitOrders.interface.encodeFunctionData(\"cancelOrder\", [order.module, order.inputToken, order.owner, order.witness, order.data]);\n\n      return {\n        data,\n        to: this._gelatoLimitOrders.address,\n        value: ethers_1.constants.Zero\n      };\n    });\n  }\n\n  cancelLimitOrder(order, checkIsActiveOrder, overrides) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._signer) throw new Error(\"No signer\");\n      if (!this._gelatoLimitOrders) throw new Error(\"No gelato limit orders contract\");\n      let _order = order;\n\n      if (order.id) {\n        try {\n          const subgraphOrder = yield Promise.race([this.getOrder(order.id), new Promise(resolve => setTimeout(resolve, 5000)).then(() => {\n            throw new Error(\"Timeout\");\n          })]);\n\n          if (subgraphOrder) {\n            if (subgraphOrder.status === \"cancelled\") {\n              throw new Error(`Order status is not open. Current order status: ${subgraphOrder.status}. Cancellation transaction hash: ${subgraphOrder.cancelledTxHash}`);\n            }\n\n            if (subgraphOrder.status === \"executed\") {\n              throw new Error(`Order status is not open. Current order status: ${subgraphOrder.status}. Execution transaction hash: ${subgraphOrder.executedTxHash}`);\n            }\n\n            _order = Object.assign(Object.assign({}, order), subgraphOrder);\n          } // eslint-disable-next-line no-empty\n\n        } catch (error) {}\n      }\n\n      if (!_order.inputToken) throw new Error(\"No input token in order\");\n      if (!_order.witness) throw new Error(\"No witness in order\");\n      if (!_order.outputToken) throw new Error(\"No output token in order\");\n      if (!_order.minReturn) throw new Error(\"No minReturn in order\");\n      if (!_order.data) throw new Error(\"No data in order\");\n      if (!_order.module) throw new Error(\"No module in order\");\n\n      if (checkIsActiveOrder) {\n        const isActiveOrder = yield this.isActiveOrder(_order);\n        if (!isActiveOrder) throw new Error(\"Order not found. Please review your order data.\");\n      }\n\n      const owner = yield this._signer.getAddress();\n      if (owner.toLowerCase() !== order.owner.toLowerCase()) throw new Error(\"Owner and signer mismatch\");\n      return this._gelatoLimitOrders.cancelOrder(_order.module, _order.inputToken, _order.owner, _order.witness, _order.data, overrides !== null && overrides !== void 0 ? overrides : {\n        gasLimit: (0, utils_1.isEthereumChain)(this._chainId) ? 600000 : 2000000\n      });\n    });\n  }\n\n  approveTokenAmount(inputToken, amount, overrides) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._signer) throw new Error(\"No signer\");\n      return overrides ? types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount, overrides) : types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount);\n    });\n  }\n\n  isActiveOrder(order) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._provider) throw new Error(\"No provider\");\n      if (!this._gelatoLimitOrders) throw new Error(\"No gelato limit orders contract\");\n      if (!order.module) throw new Error(\"No module in order\");\n      if (!order.inputToken) throw new Error(\"No input token in order\");\n      if (!order.owner) throw new Error(\"No owner in order\");\n      if (!order.witness) throw new Error(\"No witness in order\");\n      if (!order.data) throw new Error(\"No data in order\");\n      return this._gelatoLimitOrders.existOrder(order.module, order.inputToken, order.owner, order.witness, order.data);\n    });\n  }\n\n  getExchangeRate(inputValue, inputDecimals, outputValue, outputDecimals) {\n    let invert = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(18));\n\n    if (invert) {\n      return ethers_1.BigNumber.from(inputValue).mul(factor).div(outputValue).mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals))).div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals))).toString();\n    } else {\n      return ethers_1.BigNumber.from(outputValue).mul(factor).div(inputValue).mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals))).div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals))).toString();\n    }\n  }\n\n  getFeeAndSlippageAdjustedMinReturn(outputAmount, extraSlippageBPS) {\n    if (extraSlippageBPS) {\n      if (!Number.isInteger(extraSlippageBPS)) throw new Error(\"Extra Slippage BPS must an unsigned integer\");\n    }\n\n    const gelatoFee = ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000).gte(1) ? ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000) : ethers_1.BigNumber.from(1);\n    const slippageBPS = extraSlippageBPS ? this._slippageBPS + extraSlippageBPS : this._slippageBPS;\n    const slippage = ethers_1.BigNumber.from(outputAmount).mul(slippageBPS).div(10000);\n    const minReturn = ethers_1.BigNumber.from(outputAmount).sub(gelatoFee).sub(slippage);\n    return {\n      minReturn: minReturn.toString(),\n      slippage: slippage.toString(),\n      gelatoFee: gelatoFee.toString()\n    };\n  }\n\n  getAdjustedMinReturn(minReturn, extraSlippageBPS) {\n    const gelatoFee = ethers_1.BigNumber.from(this._gelatoFeeBPS);\n    const slippage = extraSlippageBPS ? ethers_1.BigNumber.from(this._slippageBPS + extraSlippageBPS) : ethers_1.BigNumber.from(this._slippageBPS);\n    const fees = gelatoFee.add(slippage);\n    const adjustedMinReturn = ethers_1.BigNumber.from(minReturn).mul(10000).div(ethers_1.BigNumber.from(10000).sub(fees));\n    return adjustedMinReturn.toString();\n  }\n\n  getExecutionPrice(inputAmount, inputDecimals, outputAmount, outputDecimals) {\n    let isInverted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(isInverted ? outputDecimals : inputDecimals));\n\n    if (isInverted) {\n      return ethers_1.BigNumber.from(inputAmount).mul(factor).div(outputAmount).toString();\n    } else {\n      return ethers_1.BigNumber.from(outputAmount).mul(factor).div(inputAmount).toString();\n    }\n  }\n\n  getOrder(orderId) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const order = yield (0, queries_1.queryOrder)(orderId, this._chainId);\n\n      if (order) {\n        return Object.assign(Object.assign({}, order), {\n          adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n        });\n      } else {\n        return null;\n      }\n    });\n  }\n\n  getOrders(owner) {\n    let includeOrdersWithNullHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, queries_1.queryOrders)(owner, this._chainId);\n      return orders.map(order => Object.assign(Object.assign({}, order), {\n        adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n      })).filter(order => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n    });\n  }\n\n  getOpenOrders(owner) {\n    let includeOrdersWithNullHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, queries_1.queryOpenOrders)(owner, this._chainId);\n      return orders.map(order => Object.assign(Object.assign({}, order), {\n        adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n      })).filter(order => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n    });\n  }\n\n  getPastOrders(owner) {\n    let includeOrdersWithNullHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, queries_1.queryPastOrders)(owner, this._chainId);\n      return orders.map(order => Object.assign(Object.assign({}, order), {\n        adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n      })).filter(order => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n    });\n  }\n\n  getExecutedOrders(owner) {\n    let includeOrdersWithNullHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, queries_1.queryExecutedOrders)(owner, this._chainId);\n      return orders.map(order => Object.assign(Object.assign({}, order), {\n        adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n      })).filter(order => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n    });\n  }\n\n  getCancelledOrders(owner) {\n    let includeOrdersWithNullHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const orders = yield (0, queries_1.queryCancelledOrders)(owner, this._chainId);\n      return orders.map(order => Object.assign(Object.assign({}, order), {\n        adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn)\n      })).filter(order => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n    });\n  }\n\n  _getKey(order) {\n    return ethers_1.utils.keccak256(this._abiEncoder.encode([\"address\", \"address\", \"address\", \"address\", \"bytes\"], [order.module, order.inputToken, order.owner, order.witness, order.data]));\n  }\n\n  _encodeSubmitData(inputToken, outputToken, owner, witness, amount, minReturn, secret, checkAllowance) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._provider) throw new Error(\"No provider\");\n      if (inputToken.toLowerCase() === outputToken.toLowerCase()) throw new Error(\"Input token and output token can not be equal\");\n      const encodedData = this._handlerAddress ? this._abiEncoder.encode([\"address\", \"uint256\", \"address\"], [outputToken, minReturn, this._handlerAddress]) : this._abiEncoder.encode([\"address\", \"uint256\"], [outputToken, minReturn]);\n      let data, value, to;\n\n      if ((0, utils_1.isNetworkGasToken)(inputToken)) {\n        const encodedEthOrder = yield this._gelatoLimitOrders.encodeEthOrder(this._moduleAddress, constants_1.ETH_ADDRESS, // we also use ETH_ADDRESS if it's MATIC\n        owner, witness, encodedData, secret);\n        data = this._gelatoLimitOrders.interface.encodeFunctionData(\"depositEth\", [encodedEthOrder]);\n        value = amount;\n        to = this._gelatoLimitOrders.address;\n      } else {\n        if (checkAllowance) {\n          const allowance = yield types_1.ERC20__factory.connect(inputToken, this._provider).allowance(owner, this._erc20OrderRouter.address);\n          if (allowance.lt(amount)) throw new Error(\"Insufficient token allowance for placing order\");\n        }\n\n        data = this._erc20OrderRouter.interface.encodeFunctionData(\"depositToken\", [amount, this._moduleAddress, inputToken, owner, witness, encodedData, secret]);\n        value = ethers_1.constants.Zero;\n        to = this._erc20OrderRouter.address;\n      }\n\n      return {\n        data,\n        value,\n        to\n      };\n    });\n  }\n\n}\n\nexports.GelatoLimitOrders = GelatoLimitOrders;","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/node_modules/@gelatonetwork/limit-orders-lib/dist/limit-orders/index.js"],"names":["Object","defineProperty","exports","value","GelatoLimitOrders","isFlashbotsCompatibleChainId","isValidChainIdAndHandler","tslib_1","require","ethers_1","abstract_provider_1","abstract_signer_1","constants_1","types_1","queries_1","utils_1","chainId","handler","NETWORK_HANDLERS","includes","CHAIN_ID","MAINNET","GOERLI","constructor","signerOrProvider","isFlashbotsProtected","_a","Error","_chainId","_gelatoFeeBPS","BPS_GELATO_FEE","_slippageBPS","LIMIT_ORDER_SLIPPAGE","_subgraphUrl","SUBGRAPH_URL","_signer","Signer","isSigner","undefined","_provider","Provider","isProvider","provider","_gelatoLimitOrders","GelatoLimitOrders__factory","connect","GELATO_LIMIT_ORDERS_ADDRESS","Contract","createInterface","_moduleAddress","GELATO_LIMIT_ORDERS_MODULE_FLASHBOTS_ADDRESS","GELATO_LIMIT_ORDERS_MODULE_ADDRESS","_handler","_handlerAddress","HANDLERS_ADDRESSES","toLowerCase","_isFlashbotsProtected","_abiEncoder","utils","AbiCoder","_erc20OrderRouter","ERC20OrderRouter__factory","GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER","gelatoFeeBPS","slippageBPS","signer","subgraphUrl","handlerAddress","moduleAddress","contract","erc20OrderRouter","encodeLimitOrderSubmission","inputToken","outputToken","inputAmount","minReturn","owner","checkAllowance","__awaiter","payload","encodeLimitOrderSubmissionWithSecret","minReturnToBeParsed","randomSecret","hexlify","randomBytes","replace","fullSecret","privateKey","secret","address","witness","Wallet","getFeeAndSlippageAdjustedMinReturn","_encodeSubmitData","encodedData","encode","order","id","_getKey","module","data","toString","adjustedMinReturn","inputData","submitLimitOrder","overrides","getAddress","txData","sendTransaction","assign","to","BigNumber","from","encodeLimitOrderCancellation","checkIsActiveOrder","isActiveOrder","interface","encodeFunctionData","constants","Zero","cancelLimitOrder","_order","subgraphOrder","Promise","race","getOrder","resolve","setTimeout","then","status","cancelledTxHash","executedTxHash","error","cancelOrder","gasLimit","isEthereumChain","approveTokenAmount","amount","ERC20__factory","approve","existOrder","getExchangeRate","inputValue","inputDecimals","outputValue","outputDecimals","invert","factor","pow","mul","div","outputAmount","extraSlippageBPS","Number","isInteger","gelatoFee","gte","slippage","sub","getAdjustedMinReturn","fees","add","getExecutionPrice","isInverted","orderId","queryOrder","getOrders","includeOrdersWithNullHandler","orders","queryOrders","map","filter","getOpenOrders","queryOpenOrders","getPastOrders","queryPastOrders","getExecutedOrders","queryExecutedOrders","getCancelledOrders","queryCancelledOrders","keccak256","isNetworkGasToken","encodedEthOrder","encodeEthOrder","ETH_ADDRESS","allowance","lt"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GelatoLimitOrders = exports.isFlashbotsCompatibleChainId = exports.isValidChainIdAndHandler = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ethers_1 = require(\"ethers\");\nconst abstract_provider_1 = require(\"@ethersproject/abstract-provider\");\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\nconst constants_1 = require(\"../constants\");\nconst types_1 = require(\"../contracts/types\");\nconst queries_1 = require(\"../utils/queries\");\nconst utils_1 = require(\"../utils\");\nconst isValidChainIdAndHandler = (chainId, handler) => {\n    return constants_1.NETWORK_HANDLERS[chainId].includes(handler);\n};\nexports.isValidChainIdAndHandler = isValidChainIdAndHandler;\nconst isFlashbotsCompatibleChainId = (chainId) => {\n    return chainId == constants_1.CHAIN_ID.MAINNET || chainId == constants_1.CHAIN_ID.GOERLI;\n};\nexports.isFlashbotsCompatibleChainId = isFlashbotsCompatibleChainId;\nclass GelatoLimitOrders {\n    constructor(chainId, signerOrProvider, handler, isFlashbotsProtected = false) {\n        var _a;\n        if (handler && !(0, exports.isValidChainIdAndHandler)(chainId, handler)) {\n            throw new Error(\"Invalid chainId and handler\");\n        }\n        else if (isFlashbotsProtected &&\n            (handler || !(0, exports.isFlashbotsCompatibleChainId)(chainId))) {\n            throw new Error(\"Invalid chainId or handler for Flashbots bundle submission. handler must be undefined, and chainId either 1 (mainnet) or 5 (goerli)\");\n        }\n        this._chainId = chainId;\n        this._gelatoFeeBPS = constants_1.BPS_GELATO_FEE[chainId];\n        this._slippageBPS = constants_1.LIMIT_ORDER_SLIPPAGE[chainId];\n        this._subgraphUrl = constants_1.SUBGRAPH_URL[chainId];\n        this._signer = abstract_signer_1.Signer.isSigner(signerOrProvider)\n            ? signerOrProvider\n            : undefined;\n        this._provider = abstract_provider_1.Provider.isProvider(signerOrProvider)\n            ? signerOrProvider\n            : abstract_signer_1.Signer.isSigner(signerOrProvider)\n                ? signerOrProvider.provider\n                : undefined;\n        this._gelatoLimitOrders = this._signer\n            ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._signer)\n            : this._provider\n                ? types_1.GelatoLimitOrders__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], this._provider)\n                : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ADDRESS[this._chainId], types_1.GelatoLimitOrders__factory.createInterface());\n        this._moduleAddress = isFlashbotsProtected\n            ? constants_1.GELATO_LIMIT_ORDERS_MODULE_FLASHBOTS_ADDRESS[this._chainId]\n            : constants_1.GELATO_LIMIT_ORDERS_MODULE_ADDRESS[this._chainId];\n        this._handler = handler;\n        this._handlerAddress = handler\n            ? (_a = constants_1.HANDLERS_ADDRESSES[this._chainId][handler]) === null || _a === void 0 ? void 0 : _a.toLowerCase()\n            : undefined;\n        this._isFlashbotsProtected = isFlashbotsProtected;\n        this._abiEncoder = new ethers_1.utils.AbiCoder();\n        this._erc20OrderRouter = this._signer\n            ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._signer)\n            : this._provider\n                ? types_1.ERC20OrderRouter__factory.connect(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], this._provider)\n                : new ethers_1.Contract(constants_1.GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId], types_1.ERC20OrderRouter__factory.createInterface());\n    }\n    get gelatoFeeBPS() {\n        return this._gelatoFeeBPS;\n    }\n    get slippageBPS() {\n        return this._slippageBPS;\n    }\n    get chainId() {\n        return this._chainId;\n    }\n    get signer() {\n        return this._signer;\n    }\n    get provider() {\n        return this._provider;\n    }\n    get subgraphUrl() {\n        return this._subgraphUrl;\n    }\n    get handler() {\n        return this._handler;\n    }\n    get handlerAddress() {\n        return this._handlerAddress;\n    }\n    get moduleAddress() {\n        return this._moduleAddress;\n    }\n    get contract() {\n        return this._gelatoLimitOrders;\n    }\n    get erc20OrderRouter() {\n        return this._erc20OrderRouter;\n    }\n    get isFlashbotsProtected() {\n        return this._isFlashbotsProtected;\n    }\n    encodeLimitOrderSubmission(inputToken, outputToken, inputAmount, minReturn, owner, checkAllowance = true) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const { payload } = yield this.encodeLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, minReturn, owner, checkAllowance);\n            return payload;\n        });\n    }\n    encodeLimitOrderSubmissionWithSecret(inputToken, outputToken, inputAmount, minReturnToBeParsed, owner, checkAllowance = true) {\n        var _a;\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const randomSecret = ethers_1.utils.hexlify(ethers_1.utils.randomBytes(19)).replace(\"0x\", \"\");\n            // 0x67656c61746f6e6574776f726b = gelatonetwork in hex\n            const fullSecret = `0x67656c61746f6e6574776f726b${randomSecret}`;\n            const { privateKey: secret, address: witness } = new ethers_1.Wallet(fullSecret);\n            const { minReturn } = this.getFeeAndSlippageAdjustedMinReturn(minReturnToBeParsed);\n            const payload = yield this._encodeSubmitData(inputToken, outputToken, owner, witness, inputAmount, minReturn, secret, checkAllowance);\n            const encodedData = this._handlerAddress\n                ? this._abiEncoder.encode([\"address\", \"uint256\", \"address\"], [outputToken, minReturn, this._handlerAddress])\n                : this._abiEncoder.encode([\"address\", \"uint256\"], [outputToken, minReturn]);\n            return {\n                payload,\n                secret,\n                witness,\n                order: {\n                    id: this._getKey({\n                        module: this._moduleAddress,\n                        inputToken,\n                        owner,\n                        witness,\n                        data: encodedData,\n                    }),\n                    module: this._moduleAddress.toLowerCase(),\n                    data: encodedData,\n                    inputToken: inputToken.toLowerCase(),\n                    outputToken: outputToken.toLowerCase(),\n                    owner: owner.toLowerCase(),\n                    witness: witness.toLowerCase(),\n                    inputAmount: inputAmount.toString(),\n                    minReturn: minReturn.toString(),\n                    adjustedMinReturn: minReturnToBeParsed.toString(),\n                    inputData: payload.data.toString(),\n                    secret: secret.toLowerCase(),\n                    handler: (_a = this._handlerAddress) !== null && _a !== void 0 ? _a : null,\n                },\n            };\n        });\n    }\n    submitLimitOrder(inputToken, outputToken, inputAmount, minReturn, checkAllowance = true, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._signer)\n                throw new Error(\"No signer\");\n            const owner = yield this._signer.getAddress();\n            const txData = yield this.encodeLimitOrderSubmission(inputToken, outputToken, inputAmount, minReturn, owner, checkAllowance);\n            return this._signer.sendTransaction(Object.assign(Object.assign({}, overrides), { to: txData.to, data: txData.data, value: ethers_1.BigNumber.from(txData.value) }));\n        });\n    }\n    encodeLimitOrderCancellation(order, checkIsActiveOrder) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._gelatoLimitOrders)\n                throw new Error(\"No gelato limit orders contract\");\n            if (!order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!order.witness)\n                throw new Error(\"No witness in order\");\n            if (!order.outputToken)\n                throw new Error(\"No output token in order\");\n            if (!order.minReturn)\n                throw new Error(\"No minReturn in order\");\n            if (!order.owner)\n                throw new Error(\"No owner\");\n            if (!order.module)\n                throw new Error(\"No module in order\");\n            if (checkIsActiveOrder) {\n                const isActiveOrder = yield this.isActiveOrder(order);\n                if (!isActiveOrder)\n                    throw new Error(\"Order not found. Please review your order data.\");\n            }\n            const data = this._gelatoLimitOrders.interface.encodeFunctionData(\"cancelOrder\", [order.module, order.inputToken, order.owner, order.witness, order.data]);\n            return {\n                data,\n                to: this._gelatoLimitOrders.address,\n                value: ethers_1.constants.Zero,\n            };\n        });\n    }\n    cancelLimitOrder(order, checkIsActiveOrder, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._signer)\n                throw new Error(\"No signer\");\n            if (!this._gelatoLimitOrders)\n                throw new Error(\"No gelato limit orders contract\");\n            let _order = order;\n            if (order.id) {\n                try {\n                    const subgraphOrder = yield Promise.race([\n                        this.getOrder(order.id),\n                        new Promise((resolve) => setTimeout(resolve, 5000)).then(() => {\n                            throw new Error(\"Timeout\");\n                        }),\n                    ]);\n                    if (subgraphOrder) {\n                        if (subgraphOrder.status === \"cancelled\") {\n                            throw new Error(`Order status is not open. Current order status: ${subgraphOrder.status}. Cancellation transaction hash: ${subgraphOrder.cancelledTxHash}`);\n                        }\n                        if (subgraphOrder.status === \"executed\") {\n                            throw new Error(`Order status is not open. Current order status: ${subgraphOrder.status}. Execution transaction hash: ${subgraphOrder.executedTxHash}`);\n                        }\n                        _order = Object.assign(Object.assign({}, order), subgraphOrder);\n                    }\n                    // eslint-disable-next-line no-empty\n                }\n                catch (error) { }\n            }\n            if (!_order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!_order.witness)\n                throw new Error(\"No witness in order\");\n            if (!_order.outputToken)\n                throw new Error(\"No output token in order\");\n            if (!_order.minReturn)\n                throw new Error(\"No minReturn in order\");\n            if (!_order.data)\n                throw new Error(\"No data in order\");\n            if (!_order.module)\n                throw new Error(\"No module in order\");\n            if (checkIsActiveOrder) {\n                const isActiveOrder = yield this.isActiveOrder(_order);\n                if (!isActiveOrder)\n                    throw new Error(\"Order not found. Please review your order data.\");\n            }\n            const owner = yield this._signer.getAddress();\n            if (owner.toLowerCase() !== order.owner.toLowerCase())\n                throw new Error(\"Owner and signer mismatch\");\n            return this._gelatoLimitOrders.cancelOrder(_order.module, _order.inputToken, _order.owner, _order.witness, _order.data, overrides !== null && overrides !== void 0 ? overrides : {\n                gasLimit: (0, utils_1.isEthereumChain)(this._chainId) ? 600000 : 2000000,\n            });\n        });\n    }\n    approveTokenAmount(inputToken, amount, overrides) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._signer)\n                throw new Error(\"No signer\");\n            return overrides\n                ? types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount, overrides)\n                : types_1.ERC20__factory.connect(inputToken, this._signer).approve(this._erc20OrderRouter.address, amount);\n        });\n    }\n    isActiveOrder(order) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._provider)\n                throw new Error(\"No provider\");\n            if (!this._gelatoLimitOrders)\n                throw new Error(\"No gelato limit orders contract\");\n            if (!order.module)\n                throw new Error(\"No module in order\");\n            if (!order.inputToken)\n                throw new Error(\"No input token in order\");\n            if (!order.owner)\n                throw new Error(\"No owner in order\");\n            if (!order.witness)\n                throw new Error(\"No witness in order\");\n            if (!order.data)\n                throw new Error(\"No data in order\");\n            return this._gelatoLimitOrders.existOrder(order.module, order.inputToken, order.owner, order.witness, order.data);\n        });\n    }\n    getExchangeRate(inputValue, inputDecimals, outputValue, outputDecimals, invert = false) {\n        const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(18));\n        if (invert) {\n            return ethers_1.BigNumber.from(inputValue)\n                .mul(factor)\n                .div(outputValue)\n                .mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals)))\n                .div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals)))\n                .toString();\n        }\n        else {\n            return ethers_1.BigNumber.from(outputValue)\n                .mul(factor)\n                .div(inputValue)\n                .mul(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(inputDecimals)))\n                .div(ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(outputDecimals)))\n                .toString();\n        }\n    }\n    getFeeAndSlippageAdjustedMinReturn(outputAmount, extraSlippageBPS) {\n        if (extraSlippageBPS) {\n            if (!Number.isInteger(extraSlippageBPS))\n                throw new Error(\"Extra Slippage BPS must an unsigned integer\");\n        }\n        const gelatoFee = ethers_1.BigNumber.from(outputAmount)\n            .mul(this._gelatoFeeBPS)\n            .div(10000)\n            .gte(1)\n            ? ethers_1.BigNumber.from(outputAmount).mul(this._gelatoFeeBPS).div(10000)\n            : ethers_1.BigNumber.from(1);\n        const slippageBPS = extraSlippageBPS\n            ? this._slippageBPS + extraSlippageBPS\n            : this._slippageBPS;\n        const slippage = ethers_1.BigNumber.from(outputAmount).mul(slippageBPS).div(10000);\n        const minReturn = ethers_1.BigNumber.from(outputAmount).sub(gelatoFee).sub(slippage);\n        return {\n            minReturn: minReturn.toString(),\n            slippage: slippage.toString(),\n            gelatoFee: gelatoFee.toString(),\n        };\n    }\n    getAdjustedMinReturn(minReturn, extraSlippageBPS) {\n        const gelatoFee = ethers_1.BigNumber.from(this._gelatoFeeBPS);\n        const slippage = extraSlippageBPS\n            ? ethers_1.BigNumber.from(this._slippageBPS + extraSlippageBPS)\n            : ethers_1.BigNumber.from(this._slippageBPS);\n        const fees = gelatoFee.add(slippage);\n        const adjustedMinReturn = ethers_1.BigNumber.from(minReturn)\n            .mul(10000)\n            .div(ethers_1.BigNumber.from(10000).sub(fees));\n        return adjustedMinReturn.toString();\n    }\n    getExecutionPrice(inputAmount, inputDecimals, outputAmount, outputDecimals, isInverted = false) {\n        const factor = ethers_1.BigNumber.from(10).pow(ethers_1.BigNumber.from(isInverted ? outputDecimals : inputDecimals));\n        if (isInverted) {\n            return ethers_1.BigNumber.from(inputAmount)\n                .mul(factor)\n                .div(outputAmount)\n                .toString();\n        }\n        else {\n            return ethers_1.BigNumber.from(outputAmount)\n                .mul(factor)\n                .div(inputAmount)\n                .toString();\n        }\n    }\n    getOrder(orderId) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const order = yield (0, queries_1.queryOrder)(orderId, this._chainId);\n            if (order) {\n                return Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) });\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    getOrders(owner, includeOrdersWithNullHandler = false) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, queries_1.queryOrders)(owner, this._chainId);\n            return orders\n                .map((order) => (Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) })))\n                .filter((order) => {\n                if (this._handler && !order.handler) {\n                    return includeOrdersWithNullHandler ? true : false;\n                }\n                else {\n                    return this._handler ? order.handler === this._handlerAddress : true;\n                }\n            });\n        });\n    }\n    getOpenOrders(owner, includeOrdersWithNullHandler = false) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, queries_1.queryOpenOrders)(owner, this._chainId);\n            return orders\n                .map((order) => (Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) })))\n                .filter((order) => {\n                if (this._handler && !order.handler) {\n                    return includeOrdersWithNullHandler ? true : false;\n                }\n                else {\n                    return this._handler ? order.handler === this._handlerAddress : true;\n                }\n            });\n        });\n    }\n    getPastOrders(owner, includeOrdersWithNullHandler = false) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, queries_1.queryPastOrders)(owner, this._chainId);\n            return orders\n                .map((order) => (Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) })))\n                .filter((order) => {\n                if (this._handler && !order.handler) {\n                    return includeOrdersWithNullHandler ? true : false;\n                }\n                else {\n                    return this._handler ? order.handler === this._handlerAddress : true;\n                }\n            });\n        });\n    }\n    getExecutedOrders(owner, includeOrdersWithNullHandler = false) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, queries_1.queryExecutedOrders)(owner, this._chainId);\n            return orders\n                .map((order) => (Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) })))\n                .filter((order) => {\n                if (this._handler && !order.handler) {\n                    return includeOrdersWithNullHandler ? true : false;\n                }\n                else {\n                    return this._handler ? order.handler === this._handlerAddress : true;\n                }\n            });\n        });\n    }\n    getCancelledOrders(owner, includeOrdersWithNullHandler = false) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const orders = yield (0, queries_1.queryCancelledOrders)(owner, this._chainId);\n            return orders\n                .map((order) => (Object.assign(Object.assign({}, order), { adjustedMinReturn: this.getAdjustedMinReturn(order.minReturn) })))\n                .filter((order) => {\n                if (this._handler && !order.handler) {\n                    return includeOrdersWithNullHandler ? true : false;\n                }\n                else {\n                    return this._handler ? order.handler === this._handlerAddress : true;\n                }\n            });\n        });\n    }\n    _getKey(order) {\n        return ethers_1.utils.keccak256(this._abiEncoder.encode([\"address\", \"address\", \"address\", \"address\", \"bytes\"], [order.module, order.inputToken, order.owner, order.witness, order.data]));\n    }\n    _encodeSubmitData(inputToken, outputToken, owner, witness, amount, minReturn, secret, checkAllowance) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._provider)\n                throw new Error(\"No provider\");\n            if (inputToken.toLowerCase() === outputToken.toLowerCase())\n                throw new Error(\"Input token and output token can not be equal\");\n            const encodedData = this._handlerAddress\n                ? this._abiEncoder.encode([\"address\", \"uint256\", \"address\"], [outputToken, minReturn, this._handlerAddress])\n                : this._abiEncoder.encode([\"address\", \"uint256\"], [outputToken, minReturn]);\n            let data, value, to;\n            if ((0, utils_1.isNetworkGasToken)(inputToken)) {\n                const encodedEthOrder = yield this._gelatoLimitOrders.encodeEthOrder(this._moduleAddress, constants_1.ETH_ADDRESS, // we also use ETH_ADDRESS if it's MATIC\n                owner, witness, encodedData, secret);\n                data = this._gelatoLimitOrders.interface.encodeFunctionData(\"depositEth\", [encodedEthOrder]);\n                value = amount;\n                to = this._gelatoLimitOrders.address;\n            }\n            else {\n                if (checkAllowance) {\n                    const allowance = yield types_1.ERC20__factory.connect(inputToken, this._provider).allowance(owner, this._erc20OrderRouter.address);\n                    if (allowance.lt(amount))\n                        throw new Error(\"Insufficient token allowance for placing order\");\n                }\n                data = this._erc20OrderRouter.interface.encodeFunctionData(\"depositToken\", [\n                    amount,\n                    this._moduleAddress,\n                    inputToken,\n                    owner,\n                    witness,\n                    encodedData,\n                    secret,\n                ]);\n                value = ethers_1.constants.Zero;\n                to = this._erc20OrderRouter.address;\n            }\n            return { data, value, to };\n        });\n    }\n}\nexports.GelatoLimitOrders = GelatoLimitOrders;\n"]},"metadata":{},"sourceType":"script"}