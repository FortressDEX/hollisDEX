{"ast":null,"code":"import { Contract } from '@ethersproject/contracts';\nimport { getAddress } from '@ethersproject/address';\nimport { AddressZero } from '@ethersproject/constants';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport IPangolinRouter from '@pangolindex/exchange-contracts/artifacts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol/IPangolinRouter.json';\nimport { ROUTER_ADDRESS } from '../constants';\nimport { JSBI, Percent, Token, CAVAX, currencyEquals } from '@pangolindex/sdk';\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value) {\n  try {\n    return getAddress(value);\n  } catch {\n    return false;\n  }\n}\nconst ETHERSCAN_PREFIXES = {\n  43113: 'https://testnet.snowtrace.io',\n  137: 'https://polygonscan.com',\n  11111: 'https://ftmscan.com/'\n};\nexport function getEtherscanLink(chainId, data, type) {\n  const prefix = `${ETHERSCAN_PREFIXES[chainId] || ETHERSCAN_PREFIXES[137]}`;\n\n  switch (type) {\n    case 'transaction':\n      {\n        return `${prefix}/tx/${data}`;\n      }\n\n    case 'token':\n      {\n        return `${prefix}/token/${data}`;\n      }\n\n    case 'block':\n      {\n        return `${prefix}/block/${data}`;\n      }\n\n    case 'address':\n    default:\n      {\n        return `${prefix}/address/${data}`;\n      }\n  }\n} // shorten the checksummed version of the input address to have 0x + 4 characters at start and end\n\nexport function shortenAddress(address) {\n  let chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  const parsed = isAddress(address);\n\n  if (!parsed) {\n    throw Error(`Invalid 'address' parameter '${address}'.`);\n  }\n\n  return `${parsed.substring(0, chars + 2)}...${parsed.substring(42 - chars)}`;\n} // add 10%\n\nexport function calculateGasMargin(value) {\n  return value.mul(BigNumber.from(10000).add(BigNumber.from(1000))).div(BigNumber.from(10000));\n} // converts a basis points value to a sdk percent\n\nexport function basisPointsToPercent(num) {\n  return new Percent(JSBI.BigInt(num), JSBI.BigInt(10000));\n}\nexport function calculateSlippageAmount(value, slippage) {\n  if (slippage < 0 || slippage > 10000) {\n    throw Error(`Unexpected slippage value: ${slippage}`);\n  }\n\n  return [JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 - slippage)), JSBI.BigInt(10000)), JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 + slippage)), JSBI.BigInt(10000))];\n} // account is not optional\n\nexport function getSigner(library, account) {\n  return library.getSigner(account).connectUnchecked();\n} // account is optional\n\nexport function getProviderOrSigner(library, account) {\n  return account ? getSigner(library, account) : library;\n} // account is optional\n\nexport function getContract(address, ABI, library, account) {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`);\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account));\n} // account is optional\n\nexport function getRouterContract(chainId, library, account) {\n  return getContract(ROUTER_ADDRESS[chainId], IPangolinRouter.abi, library, account);\n}\nexport function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\nexport function isTokenOnList(defaultTokens, chainId, currency) {\n  var _defaultTokens$curren;\n\n  if (chainId && currency === CAVAX[chainId]) return true;\n  return Boolean(currency instanceof Token && ((_defaultTokens$curren = defaultTokens[currency.chainId]) === null || _defaultTokens$curren === void 0 ? void 0 : _defaultTokens$curren[currency.address]));\n}\n/**\n * Returns true if the trade requires a confirmation of details before we can submit it\n * @param tradeA trade A\n * @param tradeB trade B\n */\n\nexport function tradeMeaningfullyDiffers(tradeA, tradeB) {\n  return tradeA.tradeType !== tradeB.tradeType || !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) || !tradeA.inputAmount.equalTo(tradeB.inputAmount) || !currencyEquals(tradeA.outputAmount.currency, tradeB.outputAmount.currency) || !tradeA.outputAmount.equalTo(tradeB.outputAmount);\n}","map":{"version":3,"sources":["/Users/safahi/Documents/GitHub/interface/hollisDEX/src/utils/index.ts"],"names":["Contract","getAddress","AddressZero","BigNumber","IPangolinRouter","ROUTER_ADDRESS","JSBI","Percent","Token","CAVAX","currencyEquals","isAddress","value","ETHERSCAN_PREFIXES","getEtherscanLink","chainId","data","type","prefix","shortenAddress","address","chars","parsed","Error","substring","calculateGasMargin","mul","from","add","div","basisPointsToPercent","num","BigInt","calculateSlippageAmount","slippage","divide","multiply","raw","getSigner","library","account","connectUnchecked","getProviderOrSigner","getContract","ABI","getRouterContract","abi","escapeRegExp","string","replace","isTokenOnList","defaultTokens","currency","Boolean","tradeMeaningfullyDiffers","tradeA","tradeB","tradeType","inputAmount","equalTo","outputAmount"],"mappings":"AAAA,SAASA,QAAT,QAAyB,0BAAzB;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,WAAT,QAA4B,0BAA5B;AAEA,SAASC,SAAT,QAA0B,0BAA1B;AACA,OAAOC,eAAP,MAA4B,4HAA5B;AACA,SAASC,cAAT,QAA+B,cAA/B;AACA,SAAkBC,IAAlB,EAAwBC,OAAxB,EAAiCC,KAAjC,EAAkEC,KAAlE,EAAyEC,cAAzE,QAAsG,kBAAtG;AAGA;AACA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA+C;AACpD,MAAI;AACF,WAAOX,UAAU,CAACW,KAAD,CAAjB;AACD,GAFD,CAEE,MAAM;AACN,WAAO,KAAP;AACD;AACF;AAED,MAAMC,kBAAoD,GAAG;AAC3D,SAAO,8BADoD;AAE3D,OAAK,yBAFsD;AAG3D,SAAO;AAHoD,CAA7D;AAMA,OAAO,SAASC,gBAAT,CACLC,OADK,EAELC,IAFK,EAGLC,IAHK,EAIG;AACR,QAAMC,MAAM,GAAI,GAAEL,kBAAkB,CAACE,OAAD,CAAlB,IAA+BF,kBAAkB,CAAC,GAAD,CAAM,EAAzE;;AAEA,UAAQI,IAAR;AACE,SAAK,aAAL;AAAoB;AAClB,eAAQ,GAAEC,MAAO,OAAMF,IAAK,EAA5B;AACD;;AACD,SAAK,OAAL;AAAc;AACZ,eAAQ,GAAEE,MAAO,UAASF,IAAK,EAA/B;AACD;;AACD,SAAK,OAAL;AAAc;AACZ,eAAQ,GAAEE,MAAO,UAASF,IAAK,EAA/B;AACD;;AACD,SAAK,SAAL;AACA;AAAS;AACP,eAAQ,GAAEE,MAAO,YAAWF,IAAK,EAAjC;AACD;AAbH;AAeD,C,CAED;;AACA,OAAO,SAASG,cAAT,CAAwBC,OAAxB,EAA4D;AAAA,MAAnBC,KAAmB,uEAAX,CAAW;AACjE,QAAMC,MAAM,GAAGX,SAAS,CAACS,OAAD,CAAxB;;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAMC,KAAK,CAAE,gCAA+BH,OAAQ,IAAzC,CAAX;AACD;;AACD,SAAQ,GAAEE,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBH,KAAK,GAAG,CAA5B,CAA+B,MAAKC,MAAM,CAACE,SAAP,CAAiB,KAAKH,KAAtB,CAA6B,EAA3E;AACD,C,CAED;;AACA,OAAO,SAASI,kBAAT,CAA4Bb,KAA5B,EAAyD;AAC9D,SAAOA,KAAK,CAACc,GAAN,CAAUvB,SAAS,CAACwB,IAAV,CAAe,KAAf,EAAsBC,GAAtB,CAA0BzB,SAAS,CAACwB,IAAV,CAAe,IAAf,CAA1B,CAAV,EAA2DE,GAA3D,CAA+D1B,SAAS,CAACwB,IAAV,CAAe,KAAf,CAA/D,CAAP;AACD,C,CAED;;AACA,OAAO,SAASG,oBAAT,CAA8BC,GAA9B,EAAoD;AACzD,SAAO,IAAIxB,OAAJ,CAAYD,IAAI,CAAC0B,MAAL,CAAYD,GAAZ,CAAZ,EAA8BzB,IAAI,CAAC0B,MAAL,CAAY,KAAZ,CAA9B,CAAP;AACD;AAED,OAAO,SAASC,uBAAT,CAAiCrB,KAAjC,EAAwDsB,QAAxD,EAAwF;AAC7F,MAAIA,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAG,KAA/B,EAAsC;AACpC,UAAMX,KAAK,CAAE,8BAA6BW,QAAS,EAAxC,CAAX;AACD;;AACD,SAAO,CACL5B,IAAI,CAAC6B,MAAL,CAAY7B,IAAI,CAAC8B,QAAL,CAAcxB,KAAK,CAACyB,GAApB,EAAyB/B,IAAI,CAAC0B,MAAL,CAAY,QAAQE,QAApB,CAAzB,CAAZ,EAAqE5B,IAAI,CAAC0B,MAAL,CAAY,KAAZ,CAArE,CADK,EAEL1B,IAAI,CAAC6B,MAAL,CAAY7B,IAAI,CAAC8B,QAAL,CAAcxB,KAAK,CAACyB,GAApB,EAAyB/B,IAAI,CAAC0B,MAAL,CAAY,QAAQE,QAApB,CAAzB,CAAZ,EAAqE5B,IAAI,CAAC0B,MAAL,CAAY,KAAZ,CAArE,CAFK,CAAP;AAID,C,CAED;;AACA,OAAO,SAASM,SAAT,CAAmBC,OAAnB,EAA0CC,OAA1C,EAA0E;AAC/E,SAAOD,OAAO,CAACD,SAAR,CAAkBE,OAAlB,EAA2BC,gBAA3B,EAAP;AACD,C,CAED;;AACA,OAAO,SAASC,mBAAT,CAA6BH,OAA7B,EAAoDC,OAApD,EAAoG;AACzG,SAAOA,OAAO,GAAGF,SAAS,CAACC,OAAD,EAAUC,OAAV,CAAZ,GAAiCD,OAA/C;AACD,C,CAED;;AACA,OAAO,SAASI,WAAT,CAAqBvB,OAArB,EAAsCwB,GAAtC,EAAgDL,OAAhD,EAAuEC,OAAvE,EAAmG;AACxG,MAAI,CAAC7B,SAAS,CAACS,OAAD,CAAV,IAAuBA,OAAO,KAAKlB,WAAvC,EAAoD;AAClD,UAAMqB,KAAK,CAAE,gCAA+BH,OAAQ,IAAzC,CAAX;AACD;;AAED,SAAO,IAAIpB,QAAJ,CAAaoB,OAAb,EAAsBwB,GAAtB,EAA2BF,mBAAmB,CAACH,OAAD,EAAUC,OAAV,CAA9C,CAAP;AACD,C,CAED;;AACA,OAAO,SAASK,iBAAT,CAA2B9B,OAA3B,EAA6CwB,OAA7C,EAAoEC,OAApE,EAAgG;AACrG,SAAOG,WAAW,CAACtC,cAAc,CAACU,OAAD,CAAf,EAA0BX,eAAe,CAAC0C,GAA1C,EAA+CP,OAA/C,EAAwDC,OAAxD,CAAlB;AACD;AAED,OAAO,SAASO,YAAT,CAAsBC,MAAtB,EAA8C;AACnD,SAAOA,MAAM,CAACC,OAAP,CAAe,qBAAf,EAAsC,MAAtC,CAAP,CADmD,CACE;AACtD;AAED,OAAO,SAASC,aAAT,CAAuBC,aAAvB,EAAuDpC,OAAvD,EAAyEqC,QAAzE,EAAuG;AAAA;;AAC5G,MAAIrC,OAAO,IAAIqC,QAAQ,KAAK3C,KAAK,CAACM,OAAD,CAAjC,EAA4C,OAAO,IAAP;AAC5C,SAAOsC,OAAO,CAACD,QAAQ,YAAY5C,KAApB,8BAA6B2C,aAAa,CAACC,QAAQ,CAACrC,OAAV,CAA1C,0DAA6B,sBAAkCqC,QAAQ,CAAChC,OAA3C,CAA7B,CAAD,CAAd;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkC,wBAAT,CAAkCC,MAAlC,EAAiDC,MAAjD,EAAyE;AAC9E,SACED,MAAM,CAACE,SAAP,KAAqBD,MAAM,CAACC,SAA5B,IACA,CAAC/C,cAAc,CAAC6C,MAAM,CAACG,WAAP,CAAmBN,QAApB,EAA8BI,MAAM,CAACE,WAAP,CAAmBN,QAAjD,CADf,IAEA,CAACG,MAAM,CAACG,WAAP,CAAmBC,OAAnB,CAA2BH,MAAM,CAACE,WAAlC,CAFD,IAGA,CAAChD,cAAc,CAAC6C,MAAM,CAACK,YAAP,CAAoBR,QAArB,EAA+BI,MAAM,CAACI,YAAP,CAAoBR,QAAnD,CAHf,IAIA,CAACG,MAAM,CAACK,YAAP,CAAoBD,OAApB,CAA4BH,MAAM,CAACI,YAAnC,CALH;AAOD","sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { getAddress } from '@ethersproject/address'\nimport { AddressZero } from '@ethersproject/constants'\nimport { JsonRpcSigner, Web3Provider } from '@ethersproject/providers'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport IPangolinRouter from '@pangolindex/exchange-contracts/artifacts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol/IPangolinRouter.json'\nimport { ROUTER_ADDRESS } from '../constants'\nimport { ChainId, JSBI, Percent, Token, CurrencyAmount, Currency, CAVAX, currencyEquals, Trade } from '@pangolindex/sdk'\nimport { TokenAddressMap } from '../state/lists/hooks'\n\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value: any): string | false {\n  try {\n    return getAddress(value)\n  } catch {\n    return false\n  }\n}\n\nconst ETHERSCAN_PREFIXES: { [chainId in ChainId]: string } = {\n  43113: 'https://testnet.snowtrace.io',\n  137: 'https://polygonscan.com',\n  11111: 'https://ftmscan.com/'\n}\n\nexport function getEtherscanLink(\n  chainId: ChainId,\n  data: string,\n  type: 'transaction' | 'token' | 'address' | 'block'\n): string {\n  const prefix = `${ETHERSCAN_PREFIXES[chainId] || ETHERSCAN_PREFIXES[137]}`\n\n  switch (type) {\n    case 'transaction': {\n      return `${prefix}/tx/${data}`\n    }\n    case 'token': {\n      return `${prefix}/token/${data}`\n    }\n    case 'block': {\n      return `${prefix}/block/${data}`\n    }\n    case 'address':\n    default: {\n      return `${prefix}/address/${data}`\n    }\n  }\n}\n\n// shorten the checksummed version of the input address to have 0x + 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  const parsed = isAddress(address)\n  if (!parsed) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n  return `${parsed.substring(0, chars + 2)}...${parsed.substring(42 - chars)}`\n}\n\n// add 10%\nexport function calculateGasMargin(value: BigNumber): BigNumber {\n  return value.mul(BigNumber.from(10000).add(BigNumber.from(1000))).div(BigNumber.from(10000))\n}\n\n// converts a basis points value to a sdk percent\nexport function basisPointsToPercent(num: number): Percent {\n  return new Percent(JSBI.BigInt(num), JSBI.BigInt(10000))\n}\n\nexport function calculateSlippageAmount(value: CurrencyAmount, slippage: number): [JSBI, JSBI] {\n  if (slippage < 0 || slippage > 10000) {\n    throw Error(`Unexpected slippage value: ${slippage}`)\n  }\n  return [\n    JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 - slippage)), JSBI.BigInt(10000)),\n    JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 + slippage)), JSBI.BigInt(10000))\n  ]\n}\n\n// account is not optional\nexport function getSigner(library: Web3Provider, account: string): JsonRpcSigner {\n  return library.getSigner(account).connectUnchecked()\n}\n\n// account is optional\nexport function getProviderOrSigner(library: Web3Provider, account?: string): Web3Provider | JsonRpcSigner {\n  return account ? getSigner(library, account) : library\n}\n\n// account is optional\nexport function getContract(address: string, ABI: any, library: Web3Provider, account?: string): Contract {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account) as any)\n}\n\n// account is optional\nexport function getRouterContract(chainId: ChainId, library: Web3Provider, account?: string): Contract {\n  return getContract(ROUTER_ADDRESS[chainId], IPangolinRouter.abi, library, account)\n}\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\n\nexport function isTokenOnList(defaultTokens: TokenAddressMap, chainId: ChainId, currency?: Currency): boolean {\n  if (chainId && currency === CAVAX[chainId]) return true\n  return Boolean(currency instanceof Token && defaultTokens[currency.chainId]?.[currency.address])\n}\n\n/**\n * Returns true if the trade requires a confirmation of details before we can submit it\n * @param tradeA trade A\n * @param tradeB trade B\n */\nexport function tradeMeaningfullyDiffers(tradeA: Trade, tradeB: Trade): boolean {\n  return (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) ||\n    !tradeA.inputAmount.equalTo(tradeB.inputAmount) ||\n    !currencyEquals(tradeA.outputAmount.currency, tradeB.outputAmount.currency) ||\n    !tradeA.outputAmount.equalTo(tradeB.outputAmount)\n  )\n}\n"]},"metadata":{},"sourceType":"module"}