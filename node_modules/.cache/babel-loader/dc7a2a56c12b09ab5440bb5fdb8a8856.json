{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nexport var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\n\nexport function parseRetryAfterHeader(header, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  var headerDelay = parseInt(\"\" + header, 10);\n\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  var headerDate = Date.parse(\"\" + header);\n\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\n\nexport function disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n/**\n * Checks if a category is rate limited\n */\n\nexport function isRateLimited(limits, category, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  return disabledUntil(limits, category) > now;\n}\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\n\nexport function updateRateLimits(limits, headers, now) {\n  var e_1, _a, e_2, _b;\n\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  var updatedRateLimits = __assign({}, limits); // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n\n\n  var rateLimitHeader = headers['x-sentry-rate-limits'];\n  var retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    try {\n      /**\n       * rate limit headers are of the form\n       *     <header>,<header>,..\n       * where each <header> is of the form\n       *     <retry_after>: <categories>: <scope>: <reason_code>\n       * where\n       *     <retry_after> is a delay in seconds\n       *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n       *         <category>;<category>;...\n       *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n       *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n       */\n      for (var _c = __values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var limit = _d.value;\n        var parameters = limit.split(':', 2);\n        var headerDelay = parseInt(parameters[0], 10);\n        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n\n        if (!parameters[1]) {\n          updatedRateLimits.all = now + delay;\n        } else {\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              updatedRateLimits[category] = now + delay;\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}","map":{"version":3,"sources":["../src/ratelimit.ts"],"names":[],"mappings":"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","sourcesContent":["// Keeping the key broad until we add the new transports\nexport type RateLimits = Record<string, number>;\n\nexport const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nexport function parseRetryAfterHeader(header: string, now: number = Date.now()): number {\n  const headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  const headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nexport function disabledUntil(limits: RateLimits, category: string): number {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nexport function isRateLimited(limits: RateLimits, category: string, now: number = Date.now()): boolean {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nexport function updateRateLimits(\n  limits: RateLimits,\n  headers: Record<string, string | null | undefined>,\n  now: number = Date.now(),\n): RateLimits {\n  const updatedRateLimits: RateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  const rateLimitHeader = headers['x-sentry-rate-limits'];\n  const retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (const limit of rateLimitHeader.trim().split(',')) {\n      const parameters = limit.split(':', 2);\n      const headerDelay = parseInt(parameters[0], 10);\n      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!parameters[1]) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (const category of parameters[1].split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}